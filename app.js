import 'dotenv/config';
import express from 'express';
import fetch from 'node-fetch';
import crypto from 'crypto';
import {
  InteractionType,
  InteractionResponseType,
  InteractionResponseFlags,
  MessageComponentTypes,
  ButtonStyleTypes,
  verifyKeyMiddleware,
} from 'discord-interactions';
import { 
  Client, 
  GatewayIntentBits, 
  EmbedBuilder, 
  SnowflakeUtil, 
  PermissionFlagsBits,
  ActionRowBuilder,
  ButtonBuilder,
  ButtonStyle,
  ModalBuilder,
  TextInputBuilder,
  TextInputStyle,
  StringSelectMenuBuilder,
  UserSelectMenuBuilder,
  RoleSelectMenuBuilder,
  ChannelSelectMenuBuilder,
  ComponentType,
  ChannelType,
  Partials,
  Options
} from 'discord.js';
import { capitalize, DiscordRequest } from './utils.js';  // Add DiscordRequest to imports
import { discordLogTags } from './src/utils/discordLogTags.js';  // Educational logging tags
import { 
  loadPlayerData, 
  updatePlayer, 
  getPlayer, 
  saveAllPlayerData,
  getGuildTribes,
  savePlayerData,    // Add this import
  getGuildPronouns,  // Add this import
  updateGuildPronouns, // Add this import
  getGuildTimezones, // Add this import
  getTimezoneOffset, // Add this import
  loadEnvironmentConfig,
  updateLiveLoggingStatus,
  getLoggingChannelId,
  saveReactionMapping,
  getReactionMapping,
  deleteReactionMapping,
  loadAllReactionMappings,
  cleanupOldReactionMappings,
  getAllApplicationsFromData,
  getApplicationsForSeason
} from './storage.js';
import {
  createApplicationButtonModal,
  handleApplicationButtonModalSubmit,
  createApplicationChannel,
  getApplicationConfig,
  saveApplicationConfig,
  createApplicationButton,
  createApplicationSetupContainer,
  BUTTON_STYLES
} from './applicationManager.js';
import { logInteraction, setDiscordClient } from './src/analytics/analyticsLogger.js';
import { logger } from './logger.js';
import { getPM2ErrorLogger } from './src/monitoring/pm2ErrorLogger.js';
import {
  calculateComponentsForTribe,
  determineDisplayScenario,
  calculateTribePages,
  createNavigationState,
  reorderTribes,
  createTribeSection,
  createNavigationButtons,
  processMemberData,
  createCastlistV2Layout,
  createPlayerCard,
  extractCastlistData,
  createCastlistRows,
  buildCastlist2ResponseData
} from './castlistV2.js';
import { MenuBuilder } from './menuBuilder.js';
import { scheduler } from './scheduler.js';
import { createBackButton } from './src/ui/backButtonFactory.js';
import {
  PlayerManagementMode,
  PlayerButtonType,
  createPlayerManagementUI,
  createPlayerDisplaySection,
  createManagementButtons,
  createAgeModal,
  handlePlayerButtonClick,
  handlePlayerModalSubmit
} from './playerManagement.js';
import {
  executeSetup,
  generateSetupResponse,
  generateSetupResponseV2,
  checkRoleHierarchy,
  REACTION_EMOJIS,
  createTimezoneReactionMessage,
  createPronounReactionMessage,
  canBotManageRole,
  canBotManageRoles,
  generateHierarchyWarning,
  testRoleHierarchy,
  checkForDuplicateTimezones,
  consolidateTimezoneRoles,
  buildPronounsViewMenu,
  buildTimezonesViewMenu,
  buildTimezoneEditMenu,
  buildTribesViewMenu,
  ensureBanRole,
  updateReactionMappingsForRole
} from './roleManager.js';
import { 
  createPlayerInventoryDisplay,
  createRoundResultsV2 
} from './safariManager.js';
import {
  ButtonHandlerFactory,
  ButtonRegistry,
  MenuFactory,
  BUTTON_REGISTRY,
  MENU_FACTORY,
  sendDeferredResponse,
  updateDeferredResponse
} from './buttonHandlerFactory.js';
import { createEntityManagementUI } from './entityManagementUI.js';
import { formatBotEmoji } from './botEmojis.js';
import { createCastlistMenu } from './castlistMenu.js';
import {
  deleteMapGrid,
  createMapExplorerMenu
} from './mapExplorer.js';
import { shouldLog } from './src/utils/logConfig.js';

// Helper function to refresh question management UI
/**
 * Build question management UI data (for ButtonHandlerFactory handlers)
 * @param {Object} config - Season configuration
 * @param {string} configId - Configuration ID
 * @param {number} currentPage - Current page number
 * @returns {Object} Components data structure (no response wrapper)
 */
function buildQuestionManagementUI(config, configId, currentPage = 0) {
  console.log(`üîß DEBUG: buildQuestionManagementUI called with configId: ${configId}, currentPage: ${currentPage}`);

  // Validate required parameters
  if (!configId) {
    console.error('üö® ERROR: configId is undefined in buildQuestionManagementUI');
    return {
      content: '‚ùå Internal error: Missing configuration ID.',
      ephemeral: true
    };
  }

  const questionsPerPage = 5;
  const totalPages = Math.max(1, Math.ceil(config.questions.length / questionsPerPage));
  const startIndex = currentPage * questionsPerPage;
  const endIndex = Math.min(startIndex + questionsPerPage, config.questions.length);
  
  const refreshedComponents = [];
  
  // Title with pagination info
  const pageInfo = config.questions.length <= questionsPerPage
    ? ''
    : ` \`Page ${currentPage + 1}/${totalPages}\``;

  refreshedComponents.push({
    type: 10, // Text Display
    content: `## :pencil: Season Applications | Manage Season Casting\n### :question: Manage Questions (${config.seasonName})${pageInfo}`
  });
  
  if (config.questions.length === 0) {
    refreshedComponents.push({
      type: 10, // Text Display
      content: '*No questions defined yet*'
    });
  } else {
    // Show only questions for current page
    for (let i = startIndex; i < endIndex; i++) {
      const question = config.questions[i];
      const maxTitleLength = 50;
      const displayTitle = question.questionTitle.length > maxTitleLength 
        ? question.questionTitle.substring(0, maxTitleLength) + '...'
        : question.questionTitle;
      
      const isLastQuestionInEditor = i === config.questions.length - 1;
      refreshedComponents.push({
        type: 10, // Text Display
        content: `**${isLastQuestionInEditor ? 'Last Question' : `Q${i + 1}.`}** ${displayTitle}`
      });
      
      const questionRow = {
        type: 1, // Action Row
        components: [
          {
            type: 2, // Button
            custom_id: `season_question_edit_${configId}_${i}_${currentPage}`,
            label: 'Edit',
            style: 2, // Secondary
            emoji: { name: '‚úèÔ∏è' }
          },
          {
            type: 2, // Button
            custom_id: `season_question_up_${configId}_${i}_${currentPage}`,
            label: ' ',
            style: 2, // Secondary
            emoji: { name: '‚¨ÜÔ∏è' },
            disabled: i === 0
          },
          {
            type: 2, // Button
            custom_id: `season_question_down_${configId}_${i}_${currentPage}`,
            label: ' ',
            style: 2, // Secondary
            emoji: { name: '‚¨áÔ∏è' },
            disabled: i === config.questions.length - 1
          },
          {
            type: 2, // Button
            custom_id: `season_question_delete_${configId}_${i}_${currentPage}`,
            label: 'Delete',
            style: 4, // Danger
            emoji: { name: 'üóëÔ∏è' }
          }
        ]
      };
      
      refreshedComponents.push(questionRow);
    }
  }
  
  const managementRow = {
    type: 1, // Action Row
    components: [
      {
        type: 2, // Button
        custom_id: `season_new_question_${configId}_${currentPage}`,
        label: 'New Question',
        style: 2, // Secondary
        emoji: { name: '‚ú®' }
      },
      {
        type: 2, // Button
        custom_id: `season_post_button_${configId}_${currentPage}`,
        label: 'Post Apps Button',
        style: 2, // Secondary
        emoji: { name: '‚úÖ' }
      },
      {
        type: 2, // Button
        custom_id: `season_app_ranking_${configId}`,
        label: 'Cast Ranking',
        style: 2, // Secondary
        emoji: { name: 'üèÜ' }
      }
    ]
  };
  
  refreshedComponents.push(managementRow);
  
  const refreshedContainer = {
    type: 17, // Container
    accent_color: 0xf39c12,
    components: refreshedComponents
  };
  
  // Create navigation buttons below the container (Components V2 format)
  const navComponents = [];
  
  if (config.questions.length > questionsPerPage) {
    const prevDisabled = currentPage === 0;
    const nextDisabled = currentPage === totalPages - 1;
    
    const navRow = {
      type: 1, // Action Row
      components: [
        {
          type: 2, // Button
          custom_id: `season_nav_prev_${configId}_${currentPage}`,
          label: "‚óÄ Previous",
          style: prevDisabled ? 2 : 1, // Secondary : Primary
          disabled: prevDisabled
        },
        {
          type: 2, // Button
          custom_id: `season_nav_next_${configId}_${currentPage}`,
          label: "Next ‚ñ∂",
          style: nextDisabled ? 2 : 1, // Secondary : Primary
          disabled: nextDisabled
        },
        // Delete Season button commented out - castlists can now link to seasons
        // Uncomment when we implement proper cascade handling
        // {
        //   type: 2, // Button
        //   custom_id: `season_delete_${configId}`,
        //   label: "Delete Season",
        //   style: 4, // Danger
        //   emoji: { name: 'üóëÔ∏è' }
        // }
        {
          type: 2, // Button
          custom_id: `season_edit_info_${configId}`,
          label: "Edit Season",
          style: 2, // Secondary
          emoji: { name: '‚úèÔ∏è' }
        }
      ]
    };
    navComponents.push(navRow);
  } else {
    // If 5 or fewer questions, show disabled navigation buttons for consistency
    const navRow = {
      type: 1, // Action Row
      components: [
        {
          type: 2, // Button
          custom_id: `season_nav_prev_${configId}_${currentPage}`,
          label: "‚óÄ Previous",
          style: 2, // Secondary
          disabled: true
        },
        {
          type: 2, // Button
          custom_id: `season_nav_next_${configId}_${currentPage}`,
          label: "Next ‚ñ∂",
          style: 2, // Secondary
          disabled: true
        },
        // Delete Season button commented out - castlists can now link to seasons
        // {
        //   type: 2, // Button
        //   custom_id: `season_delete_${configId}`,
        //   label: "Delete Season",
        //   style: 4, // Danger
        //   emoji: { name: 'üóëÔ∏è' }
        // }
        {
          type: 2, // Button
          custom_id: `season_edit_info_${configId}`,
          label: "Edit Season",
          style: 2, // Secondary
          emoji: { name: '‚úèÔ∏è' }
        }
      ]
    };
    navComponents.push(navRow);
  }

  // Return just the components (for ButtonHandlerFactory)
  return {
    components: [refreshedContainer, ...navComponents]
  };
}

/**
 * Refresh question management UI (old-style wrapper for direct res.send())
 * @param {Object} res - Express response object
 * @param {Object} config - Season configuration
 * @param {string} configId - Configuration ID
 * @param {number} currentPage - Current page number
 */
async function refreshQuestionManagementUI(res, config, configId, currentPage = 0) {
  const responseData = buildQuestionManagementUI(config, configId, currentPage);

  return res.send({
    type: InteractionResponseType.UPDATE_MESSAGE,
    data: {
      flags: (1 << 15), // IS_COMPONENTS_V2
      ...responseData
    }
  });
}

// Helper function to show application questions
async function showApplicationQuestion(res, config, channelId, questionIndex) {
  const question = config.questions[questionIndex];
  if (!question) {
    return res.send({
      type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        content: '‚ùå Question not found.',
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
  }
  
  const isLastQuestion = questionIndex === config.questions.length - 1;
  const isSecondToLast = questionIndex === config.questions.length - 2;
  
  const questionComponents = [
    {
      type: 10, // Text Display
      content: `## ${isLastQuestion ? '' : `Q${questionIndex + 1}. `}${question.questionTitle}\n\n${question.questionText}`
    }
  ];
  
  // Add Media Gallery if question has an image URL
  if (question.imageURL && question.imageURL.trim()) {
    questionComponents.push({
      type: 12, // Media Gallery
      items: [
        {
          media: {
            url: question.imageURL.trim()
          }
        }
      ]
    });
  }
  
  // Add navigation button(s) - but not for the last question
  if (!isLastQuestion) {
    questionComponents.push({
      type: 14 // Separator
    });
    // Regular navigation button
    const navButton = new ButtonBuilder()
      .setCustomId(`app_next_question_${channelId}_${questionIndex}`)
      .setLabel(isSecondToLast ? 'Complete Application' : `Next Question`)
      .setStyle(isSecondToLast ? ButtonStyle.Success : ButtonStyle.Secondary) // Green for Complete Application, grey for Next
      .setEmoji(isSecondToLast ? '‚úÖ' : '‚û°Ô∏è');
    
    const navRow = new ActionRowBuilder().addComponents(navButton);
    questionComponents.push(navRow.toJSON());
  }
  
  
  const questionContainer = {
    type: 17, // Container
    accent_color: isLastQuestion ? 0x2ecc71 : 0x3498db, // Green for last question, blue for others
    components: questionComponents
  };
  
  return res.send({
    type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
    data: {
      flags: (1 << 15), // IS_COMPONENTS_V2
      components: [questionContainer]
    }
  });
}

import { 
  loadEntity, 
  updateEntityFields, 
  deleteEntity,
  searchEntities 
} from './entityManager.js';
import { 
  createFieldGroupModal, 
  parseModalSubmission, 
  validateFields,
  createConsumableSelect 
} from './fieldEditors.js';
// Helper function imports (Phase 1A refactoring)
import {
  createEmojiForUser,
  parseEmojiCode,
  parseTextEmoji,
  sanitizeEmojiName,
  checkRoleHasEmojis,
  clearEmojisForRole
} from './utils/emojiUtils.js';
import {
  calculateCastlistFields,
  createMemberFields,
  determineCastlistToShow,
  shouldOmitSpacers
} from './utils/castlistUtils.js';
import {
  checkRoleHierarchyPermission,
  handleSetupTycoons
} from './utils/roleUtils.js';
import {
  requirePermission,
  requireAdminPermission,
  requireSpecificUser,
  hasPermission,
  PERMISSIONS
} from './utils/permissionUtils.js';
import fs from 'fs';
import path from 'path';
import { execSync } from 'child_process';
import os from 'os';
import { Readable } from 'stream';
import { pipeline } from 'stream/promises';

// REMOVED: createCastingButtons - now handled by castRankingManager.js

// REMOVED: createVotingBreakdown - now handled by castRankingManager.js

// REMOVED: createApplicantSelectOptions - now handled by castRankingManager.js

/**
 * Helper function to create player notes section and edit button
 * @param {string} channelId - Application channel ID
 * @param {number} appIndex - Application index for navigation
 * @param {Object} playerData - Player data object
 * @param {string} guildId - Guild ID
 * @returns {Array} Array containing Text Display and ActionRow components
 */
function createPlayerNotesSection(channelId, appIndex, playerData, guildId, configId = null) {
  // Get existing notes or default text
  const existingNotes = playerData[guildId]?.applications?.[channelId]?.playerNotes;
  const notesText = existingNotes || 'Record casting notes, connections or potential issues...';
  
  // Create notes text display
  const notesDisplay = {
    type: 10, // Text Display component
    content: `### :pencil: Player Notes\n${notesText}`
  };
  
  // Create edit button
  const editButton = new ButtonBuilder()
    .setCustomId(`edit_player_notes_${channelId}_${appIndex}_${configId || 'legacy'}`)
    .setLabel('‚úèÔ∏è Edit Player Notes')
    .setStyle(ButtonStyle.Primary);
  
  // Create delete application button
  const deleteButton = new ButtonBuilder()
    .setCustomId(`delete_application_mode_${channelId}_${appIndex}_${configId || 'legacy'}`)
    .setLabel('üóëÔ∏è Delete Application')
    .setStyle(ButtonStyle.Danger);
  
  const editButtonRow = new ActionRowBuilder().addComponents(editButton, deleteButton);
  
  return [notesDisplay, editButtonRow.toJSON()];
}

/**
 * Determine if user has admin permissions (production team member)
 *
 * This function gates access to Production Menu vs Player Menu:
 * - ADMIN: createProductionMenuInterface() - full server management
 * - PLAYER: createPlayerManagementUI() - personal profile only
 *
 * Entry points using this check:
 * 1. /menu slash command (line ~2345)
 * 2. viral_menu button from /castlist (line ~6124)
 *
 * Checks any of: ManageChannels | ManageGuild | ManageRoles | Administrator
 *
 * @param {Object} member - Discord member object from interaction
 * @returns {boolean} True if user has any admin permission
 */
function hasAdminPermissions(member) {
  if (!member || !member.permissions) return false;
  
  // Convert permissions string to BigInt for comparison
  const permissions = BigInt(member.permissions);
  const adminPermissions = 
    PermissionFlagsBits.ManageChannels | 
    PermissionFlagsBits.ManageGuild | 
    PermissionFlagsBits.ManageRoles | 
    PermissionFlagsBits.Administrator;
  
  return (permissions & BigInt(adminPermissions)) !== 0n;
}

/**
 * Check if user has a specific permission in a specific channel
 * @param {Object} member - Discord member object from interaction  
 * @param {string} channelId - Discord channel ID
 * @param {bigint} permission - Discord permission flag (e.g., PermissionFlagsBits.SendMessages)
 * @param {Object} client - Discord.js client instance
 * @returns {Promise<boolean>} True if user has the permission in that channel
 */
async function hasChannelPermission(member, channelId, permission, client) {
  try {
    if (!member || !member.user || !channelId || !client) return false;
    
    // Fetch the channel and guild member to get accurate permissions
    const channel = await client.channels.fetch(channelId);
    if (!channel || !channel.guild) return false;
    
    const guildMember = await channel.guild.members.fetch(member.user.id);
    if (!guildMember) return false;
    
    // Get computed permissions for this member in this specific channel
    const memberPermissions = guildMember.permissionsIn(channel);
    
    return memberPermissions.has(permission);
  } catch (error) {
    console.error('Error checking channel permission:', error);
    return false; // Fail-safe: deny permission if we can't check
  }
}

/**
 * Check if user can send messages in a specific channel
 * @param {Object} member - Discord member object from interaction
 * @param {string} channelId - Discord channel ID  
 * @param {Object} client - Discord.js client instance
 * @returns {Promise<boolean>} True if user can send messages in that channel
 */
async function canSendMessagesInChannel(member, channelId, client) {
  return await hasChannelPermission(member, channelId, PermissionFlagsBits.SendMessages, client);
}

/**
 * PERMISSION SYSTEM ARCHITECTURE DOCUMENTATION
 * ============================================
 * 
 * This codebase implements a comprehensive, reusable permission checking system to prevent
 * channel spam and ensure proper Discord permission enforcement.
 * 
 * ## Core Functions:
 * 
 * 1. **hasAdminPermissions(member)** - Guild-level admin permission check
 *    - Checks: Manage Channels, Manage Guild, Manage Roles, Administrator
 *    - Usage: Production features, admin-only functionality
 * 
 * 2. **hasChannelPermission(member, channelId, permission, client)** - Channel-specific permission check
 *    - Uses Discord.js permissionsIn() for accurate channel-level permissions
 *    - Handles channel overwrites, role-based permissions, etc.
 *    - Reusable for any Discord permission flag
 * 
 * 3. **canSendMessagesInChannel(member, channelId, client)** - Specific helper for SEND_MESSAGES
 *    - Built on hasChannelPermission() for consistency
 *    - Primary function for anti-spam enforcement
 * 
 * ## Anti-Spam Implementation:
 * 
 * **Castlist Permission Logic:**
 * - IF user has SEND_MESSAGES permission in channel ‚Üí Public castlist display
 * - ELSE user lacks SEND_MESSAGES permission ‚Üí Ephemeral castlist (only visible to user)
 * 
 * **Handlers with Permission Checking:**
 * - show_castlist2_* (main castlist display)
 * - castlist2_nav_* (navigation between tribes/pages)
 * - castlist2_tribe_prev_*, castlist2_tribe_next_* (legacy tribe navigation)
 * - castlist2_prev_*, castlist2_next_* (legacy page navigation)
 * 
 * ## Implementation Pattern:
 * 
 * ```javascript
 * // Check permissions and apply ephemeral flag if needed
 * if (member && channelId) {
 *   const canSendMessages = await canSendMessagesInChannel(member, channelId, client);
 *   if (!canSendMessages) {
 *     responseData.flags = (responseData.flags || 0) | InteractionResponseFlags.EPHEMERAL;
 *   }
 * }
 * ```
 * 
 * ## Error Handling:
 * - Fail-safe: If permission check fails, deny permission (return false)
 * - Prevents security bypasses due to API errors
 * - Comprehensive error logging for troubleshooting
 * 
 * ## Future Extensibility:
 * - hasChannelPermission() supports any Discord permission flag
 * - Pattern easily adaptable to other features requiring channel permission checks
 * - Consistent architecture across admin vs channel-specific permissions
 */

/**
 * Check if user has Cast Ranking permissions (with special exception for server 1331657596087566398)
 * @param {Object} member - Discord member object from interaction
 * @param {string} guildId - Discord guild ID
 * @returns {boolean} True if user has cast ranking permissions
 */
function hasCastRankingPermissions(member, guildId) {
  if (!member || !member.permissions) return false;
  
  // Special exception for server 1331657596087566398 - allow all users
  if (guildId === '1331657596087566398') {
    console.log(`üèÜ Cast Ranking: Special permission granted for server ${guildId}`);
    return true;
  }
  
  // Standard permission check for other servers: Manage Roles OR Manage Channels
  const permissions = BigInt(member.permissions);
  const castRankingPermissions = 
    PermissionFlagsBits.ManageRoles | 
    PermissionFlagsBits.ManageChannels;
  
  const hasPermission = (permissions & BigInt(castRankingPermissions)) !== 0n;
  console.log(`üèÜ Cast Ranking: Standard permission check for server ${guildId}: ${hasPermission}`);
  return hasPermission;
}

// createPlayerDisplaySection has been moved to playerManagement.js module

/**
 * Create reusable CastBot menu components
 * @param {Object} playerData - Guild player data
 * @param {string} guildId - Discord guild ID
 * @param {boolean} isEphemeral - Whether menu should be ephemeral (user-only)
 * @returns {Object} Menu content and components
 */
/**
 * Create production menu interface with Components V2 structure
 * @param {Object} guild - Discord guild object
 * @param {Object} playerData - Guild player data
 * @param {string} guildId - Discord guild ID
 * @param {string} userId - User ID for special features (optional)
 * @returns {Object} Production menu response object
 */
async function createProductionMenuInterface(guild, playerData, guildId, userId = null) {
  // Track legacy menu usage
  MenuBuilder.trackLegacyMenu('createProductionMenuInterface', 'Main production menu');

  // Check if server has completed initial setup (at least 1 pronoun AND 1 timezone)
  // If not, show Setup Wizard instead of Production Menu
  const hasPronouns = playerData[guildId]?.pronounRoleIDs?.length > 0;
  const hasTimezones = playerData[guildId]?.timezones && Object.keys(playerData[guildId].timezones).length > 0;
  const hasSetup = hasPronouns && hasTimezones;

  if (!hasSetup) {
    console.log(`üßô First-run detected: pronouns=${hasPronouns}, timezones=${hasTimezones} - showing Setup Wizard instead of Production Menu`);

    // Import Discord Messenger service for reusable components
    const { default: DiscordMessenger } = await import('./discordMessenger.js');

    // Return Setup Wizard components with hasSetup status
    const wizardComponents = DiscordMessenger.createWelcomeComponents({
      context: 'channel',
      hasSetup
    });

    // Return in same format as Production Menu expects
    return {
      flags: (1 << 15), // IS_COMPONENTS_V2
      components: wizardComponents
    };
  }

  // Extract castlist data using Virtual Adapter pattern for modern entities
  const { allCastlists } = await extractCastlistData(playerData, guildId);

  // Limit to 4 custom castlists to prevent Discord 40-component limit
  const { limitAndSortCastlists } = await import('./castlistV2.js');
  const limitedCastlists = limitAndSortCastlists(allCastlists, 4);

  // Create castlist rows with metadata display (sort strategy, emoji, description)
  // Pass preSorted=true to preserve timestamp-based sort order from limitAndSortCastlists
  const castlistRows = createCastlistRows(limitedCastlists, true, false, true);
  
  // Debug logging for castlist pagination
  console.log(`Created ${castlistRows.length} castlist row(s) for ${limitedCastlists.size} castlist(s) (limited from ${allCastlists.size})`);
  if (castlistRows.length > 1) {
    console.log('Pagination active: castlists split across multiple rows to prevent Discord ActionRow limit');
  }

  // Note: hasPronouns AND hasTimezones are true at this point (we return Setup Wizard early if not)
  // hasRoles kept for backward compatibility but will always be true here
  const hasRoles = true;

  // Create admin control buttons (reorganized for Castlists, Applications and Season Management section)
  const adminButtons = [];

  // Castlist Hub - now available to all production team members
  adminButtons.push(
    new ButtonBuilder()
      .setCustomId('castlist_hub_main')
      .setLabel('Castlist Manager')
      .setStyle(ButtonStyle.Primary)
      .setEmoji('üìã')
  );

  // Add Season Applications (moved from Advanced Features, changed to Secondary)
  adminButtons.push(
    new ButtonBuilder()
      .setCustomId('season_management_menu')
      .setLabel('Apps')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üìù')
  );

  // Standard admin buttons
  adminButtons.push(
    new ButtonBuilder()
      .setCustomId('admin_manage_player')
      .setLabel('Players')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üßë‚Äçü§ù‚Äçüßë'),
    new ButtonBuilder()
      .setCustomId('safari_rounds_menu')
      .setLabel('Challenges')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üèÉ‚Äç‚ôÄÔ∏è'),
    new ButtonBuilder()
      .setCustomId('prod_donate')
      .setLabel('Donate')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('‚òï')
    // Tribes moved to Reece's Stuff menu (reeces_stuff) - see menuBuilder.js
  );
  
  // Live Analytics button moved to Reece Stuff submenu
  
  const adminRow = new ActionRowBuilder().addComponents(adminButtons);

  // Create Safari features row (Idol Hunts, Challenges and Safari section)
  const safariFeatureButtons = [
    new ButtonBuilder()
      .setCustomId('safari_store_manage_items')
      .setLabel('Stores')
      .setStyle(ButtonStyle.Primary)
      .setEmoji('üè™'),
    new ButtonBuilder()
      .setCustomId('safari_manage_items')
      .setLabel('Items')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üì¶'),
    new ButtonBuilder()
      .setCustomId('safari_map_admin')
      .setLabel('Player Admin')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üß≠'),
    new ButtonBuilder()
      .setCustomId('safari_manage_currency')
      .setLabel('Currency')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üí∞'),
    new ButtonBuilder()
      .setCustomId('safari_customize_terms')
      .setLabel('Settings')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('‚öôÔ∏è')
  ];

  const safariFeatureRow = new ActionRowBuilder().addComponents(safariFeatureButtons);

  // Create Advanced Features row (Map Explorer + Analytics + Action Editor + Tools)
  const advancedFeaturesButtons = [
    new ButtonBuilder()
      .setCustomId('safari_map_explorer')
      .setLabel('Map Admin')
      .setStyle(ButtonStyle.Primary)
      .setEmoji('üó∫Ô∏è')
  ];

  // Analytics moved to Reece's Stuff menu (Tools ‚Üí Reece's Stuff ‚Üí Analytics)

  // Add Actions button
  advancedFeaturesButtons.push(
    new ButtonBuilder()
      .setCustomId('safari_action_editor')
      .setLabel('Actions')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('‚ö°')
  );

  // safari_rounds_menu moved to adminButtons row (relabeled to "Challenges")
  // prod_safari_menu removed - buttons distributed to Production Menu and Map Explorer

  // Add Tools button (renamed from Initial Setup, contains Setup/Availability/Help) - third/fourth in row depending on Analytics
  advancedFeaturesButtons.push(
    new ButtonBuilder()
      .setCustomId('castbot_tools')
      .setLabel('Tools')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('ü™õ')
  );

  const advancedFeaturesRow = new ActionRowBuilder().addComponents(advancedFeaturesButtons);
  
  // Component validation moved to utils.js - use countComponents() or validateComponentLimit()
  
  // Check for active season to display in header
  const activeSeason = playerData[guildId]?.activeSeason;
  const menuTitle = activeSeason?.name 
    ? `## ${formatBotEmoji('castbot_logo')} CastBot | ${activeSeason.name}`
    : `## ${formatBotEmoji('castbot_logo')} CastBot | Production Menu`;
  
  // Build container components array with pagination support
  const containerComponents = [
    // Title Section with Player Menu button accessory
    {
      type: 9, // Section with accessory
      components: [
        {
          type: 10, // Text Display component
          content: menuTitle
        }
      ],
      accessory: {
        type: 2, // Button
        custom_id: 'prod_player_menu',
        label: 'Player Menu',
        style: 2, // Secondary
        emoji: { name: 'ü™™' }
      }
    },
    {
      type: 14 // Separator after title
    },
    {
      type: 9, // Section with accessory - Feature announcement ticker
      components: [
        {
          type: 10, // Text Display
          content: `> **üöÄ Major New Castlist features!** Alumni lists, swaps and more!`
        }
      ],
      accessory: {
        type: 2, // Button
        custom_id: 'dm_view_tips', // üß™ TEMPORARILY HIJACKED for Path A test
        label: 'New Features',
        style: 2, // Secondary (grey)
        emoji: { name: '‚ú®' }
      }
    },
    {
      type: 10, // Text Display component
      content: `> **\`üìç Post Castlists\`**`
    },
    ...castlistRows, // Multiple castlist rows with pagination
    {
      type: 14 // Separator after castlist rows
    },
    {
      type: 10, // Text Display component
      content: `> **\`‚úèÔ∏è Castlists, Applications and Season Management\`**`
    },
    adminRow.toJSON(), // Admin management buttons
    {
      type: 14 // Separator after admin management row
    },
    {
      type: 10, // Text Display component
      content: `> **\`ü¶Å Idol Hunts, Challenges and Safari\`**`
    },
    safariFeatureRow.toJSON(), // Safari feature buttons (Stores, Items, Player Admin, Rounds, Currency)
    {
      type: 14 // Separator after Safari features row
    },
    {
      type: 10, // Text Display component
      content: `> **\`üíé Advanced Features\`**`
    },
    advancedFeaturesRow.toJSON(), // Safari + Analytics + Tools (single row)
    {
      type: 14 // Separator before credit
    },
    {
      type: 10, // Text Display component
      content: `-# Made by Reece (@extremedonkey)`
    }
  ];

  // Create Components V2 Container for entire production menu
  const prodMenuContainer = {
    type: 17, // Container component
    accent_color: 0x3498DB, // Blue accent color
    components: containerComponents
  };

  // Count and validate components (must wrap container in array!)
  const { countComponents } = await import('./utils.js');
  const count = countComponents([prodMenuContainer], {
    enableLogging: true,
    verbosity: "full",
    label: "Production Menu (viral_menu)"
  });

  if (count > 40) {
    throw new Error(`Production Menu exceeds component limit: ${count}/40 components`);
  }

  return {
    flags: (1 << 15) | (1 << 6), // IS_COMPONENTS_V2 flag + EPHEMERAL flag
    components: [prodMenuContainer]
  };
}

/**
 * Create Analytics Admin submenu interface (admin-only special features)
 */
async function createReeceStuffMenu(guildId, channelId = null) {
  // Load data to check what exists for this guild
  const { loadSafariContent } = await import('./safariManager.js');
  const { loadPlayerData } = await import('./storage.js');
  
  const safariData = await loadSafariContent();
  const playerData = await loadPlayerData();
  
  // Check if there's data to delete
  const guildMaps = safariData[guildId]?.maps || {};
  const activeMapId = guildMaps.active;
  const hasActiveMap = activeMapId && guildMaps[activeMapId];
  const hasSafariData = !!safariData[guildId];
  const hasPlayerData = !!playerData[guildId];
  
  // Check if there are roles to nuke
  // Note: Button is always enabled now because nuke operation uses dstState.json pattern matching
  // to detect roles even if they're not registered in playerData (useful for dev cleanup)
  const hasPronounRoles = playerData[guildId]?.pronounRoleIDs?.length > 0;
  const hasTimezoneRoles = playerData[guildId]?.timezones && Object.keys(playerData[guildId].timezones).length > 0;
  const hasRolesInData = true;  // Always enabled - pattern matching detects unregistered roles
  
  // Check if this channel has an application (for Emergency App Re-Init)
  const isApplicationChannel = channelId && !!playerData[guildId]?.applications?.[channelId];
  
  console.log(`üìä Reece menu data check - Guild ${guildId}: Map: ${hasActiveMap}, Safari: ${hasSafariData}, Player: ${hasPlayerData}, Roles: ${hasRolesInData}, AppChannel: ${isApplicationChannel}`);
  
  // Analytics section buttons - All Servers first, Print Logs + Toggle moved to Reece's Stuff
  const analyticsButtons = [
    new ButtonBuilder()
      .setCustomId('prod_all_servers')
      .setLabel('All Servers')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üåê'),
    new ButtonBuilder()
      .setCustomId('prod_server_usage_stats')
      .setLabel('Server Stats')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üìà'),
    new ButtonBuilder()
      .setCustomId('prod_ultrathink_monitor')
      .setLabel('Ultramonitor')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üåà')
  ];

  // Data Actions section buttons (DST + Refresh Tips + Import)
  const dataActionsButtons = [
    new ButtonBuilder()
      .setCustomId('admin_dst_toggle')
      .setLabel('DST Manager')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üåç'),
    new ButtonBuilder()
      .setCustomId('refresh_tips')
      .setLabel('Refresh Tips')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üí°'),
    new ButtonBuilder()
      .setCustomId('playerdata_import')
      .setLabel('Import Server')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üì•')
  ];

  // Export Data section buttons
  const exportDataButtons = [
    new ButtonBuilder()
      .setCustomId('playerdata_export_all')
      .setLabel('All playerData')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üíø'),
    new ButtonBuilder()
      .setCustomId('playerdata_export')
      .setLabel('Server playerData')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üíø'),
    new ButtonBuilder()
      .setCustomId('safaricontent_export_all')
      .setLabel('All safariContent')
      .setStyle(ButtonStyle.Secondary)
      .setEmoji('üíø')
  ];

  // Danger Zone section buttons
  const deleteMapButton = new ButtonBuilder()
    .setCustomId('map_delete')
    .setLabel('Delete Map')
    .setStyle(ButtonStyle.Danger)
    .setEmoji('üóëÔ∏è')
    .setDisabled(!hasActiveMap);  // Disable if no active map
  
  const dangerZoneButtons = [
    deleteMapButton,  // First button in the row
    new ButtonBuilder()
      .setCustomId('nuke_roles')
      .setLabel('Nuke Roles')
      .setStyle(ButtonStyle.Danger)
      .setEmoji('üí•')
      .setDisabled(!hasRolesInData),
    new ButtonBuilder()
      .setCustomId('emergency_app_reinit')
      .setLabel('Emergency App Re-Init')
      .setStyle(ButtonStyle.Danger)
      .setEmoji('üö®')
      .setDisabled(!isApplicationChannel),
    new ButtonBuilder()
      .setCustomId('nuke_player_data')
      .setLabel('Nuke playerData')
      .setStyle(ButtonStyle.Danger)
      .setEmoji('‚ò¢Ô∏è')
      .setDisabled(!hasPlayerData),  // Disable if no playerData exists
    new ButtonBuilder()
      .setCustomId('nuke_safari_content')
      .setLabel('Nuke safariContent')
      .setStyle(ButtonStyle.Danger)
      .setEmoji('‚ò¢Ô∏è')
      .setDisabled(!hasSafariData)  // Disable if no safariContent exists
  ];
  
  const analyticsRow = new ActionRowBuilder().addComponents(analyticsButtons);
  const dangerZoneRow = new ActionRowBuilder().addComponents(dangerZoneButtons);
  const dataActionsRow = new ActionRowBuilder().addComponents(dataActionsButtons);
  const exportDataRow = new ActionRowBuilder().addComponents(exportDataButtons);

  const backRow = new ActionRowBuilder().addComponents(
    new ButtonBuilder()
      .setCustomId('castbot_tools')
      .setLabel('‚Üê Tools')
      .setStyle(ButtonStyle.Secondary)
  );

  // Build container components with section headers
  const containerComponents = [
    { type: 10, content: `## üßÆ CastBot | Analytics` },
    { type: 14 },
    { type: 10, content: `> **\`üìä Analytics\`**` },
    analyticsRow.toJSON(),
    { type: 14 },
    { type: 10, content: `> **\`üì¶ Data Actions\`**` },
    dataActionsRow.toJSON(),
    { type: 14 },
    { type: 10, content: `> **\`üíæ Export Data\`**` },
    exportDataRow.toJSON(),
    { type: 14 },
    { type: 10, content: `> **\`‚ò¢Ô∏è Danger Zone\`**` },
    dangerZoneRow.toJSON(),
    { type: 14 },
    backRow.toJSON()
  ];

  const reeceMenuContainer = {
    type: 17,
    accent_color: 0xe74c3c,
    components: containerComponents
  };

  const { countComponents } = await import('./utils.js');
  countComponents([reeceMenuContainer], { verbosity: "summary", label: "Analytics Admin" });

  return {
    flags: (1 << 15),
    components: [reeceMenuContainer]
  };
}

/**
 * Create Safari submenu interface for dynamic content management
 */
// TODO: MARKED FOR DELETION - createSafariMenu function removed (2025-02-11)
// Safari features distributed to Production Menu and Map Explorer
// async function createSafariMenu(guildId, userId, member) {
//   // Get the inventory name and current round for this guild
//   let inventoryName = 'Inventory'; // Default
//   let inventoryEmoji = 'üß∞'; // Default emoji
//   let currentRound = 1; // Default round
//   let totalRounds = 3; // Default total rounds
//
//   try {
//     const { loadSafariContent } = await import('./safariManager.js');
//     const safariContent = await loadSafariContent();
//     const guildConfig = safariContent[guildId]?.safariConfig;
//     if (guildConfig?.inventoryName) {
//       inventoryName = guildConfig.inventoryName;
//     }
//     if (guildConfig?.inventoryEmoji) {
//       inventoryEmoji = guildConfig.inventoryEmoji;
//     }
//     // Get current round for dynamic button label
//     if (guildConfig?.currentRound) {
//       currentRound = guildConfig.currentRound;
//     }
//     // Get total rounds
//     if (guildConfig?.totalRounds) {
//       totalRounds = guildConfig.totalRounds;
//     }
//   } catch (error) {
//     console.error('Error loading safari config:', error);
//   }
//
//   // Use custom inventory name for everyone
//   const inventoryLabel = `My ${inventoryName}`;
//
//   // Create dynamic round results button labels
//   let roundResultsLabel;
//   if (currentRound >= 1 && currentRound <= totalRounds) {
//     roundResultsLabel = `Round ${currentRound} Results`;
//   } else if (currentRound > totalRounds) {
//     roundResultsLabel = 'Reset Game';
//   } else {
//     roundResultsLabel = 'Results'; // Fallback
//   }
//
//   // Advanced Safari Configuration section buttons (Map-related features)
//   const mapAdminButtons = [
//     new ButtonBuilder()
//       .setCustomId('safari_map_explorer')
//       .setLabel('üó∫Ô∏è Map Admin')
//       .setStyle(ButtonStyle.Secondary),
//     new ButtonBuilder()
//       .setCustomId('safari_location_editor')
//       .setLabel('Location Editor')
//       .setStyle(ButtonStyle.Secondary)
//       .setEmoji('üìç'),
//     new ButtonBuilder()
//       .setCustomId('safari_action_editor')
//       .setLabel('Action Editor')
//       .setStyle(ButtonStyle.Secondary)
//       .setEmoji('‚ö°'),
//     new ButtonBuilder()
//       .setCustomId('safari_progress')
//       .setLabel('Safari Progress')
//       .setStyle(ButtonStyle.Secondary)
//       .setEmoji('üöÄ')
//   ];
//
//   // TODO: Flag for deletion - Check if safari_manage_safari_buttons handler is still needed
//   // TODO: Flag for deletion - Check if safari_navigate handlers and dependencies can be removed
//
//   const mapAdminRow = new ActionRowBuilder().addComponents(mapAdminButtons);
//
//   // Create back button
//   const backButton = [
//     new ButtonBuilder()
//       .setCustomId('prod_menu_back')
//       .setLabel('‚¨Ö Menu')
//       .setStyle(ButtonStyle.Secondary)
//   ];
//
//   const backRow = new ActionRowBuilder().addComponents(backButton);
//
//   // Build container components with section headers
//   const containerComponents = [
//     {
//       type: 10, // Text Display component
//       content: `## ü¶Å Safari | Idol Hunts, Challenges & More\n\nAdvanced map configuration, custom actions, and location management.`
//     },
//     {
//       type: 14 // Separator
//     },
//     {
//       type: 10, // Text Display component
//       content: `> **\`ü¶Å Advanced Safari Configuration\`**`
//     },
//     mapAdminRow.toJSON(),
//     {
//       type: 14 // Separator
//     },
//     backRow.toJSON() // Back navigation
//   ];
//
//   // Create Components V2 Container
//   const safariMenuContainer = {
//     type: 17, // Container component
//     accent_color: 0xf39c12, // Orange accent color for safari theme
//     components: containerComponents
//   };
//
//   return {
//     flags: (1 << 15), // IS_COMPONENTS_V2 flag
//     components: [safariMenuContainer]
//   };
// }


// Viral growth buttons are now integrated into navigation buttons in castlistV2.js

// REACTION_EMOJIS moved to roleManager.js as REACTION_EMOJIS
// Using Discord's conservative 20-reaction limit for maximum compatibility


/**
 * Send castlist2 response with dynamic component optimization
 * @param {Object} req - Request object with Discord interaction data
 * @param {Object} guild - Discord guild object
 * @param {Array} tribes - Array of tribe data with members
 * @param {string} castlistId - ID of the castlist (for lookups/button encoding)
 * @param {Object} navigationState - Current navigation state
 * @param {Object} member - Discord member object for permission checking (optional)
 * @param {string} channelId - Channel ID for permission checking (optional)
 * @param {string} displayMode - 'view' or 'edit' mode
 * @param {string} castlistName - Display name (optional, defaults to ID)
 */
async function sendCastlist2Response(req, guild, tribes, castlistId, navigationState, member = null, channelId = null, displayMode = 'view', castlistName = null, options = {}) {
  // Use the build function to avoid duplication
  // Create a permission checker wrapper if needed
  const permissionChecker = (member && channelId) ?
    async (m, c) => await canSendMessagesInChannel(m, c, client) :
    null;

  const responseData = await buildCastlist2ResponseData(guild, tribes, castlistId, navigationState, member, channelId, permissionChecker, displayMode, castlistName, options);

  // Send via webhook (used for deferred slash command responses)
  const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
  await DiscordRequest(endpoint, {
    method: 'PATCH',
    body: responseData,
  });
}

// Role constants moved to roleManager.js module

// Update ensureServerData function
async function ensureServerData(guild) {
  const playerData = await loadPlayerData();

  // Try to get owner information safely
  let ownerInfo = null;
  try {
    const owner = await guild.members.fetch(guild.ownerId);
    ownerInfo = {
      username: owner.user.username,
      globalName: owner.user.globalName || owner.user.username,
      discriminator: owner.user.discriminator,
      tag: owner.user.tag
    };
  } catch (error) {
    // Silently fail - owner might not be in cache or accessible
    console.debug(`Could not fetch owner info for guild ${guild.id}`);
  }

  // Prepare server metadata with enhanced analytics
  const serverMetadata = {
    serverName: guild.name,
    icon: guild.iconURL(),
    ownerId: guild.ownerId,
    memberCount: guild.memberCount,
    description: guild.description || null,
    vanityURLCode: guild.vanityURLCode || null,
    preferredLocale: guild.preferredLocale,
    partnered: guild.partnered || false,
    verified: guild.verified || false,
    createdTimestamp: guild.createdTimestamp,
    lastUpdated: Date.now(),
    // Analytics metadata (safe to log)
    ...(ownerInfo && { ownerInfo }),
    analyticsVersion: '1.0' // For future analytics upgrades
  };

  if (!playerData[guild.id]) {
    // New server initialization
    playerData[guild.id] = {
      ...serverMetadata,
      players: {},
      tribes: {},           // Now empty object (no fixed keys)
      timezones: {},
      pronounRoleIDs: [],
      // Analytics for new installations
      firstInstalled: Date.now(),
      installationMethod: 'command' // Could be 'invite', 'command', etc.
    };
    // PRIORITY 3: Return indicator to batch write later (don't write per-guild)
    return { updated: true, isNew: true };
  } else {
    // Check if metadata actually changed before marking for update
    const existing = playerData[guild.id];
    const hasChanges = existing.memberCount !== serverMetadata.memberCount ||
                      existing.serverName !== serverMetadata.serverName ||
                      existing.icon !== serverMetadata.icon;

    if (hasChanges) {
      // Update existing server metadata
      playerData[guild.id] = {
        ...existing,
        ...serverMetadata
      };
      return { updated: true, isNew: false };
    }

    return { updated: false, isNew: false };
  }
}

// Create an express app
const app = express();
// Get port, or default to 3000
const PORT = process.env.PORT || 3000;

// Initialize Discord client with required intents, partials, and ultra-cautious cache limits
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMembers,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.MessageContent
  ],
  partials: [Partials.Message, Partials.Channel, Partials.Reaction],
  // Cache limits: Only limit MessageManager to prevent unbounded message cache growth
  // GuildMemberManager/UserManager are naturally bounded by server membership
  // NOTE: RoleManager and ChannelManager are NOT limited per Discord.js recommendations
  makeCache: Options.cacheWithLimits({
    MessageManager: 50        // Limit message cache (messages are large objects)
    // GuildMemberManager: REMOVED - caused mid-operation evictions leading to "Supplied parameter is not a User nor a Role" errors
    // UserManager: REMOVED - redundant with member caching, saves memory (6.69MB -> 0.97MB)
  })
});

// ============================================================================
// üìÖ SCHEDULER - Register actions for persistent job scheduling
// ============================================================================
scheduler.registerAction('process_round_results', async (payload, schedulerClient) => {
  const { channelId, guildId } = payload;
  try {
    console.log(`‚öîÔ∏è DEBUG: Executing scheduled Safari round results in channel ${channelId}`);
    const { processRoundResults } = await import('./safariManager.js');
    const roundData = await processRoundResults(guildId, null, schedulerClient, { isScheduled: true, channelId });

    if (roundData === null) {
      console.log(`‚úÖ DEBUG: Scheduled Safari round results executed successfully via webhook`);
      return;
    }

    if (roundData?.data?.content) {
      console.error(`‚ùå DEBUG: Scheduled execution returned error:`, roundData.data.content);
    }
  } catch (error) {
    console.error(`‚ùå ERROR: Failed to execute scheduled Safari round results:`, error);
    try {
      const channel = await schedulerClient.channels.fetch(channelId);
      if (channel) {
        const errorWebhook = await channel.createWebhook({
          name: 'Safari Error',
          reason: 'Scheduled Safari error notification'
        });
        await fetch(errorWebhook.url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            content: '‚ùå **ERROR**: Scheduled Safari round results failed to execute. Please run the command manually.'
          })
        });
        setTimeout(() => errorWebhook.delete().catch(() => {}), 1000);
      }
    } catch (channelError) {
      console.error(`‚ùå ERROR: Could not send error message to channel:`, channelError);
    }
  }
});

scheduler.registerAction('send_reminder', async (payload, schedulerClient) => {
  const { channelId, reminderMessage } = payload;
  try {
    const channel = await schedulerClient.channels.fetch(channelId);
    if (channel) {
      await channel.send({
        content: `‚è∞ **Safari Round Results** will be revealed in **${reminderMessage}**! ü¶Å`,
        flags: 0
      });
    }
  } catch (error) {
    console.error(`‚ùå ERROR: Failed to send reminder message to channel ${channelId}:`, error);
  }
});

scheduler.registerAction('execute_custom_action', async (payload, schedulerClient) => {
  const { channelId, guildId, actionId, userId, actionName } = payload;
  try {
    console.log(`‚è∞ [SCHEDULER] Executing Custom Action "${actionName}" (${actionId}) in channel ${channelId}`);
    const channel = await schedulerClient.channels.fetch(channelId);
    const guild = await schedulerClient.guilds.fetch(guildId);

    // Fetch the scheduling user's member for condition evaluation
    let member = null;
    try { member = await guild.members.fetch(userId); } catch (e) {
      console.warn(`‚ö†Ô∏è [SCHEDULER] Could not fetch member ${userId}: ${e.message}`);
    }

    const { executeButtonActions } = await import('./safariManager.js');
    const interactionData = {
      token: null,
      applicationId: process.env.APP_ID,
      client: schedulerClient,
      member,
      user: { id: userId },
      channel: { name: channel.name }
    };

    const result = await executeButtonActions(guildId, actionId, userId, interactionData, schedulerClient);

    // Check if result is an error/failure ‚Äî don't post errors to the channel
    const isError = result?.content?.startsWith('‚ùå') ||
                    (result?.flags && (result.flags & InteractionResponseFlags.EPHEMERAL));
    if (isError) {
      console.warn(`‚ö†Ô∏è [SCHEDULER] Custom Action "${actionName}" returned error: ${result?.content || 'unknown'}`);
      return; // Don't post error messages to channel via webhook
    }

    // Post successful result to channel via webhook
    const webhook = await channel.createWebhook({
      name: actionName || 'Scheduled Action',
      reason: 'Scheduled custom action execution'
    });

    if (result?.components) {
      // Strip ephemeral flags from components ‚Äî scheduled results are public
      const flags = result.flags ? (result.flags & ~InteractionResponseFlags.EPHEMERAL) : (1 << 15);
      await fetch(webhook.url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          flags: flags | (1 << 15), // Ensure IS_COMPONENTS_V2
          components: result.components
        })
      });
    } else if (result?.content) {
      await fetch(webhook.url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ content: result.content })
      });
    }

    setTimeout(() => webhook.delete('Cleanup after scheduled action').catch(() => {}), 5000);
    console.log(`‚úÖ [SCHEDULER] Custom Action "${actionName}" executed in #${channel.name}`);
  } catch (error) {
    console.error(`‚ùå [SCHEDULER] Custom Action "${actionName}" (${actionId}) failed:`, error);
    try {
      const channel = await schedulerClient.channels.fetch(channelId);
      if (channel) {
        const errorWebhook = await channel.createWebhook({
          name: 'Scheduled Action Error',
          reason: 'Scheduled action error notification'
        });
        await fetch(errorWebhook.url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            content: `‚ùå **Scheduled Action Failed**: "${actionName}" could not execute. Please run the action manually.`
          })
        });
        setTimeout(() => errorWebhook.delete().catch(() => {}), 1000);
      }
    } catch (channelError) {
      console.error(`‚ùå [SCHEDULER] Could not send error message to channel:`, channelError);
    }
  }
});

// Add these event handlers after client initialization
client.once('ready', async () => {
  console.log('Discord client is ready!');

  // Set Discord client reference for analytics logging
  setDiscordClient(client);

  // PRIORITY 3: Batch all analytics updates, then write ONCE
  console.log('üìä Updating server analytics metadata...');
  const playerData = await loadPlayerData();
  let analyticsUpdated = false;
  let newServersCount = 0;
  let updatedServersCount = 0;
  const newServers = [];
  const updatedServers = [];
  const unchangedServers = [];

  // Collect all metadata updates in memory
  for (const guild of client.guilds.cache.values()) {
    const result = await ensureServerData(guild);

    if (result.updated) {
      analyticsUpdated = true;
      if (result.isNew) {
        newServersCount++;
        newServers.push(guild.name);
        console.log(`üéâ NEW SERVER INSTALLED: ${guild.name} (${guild.id})`);

        // Post new server install announcement to Discord analytics channel
        try {
          const { logNewServerInstall } = await import('./src/analytics/analyticsLogger.js');
          await logNewServerInstall(guild, null); // ownerInfo handled in ensureServerData
        } catch (error) {
          console.error('Error posting server install announcement:', error);
          // Don't break server initialization if announcement fails
        }
      } else {
        updatedServersCount++;
        updatedServers.push(guild.name);
      }
    } else {
      unchangedServers.push(guild.name);
    }
  }

  // SINGLE WRITE after all updates
  if (analyticsUpdated) {
    await savePlayerData(playerData);
    if (newServersCount > 0) {
      console.log(`‚úÖ Analytics: ${newServersCount} new server(s) installed: ${newServers.join(', ')}`);
    }
    if (updatedServersCount > 0) {
      console.log(`‚úÖ Analytics: ${updatedServersCount} updated: ${updatedServers.join(', ')}`);
    }
  } else {
    console.log(`‚úÖ Analytics: No metadata changes needed (${unchangedServers.length} servers checked: ${unchangedServers.slice(0, 3).join(', ')}${unchangedServers.length > 3 ? ` +${unchangedServers.length - 3} more` : ''})`);
  }

  // Initialize reaction mappings from persistent storage
  console.log('üì• Loading reaction mappings from persistent storage...');
  client.roleReactions = new Map();
  let totalMappingsLoaded = 0;

  for (const guild of client.guilds.cache.values()) {
    // Load reaction mappings for this guild
    try {
      const mappings = await loadAllReactionMappings(guild.id);
      let guildMappingsCount = 0;

      for (const [messageId, mappingData] of Object.entries(mappings)) {
        if (mappingData && mappingData.mapping) {
          client.roleReactions.set(messageId, mappingData.mapping);
          guildMappingsCount++;
        }
      }

      if (guildMappingsCount > 0) {
        console.log(`  ‚úÖ Loaded ${guildMappingsCount} reaction mappings for guild ${guild.name}`);
        totalMappingsLoaded += guildMappingsCount;
      }

      // Clean up old mappings while we're at it
      const cleanedCount = await cleanupOldReactionMappings(guild.id);
      if (cleanedCount > 0) {
        console.log(`  üßπ Cleaned ${cleanedCount} old reaction mappings for guild ${guild.name}`);
      }
    } catch (error) {
      console.error(`  ‚ùå Error loading reaction mappings for guild ${guild.name}:`, error);
    }
  }

  console.log(`üì• Total reaction mappings loaded: ${totalMappingsLoaded}`);

  // Initialize and restore persistent scheduler
  scheduler.init(client);
  await scheduler.restore();

  // Start PM2 Error Log Monitoring (Dev & Prod)
  const pm2Logger = getPM2ErrorLogger(client);
  pm2Logger.start();
});

client.on('guildCreate', async (guild) => {
  // PRIORITY 3: Handle new guild, then write once
  const playerData = await loadPlayerData();
  const result = await ensureServerData(guild);

  if (result.updated) {
    await savePlayerData(playerData);
    console.log(`‚úÖ New server data saved: ${guild.name} (${guild.id})`);
  }

  // Send welcome message using Discord Messenger service
  try {
    const { default: DiscordMessenger } = await import('./discordMessenger.js');
    await DiscordMessenger.sendWelcomePackage(client, guild);
  } catch (error) {
    console.error(`‚ùå Failed to send welcome message for ${guild.name}:`, error);
    // Don't break the installation process if welcome message fails
  }
});

// Remove hardcoded timezone configurations

// Update roleConfig to remove timezone references
const roleConfig = { 
  // any remaining config needed
};

// Add this near the top with other constants
const REQUIRED_PERMISSIONS = [
  PermissionFlagsBits.Administrator,
  PermissionFlagsBits.ManageChannels,
  PermissionFlagsBits.ManageGuild,
  PermissionFlagsBits.ManageRoles,
];

// Add this helper function
async function hasRequiredPermissions(guildId, userId) {
  try {
    const guild = await client.guilds.fetch(guildId);
    const member = await guild.members.fetch(userId);
    // Return true if they have ANY of the required permissions
    return REQUIRED_PERMISSIONS.some(perm => member.permissions.has(perm));
  } catch (error) {
    console.error('Error checking permissions:', error);
    return false;
  }
}

// Add a route to serve a test HTML page
app.get('/', (req, res) => {
    console.log('Root URL accessed');
    res.send('<h1>Castbot is running successfully!</h1>');
});

app.get("/interactions", (req, res) => {
  console.log("GET /interactions was accessed");
  res.send("OK, we see you!");
});

/**
 * Parse request body as JSON for all routes except /interactions
 * The /interactions endpoint needs raw buffer access for discord-interactions package
 */
app.use((req, res, next) => {
  if (req.path === '/interactions') {
    // Skip JSON parsing for interactions endpoint
    next();
  } else {
    // Apply JSON parsing for other routes
    express.json()(req, res, next);
  }
});

// Serve static files from img directory for map images
app.use('/img', express.static('./img'));

// Keep track of processed interactions to prevent duplicates
const processedInteractions = new Map();

// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
// HELPER: Generate Tips Screen (Paginated Media Gallery)
// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

/**
 * DISABLED 2025-11-06: Created channels in all guilds - see RaP/0980 for alternatives
 * Upload all tip images to Discord storage channel and get CDN URLs
 * Follows Safari's uploadImageToDiscord pattern for stable, permanent URLs
 * @param {Guild} guild - Discord guild object
 * @returns {Array<string>} Array of 10 Discord CDN URLs for tip images
 */
/* DISABLED - DO NOT USE
async function uploadTipImagesToDiscord(guild) {
  try {
    const { AttachmentBuilder } = await import('discord.js');
    const path = await import('path');

    // Fetch channels to populate cache (guild.channels may not be cached after fetch)
    await guild.channels.fetch();

    // Find or create tips storage channel (hidden from everyone)
    let storageChannel = guild.channels.cache.find(ch => ch.name === 'tips-storage' && ch.type === 0);

    if (!storageChannel) {
      console.log('üì¶ Creating tips-storage channel...');
      storageChannel = await guild.channels.create({
        name: 'tips-storage',
        type: 0, // Text channel
        topic: 'Storage for tips gallery images - do not delete',
        permissionOverwrites: [
          {
            id: guild.roles.everyone.id,
            deny: ['ViewChannel', 'SendMessages']
          }
        ]
      });
    }

    // Upload all 10 images and collect Discord CDN URLs
    const cdnUrls = [];
    for (let i = 1; i <= 10; i++) {
      const filename = `${i}.png`;
      const imagePath = path.join('/home/reece/castbot/img/tips', filename);

      // Create attachment and send to storage channel
      const attachment = new AttachmentBuilder(imagePath, { name: filename });
      const message = await storageChannel.send({
        content: `Tip image ${i}/10`,
        files: [attachment]
      });

      // Get Discord CDN URL from uploaded attachment
      const cdnUrl = message.attachments.first().url;
      cdnUrls.push(cdnUrl);

      console.log(`‚úÖ Uploaded ${filename} to Discord CDN`);
    }

    return cdnUrls;
  } catch (error) {
    console.error('‚ùå Error uploading tip images:', error);
    throw error;
  }
}
*/ // END DISABLED uploadTipImagesToDiscord

// Cache for Discord CDN URLs (populated on first access)
// let cachedTipImageUrls = null; // DISABLED

/**
 * DISABLED 2025-11-06: See uploadTipImagesToDiscord above
 * Get Discord CDN URLs for all tip images (uploads on first call, caches for future use)
 * @param {Guild} guild - Discord guild object
 * @returns {Array<string>} Array of 10 Discord CDN URLs
 */
/* DISABLED - DO NOT USE
async function getTipImageUrls(guild) {
  if (!cachedTipImageUrls) {
    console.log('üì§ First access - uploading tip images to Discord...');
    cachedTipImageUrls = await uploadTipImagesToDiscord(guild);
  }
  return cachedTipImageUrls;
}
*/ // END DISABLED getTipImageUrls

/**
 * DISABLED 2025-11-06: Part of tips gallery - see RaP/0980 for alternatives
 * Generate paginated tips screen showing one screenshot at a time
 * Uses Discord CDN URLs from uploaded images (Safari pattern)
 * Pattern: Similar to castRankingManager navigation (stateless pagination)
 *
 * @param {number} index - Current screenshot index (0-9)
 * @param {Array<string>} discordCdnUrls - Array of Discord CDN URLs for all 10 images
 * @returns {Object} UPDATE_MESSAGE response with Components V2 structure
 */
/* DISABLED - DO NOT USE
function generateTipsScreen(index, discordCdnUrls) {
  // Define all 10 CastBot feature screenshots metadata
  // Images uploaded to Discord storage channel, URLs provided as parameter

  const screenshots = [
    {
      filename: '1.png',
      title: 'ü¶Å Safari System',
      description: 'Create adventure challenges with maps, items, and player progression'
    },
    {
      filename: '2.png',
      title: 'üìã Dynamic Castlists',
      description: 'Organize cast members with placements, alumni, and custom formatting'
    },
    {
      filename: '3.png',
      title: 'üìä Production Menu',
      description: 'Comprehensive admin interface for managing all CastBot features'
    },
    {
      filename: '4.png',
      title: 'üèÜ Cast Rankings',
      description: 'Let players anonymously vote on applicants with visual ranking interface'
    },
    {
      filename: '5.png',
      title: 'üé¨ Season Management',
      description: 'Configure applications, questions, and production workflows'
    },
    {
      filename: '6.png',
      title: 'üì± Mobile View',
      description: 'CastBot works seamlessly on mobile devices with responsive design'
    },
    {
      filename: '7.png',
      title: 'üéÆ Player Menu',
      description: 'Access your profile, seasons, and interactive features from one place'
    },
    {
      filename: '8.png',
      title: 'üó∫Ô∏è Safari Map Explorer',
      description: 'Interactive map system with fog of war and location tracking'
    },
    {
      filename: '9.png',
      title: 'üìù Application Builder',
      description: 'Create custom season applications with multiple question types'
    },
    {
      filename: '10.png',
      title: '‚öôÔ∏è Settings & Configuration',
      description: 'Fine-tune CastBot behavior for your server needs'
    }
  ];

  const currentScreenshot = screenshots[index];
  const totalCount = screenshots.length;
  const imageUrl = discordCdnUrls[index]; // Use Discord CDN URL from array

  return {
    type: InteractionResponseType.UPDATE_MESSAGE,
    data: {
      components: [
        {
          type: 17, // Container
          accent_color: 0x9b59b6, // Purple for tips/features
          components: [
            {
              type: 10, // Text Display
              content: `## üí° CastBot Features Tour (${index + 1}/${totalCount})\n\n### ${currentScreenshot.title}\n\n${currentScreenshot.description}`
            },
            { type: 14 }, // Separator
            {
              type: 12, // Media Gallery - ONE screenshot at a time
              items: [
                {
                  media: { url: imageUrl },
                  description: currentScreenshot.title
                }
              ]
            },
            { type: 14 }, // Separator
            {
              type: 10,
              content: `> **\`üì∏ Feature Showcase (${index + 1}/${totalCount})\`**\n‚Ä¢ Use Previous/Next to explore all CastBot features\n‚Ä¢ Each screenshot shows a key feature in action\n‚Ä¢ ${totalCount} features total - discover everything CastBot can do!`
            },
            { type: 14 }, // Separator before navigation
            {
              type: 1, // Action Row - Navigation buttons
              components: [
                {
                  type: 2, // Button
                  custom_id: 'dm_back_to_welcome',
                  label: '‚Üê Back',
                  style: 2 // Secondary (grey)
                },
                {
                  type: 2, // Button
                  custom_id: `tips_prev_${index}`,
                  label: '‚óÄ Previous',
                  style: 2, // Secondary (grey)
                  disabled: index === 0
                },
                {
                  type: 2, // Button
                  custom_id: `tips_next_${index}`,
                  label: 'Next ‚ñ∂',
                  style: 2, // Secondary (grey)
                  disabled: index === totalCount - 1
                }
              ]
            }
          ]
        }
      ]
    }
  };
}
*/ // END DISABLED generateTipsScreen

// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
// NEW IMPLEMENTATION: Using attachment:// Protocol with Local Files
// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

/**
 * Generate initial tips screen using WEBHOOK FOLLOWUP with files
 * CRITICAL: Interaction responses CANNOT attach files - must use webhook API!
 *
 * Pattern:
 * 1. Return DEFERRED response to acknowledge interaction
 * 2. Use webhook.createMessage() with files attached
 * 3. Navigation uses webhook.editMessage() to switch attachment:// references
 *
 * @param {Object} interaction - Discord interaction object
 * @param {Object} client - Discord client
 * @returns {Object} DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE response
 */
async function generateInitialTipsScreen(interaction, client) {
  const path = await import('path');
  const fs = await import('fs/promises');
  const { AttachmentBuilder } = await import('discord.js');

  // Screenshot metadata (order matches filenames 1-10)
  const screenshots = [
    { title: 'ü¶Å Safari System', description: 'Create adventure challenges with maps, items, and player progression' },
    { title: 'üìã Dynamic Castlists', description: 'Organize cast members with placements, alumni, and custom formatting' },
    { title: 'üìä Production Menu', description: 'Comprehensive admin interface for managing all CastBot features' },
    { title: 'üèÜ Cast Rankings', description: 'Let players anonymously vote on applicants with visual ranking interface' },
    { title: 'üé¨ Season Management', description: 'Configure applications, questions, and production workflows' },
    { title: 'üì± Mobile View', description: 'CastBot works seamlessly on mobile devices with responsive design' },
    { title: 'üéÆ Player Menu', description: 'Access your profile, seasons, and interactive features from one place' },
    { title: 'üó∫Ô∏è Safari Map Explorer', description: 'Interactive map system with fog of war and location tracking' },
    { title: 'üìù Application Builder', description: 'Create custom season applications with multiple question types' },
    { title: '‚öôÔ∏è Settings & Configuration', description: 'Fine-tune CastBot behavior for your server needs' }
  ];

  // Load ALL 10 images from local filesystem using AttachmentBuilder
  const attachments = [];
  const basePath = path.join('/home/reece/castbot/img/tips');

  for (let i = 1; i <= 10; i++) {
    const filePath = path.join(basePath, `${i}.png`);

    try {
      // Use AttachmentBuilder for proper Discord.js file handling
      const attachment = new AttachmentBuilder(filePath, { name: `${i}.png` });
      attachments.push(attachment);

      // Log file size for debugging
      const stats = await fs.stat(filePath);
      console.log(`‚úÖ Loaded tip image ${i}.png (${stats.size} bytes)`);
    } catch (error) {
      console.error(`‚ùå Failed to load ${i}.png:`, error.message);
      throw new Error(`Failed to load tip image ${i}: ${error.message}`);
    }
  }

  const index = 0; // Start at first screenshot
  const currentScreenshot = screenshots[index];
  const totalCount = screenshots.length;

  // Create webhook followup message with files (async - doesn't block response)
  setTimeout(async () => {
    try {
      console.log('üì§ Creating webhook followup message with 10 attached files...');

      // Use Discord REST API for interaction followup (proper pattern for deferred responses)
      const FormData = (await import('form-data')).default;
      const fetch = (await import('node-fetch')).default;

      const form = new FormData();

      // Attach all 10 image files
      const attachmentDescriptors = [];
      for (let i = 0; i < attachments.length; i++) {
        const filePath = path.join(basePath, `${i + 1}.png`);
        const fileBuffer = await fs.readFile(filePath);
        const filename = `${i + 1}.png`;

        // Add file to form
        form.append(`files[${i}]`, fileBuffer, { filename });

        // Track attachment descriptor for payload
        attachmentDescriptors.push({
          id: i,
          filename: filename
        });
      }

      // Add payload JSON (components + flags + attachments array)
      const payload = {
        content: "üí° **CastBot Features Tour**",  // Fallback content (Discord requires SOMETHING)
        flags: (1 << 6),  // EPHEMERAL flag (64)
        attachments: attachmentDescriptors,  // CRITICAL: Describes which files are attached
        components: [
          {
            type: 17, // Container
            accent_color: 0x9b59b6, // Purple for tips/features
            components: [
              {
                type: 10, // Text Display
                content: `## üí° CastBot Features Tour (${index + 1}/${totalCount})\n\n### ${currentScreenshot.title}\n\n${currentScreenshot.description}`
              },
              { type: 14 }, // Separator
              {
                type: 12, // Media Gallery - Reference FIRST attached file
                items: [
                  {
                    media: { url: 'attachment://1.png' },  // Reference pre-attached file
                    description: currentScreenshot.title
                  }
                ]
              },
              { type: 14 }, // Separator
              {
                type: 10,
                content: `> **\`üì∏ Feature Showcase (${index + 1}/${totalCount})\`**\n‚Ä¢ Use Previous/Next to explore all CastBot features\n‚Ä¢ Each screenshot shows a key feature in action\n‚Ä¢ ${totalCount} features total - discover everything CastBot can do!`
              },
              { type: 14 }, // Separator before navigation
              {
                type: 1, // Action Row - Navigation buttons
                components: [
                  {
                    type: 2, // Button
                    custom_id: 'dm_back_to_welcome',
                    label: '‚Üê Back',
                    style: 2 // Secondary (grey)
                  },
                  {
                    type: 2, // Button
                    custom_id: `tips_prev_${index}`,
                    label: '‚óÄ Previous',
                    style: 2, // Secondary (grey)
                    disabled: true  // Disabled on first image
                  },
                  {
                    type: 2, // Button
                    custom_id: `tips_next_${index}`,
                    label: 'Next ‚ñ∂',
                    style: 2, // Secondary (grey)
                    disabled: false
                  }
                ]
              }
            ]
          }
        ]
      };

      form.append('payload_json', JSON.stringify(payload));

      // Debug: Log what we're sending
      console.log('üìã Payload structure:', JSON.stringify({
        hasContent: !!payload.content,
        hasComponents: !!payload.components,
        hasAttachments: !!payload.attachments,
        attachmentCount: attachmentDescriptors.length,
        componentCount: payload.components?.length || 0
      }));

      // Send POST request to Discord interaction webhook endpoint
      const webhookUrl = `https://discord.com/api/v10/webhooks/${interaction.application_id}/${interaction.token}`;
      console.log(`üì° Sending to: ${webhookUrl.substring(0, 80)}...`);

      const response = await fetch(webhookUrl, {
        method: 'POST',
        body: form,
        headers: form.getHeaders()
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }

      const result = await response.json();
      console.log('‚úÖ Webhook followup message sent successfully with all files!');
      console.log(`   Message ID: ${result.id}`);
    } catch (error) {
      console.error('‚ùå Failed to send webhook followup:', error.message);
      console.error(error);
    }
  }, 0);

  // Return immediate deferred response (tells Discord we're processing)
  return {
    type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE, // Type 5
    data: {
      flags: (1 << 6)  // EPHEMERAL flag
    }
  };
}

/**
 * Generate navigation update (UPDATE_MESSAGE)
 * References one of the 10 pre-attached images via attachment:// protocol
 *
 * @param {number} index - Screenshot index (0-9)
 * @returns {Object} UPDATE_MESSAGE response (edits existing message)
 */
function generateTipsScreenNavigation(index) {
  const screenshots = [
    { title: 'ü¶Å Safari System', description: 'Create adventure challenges with maps, items, and player progression' },
    { title: 'üìã Dynamic Castlists', description: 'Organize cast members with placements, alumni, and custom formatting' },
    { title: 'üìä Production Menu', description: 'Comprehensive admin interface for managing all CastBot features' },
    { title: 'üèÜ Cast Rankings', description: 'Let players anonymously vote on applicants with visual ranking interface' },
    { title: 'üé¨ Season Management', description: 'Configure applications, questions, and production workflows' },
    { title: 'üì± Mobile View', description: 'CastBot works seamlessly on mobile devices with responsive design' },
    { title: 'üéÆ Player Menu', description: 'Access your profile, seasons, and interactive features from one place' },
    { title: 'üó∫Ô∏è Safari Map Explorer', description: 'Interactive map system with fog of war and location tracking' },
    { title: 'üìù Application Builder', description: 'Create custom season applications with multiple question types' },
    { title: '‚öôÔ∏è Settings & Configuration', description: 'Fine-tune CastBot behavior for your server needs' }
  ];

  const currentScreenshot = screenshots[index];
  const totalCount = screenshots.length;
  const imageNumber = index + 1; // attachment://1.png through attachment://10.png

  return {
    type: InteractionResponseType.UPDATE_MESSAGE, // Type 7 - Edit existing message
    data: {
      components: [
        {
          type: 17, // Container
          accent_color: 0x9b59b6, // Purple for tips/features
          components: [
            {
              type: 10, // Text Display
              content: `## üí° CastBot Features Tour (${index + 1}/${totalCount})\n\n### ${currentScreenshot.title}\n\n${currentScreenshot.description}`
            },
            { type: 14 }, // Separator
            {
              type: 12, // Media Gallery - Reference different attached file
              items: [
                {
                  media: { url: `attachment://${imageNumber}.png` },  // attachment://1.png to attachment://10.png
                  description: currentScreenshot.title
                }
              ]
            },
            { type: 14 }, // Separator
            {
              type: 10,
              content: `> **\`üì∏ Feature Showcase (${index + 1}/${totalCount})\`**\n‚Ä¢ Use Previous/Next to explore all CastBot features\n‚Ä¢ Each screenshot shows a key feature in action\n‚Ä¢ ${totalCount} features total - discover everything CastBot can do!`
            },
            { type: 14 }, // Separator before navigation
            {
              type: 1, // Action Row - Navigation buttons
              components: [
                {
                  type: 2, // Button
                  custom_id: 'dm_back_to_welcome',
                  label: '‚Üê Back',
                  style: 2 // Secondary (grey)
                },
                {
                  type: 2, // Button
                  custom_id: `tips_prev_${index}`,
                  label: '‚óÄ Previous',
                  style: 2, // Secondary (grey)
                  disabled: index === 0
                },
                {
                  type: 2, // Button
                  custom_id: `tips_next_${index}`,
                  label: 'Next ‚ñ∂',
                  style: 2, // Secondary (grey)
                  disabled: index === totalCount - 1
                }
              ]
            }
          ]
        }
      ]
    }
  };
}

// ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

app.post('/interactions', verifyKeyMiddleware(process.env.PUBLIC_KEY), async function (req, res) {
    // Verbose logging controlled by DEBUG_VERBOSE environment variable
    if (shouldLog('VERBOSE')) {
        console.log("Got headers:", JSON.stringify(req.headers, null, 2));
        console.log("Got body:", req.body);
    }
    
    // Clear request-scoped caches at the start of each interaction
    const { clearRequestCache } = await import('./storage.js');
    const { clearSafariCache } = await import('./safariManager.js');
    clearRequestCache();
    clearSafariCache();
    
  // Interaction type and data
  const { type, id, data, guild_id } = req.body;
  
  // Check for duplicate interactions
  if (id && processedInteractions.has(id)) {
    console.log(`‚ö†Ô∏è Duplicate interaction detected: ${id}`);
    return res.status(204).send(); // Return no content for duplicates
  }
  
  // Store interaction ID with timestamp
  if (id) {
    processedInteractions.set(id, Date.now());
    
    // Clean up old entries after 5 minutes
    setTimeout(() => {
      processedInteractions.delete(id);
    }, 5 * 60 * 1000);
  }

  /**
   * Handle verification requests
   */
  if (type === InteractionType.PING) {
    return res.send({ type: InteractionResponseType.PONG });
  }
  
  // Check for pending whispers (skip for PING interactions)
  if (type !== InteractionType.PING && req.body.member?.user?.id) {
    const userId = req.body.member.user.id;
    const token = req.body.token;
    
    // Deliver pending whispers as a follow-up message
    const { checkAndDeliverWhispers } = await import('./whisperManager.js');
    checkAndDeliverWhispers(userId, token).catch(error => {
      console.error('Failed to deliver pending whispers:', error);
    });
  }
  



  /**
   * Handle slash command requests !
   * See https://discord.com/developers/docs/interactions/application-commands#slash-commands
   */
  if (type === InteractionType.APPLICATION_COMMAND) {
    const name = data.name;

    console.log(`Received command: ${name}`);

    // Analytics logging for slash commands
    const user = req.body.member?.user || req.body.user;
    const guild = req.body.guild;
    const member = req.body.member;
    const channelId = req.body.channel_id;
    
    
    if (user && guild) {
      // Get display name (nickname or global_name)
      const displayName = member?.nick || user.global_name || user.username;
      
      // Get channel name from Discord.js client (more reliable than REST API)
      let channelName = null;
      if (channelId) {
        try {
          // First try Discord.js client cache
          const channel = client?.channels?.cache?.get(channelId);
          if (channel?.name) {
            channelName = channel.name;
            console.log(`üìç DEBUG: Channel name from cache: #${channelName} (${channelId})`);
          } else {
            // Fallback to fetching via client
            if (client) {
              const fetchedChannel = await client.channels.fetch(channelId);
              if (fetchedChannel?.name) {
                channelName = fetchedChannel.name;
                console.log(`üìç DEBUG: Channel name from fetch: #${channelName} (${channelId})`);
              }
            }
          }
          
          // Last resort: Discord REST API
          if (!channelName) {
            const channelResponse = await DiscordRequest(`channels/${channelId}`, { method: 'GET' });
            if (channelResponse.ok) {
              const channelData = await channelResponse.json();
              channelName = channelData.name;
              console.log(`üìç DEBUG: Channel name from REST API: #${channelName} (${channelId})`);
            } else {
              console.log(`‚ö†Ô∏è DEBUG: REST API failed for channel ${channelId}, status:`, channelResponse.status);
            }
          }
        } catch (error) {
          console.log('Could not fetch channel name for analytics:', error.message);
        }
      }
      
      await logInteraction(
        user.id,
        req.body.guild_id,
        'SLASH_COMMAND',
        `/${name}`,
        user.username,
        guild.name || 'Unknown Server',
        null, // no components for slash commands
        channelName,
        displayName
      );
    }

    // Only castlist and menu are open commands - all others removed
    const readOnlyCommands = ['castlist', 'menu'];
    if (!readOnlyCommands.includes(name)) {
      const hasPerms = await hasRequiredPermissions(req.body.guild_id, req.body.member.user.id);
      if (!hasPerms) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'You need Manage Channels, Manage Server, or Manage Roles permission to use this command.',
            flags: InteractionResponseFlags.EPHEMERAL,
          },
        });
      }
    }

    if (name === 'castlist') {
    // ROUTE TO CASTLIST2: /castlist now uses Components V2 functionality
    try {
      console.log('Processing castlist command (routed to Components V2 - Unified Data Access)');
      const guildId = req.body.guild_id;
      const userId = req.body.member.user.id;
      const requestedCastlist = data.options?.find(opt => opt.name === 'castlist')?.value;

      // ‚úÖ NEW: Single unified call via Virtual Adapter
      const { getTribesForCastlist } = await import('./castlistDataAccess.js');
      const castlistIdentifier = requestedCastlist || 'default';
      console.log(`Selected castlist: ${castlistIdentifier}`);

      // Check permissions BEFORE sending deferred response to determine response type
      const member = req.body.member;
      const channelId = req.body.channel_id;
      const canSendMessages = await canSendMessagesInChannel(member, channelId, client);
      console.log(`Pre-deferred permission check: User ${member?.user?.username} can send messages in channel ${channelId}: ${canSendMessages}`);

      // Send appropriate deferred response based on permissions
      if (canSendMessages) {
        // User can send messages - public deferred response
        res.send({ type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE });
        console.log('[CASTLIST] Sent deferred response');
      } else {
        // User cannot send messages - ephemeral deferred response
        res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
          data: { flags: InteractionResponseFlags.EPHEMERAL }
        });
        console.log('[CASTLIST] Sent ephemeral deferred response');
      }

      // Get tribes via unified data access (handles legacy + modern castlists)
      const validTribes = await getTribesForCastlist(guildId, castlistIdentifier, client);
      console.log(`Loaded ${validTribes.length} tribes via unified data access`);

      if (validTribes.length === 0) {
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: `No tribes found for castlist: ${castlistIdentifier}. Please add tribes via Production Menu.`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        return;
      }

      // Pre-load playerData for sorting (placements, etc.)
      const playerData = await loadPlayerData();
      const guild = await client.guilds.fetch(guildId);

      // Apply user-first tribe ordering for default castlists
      const orderedTribes = reorderTribes(validTribes, userId, "user-first", castlistIdentifier);

      // Determine display scenario based on component calculations
      const scenario = determineDisplayScenario(orderedTribes);
      console.log(`Component scenario: ${scenario}`);

      // Log component calculations for debugging
      orderedTribes.forEach(tribe => {
        const withSeparators = calculateComponentsForTribe(tribe.memberCount, true);
        const withoutSeparators = calculateComponentsForTribe(tribe.memberCount, false);
        console.log(`Tribe ${tribe.name}: ${tribe.memberCount} members = ${withSeparators} components (with separators), ${withoutSeparators} (without)`);
      });

      // Create navigation state for initial display (first tribe, first page)
      const navigationState = createNavigationState(orderedTribes, scenario, 0, 0, guild, { playerData, guildId });

      await sendCastlist2Response(req, guild, orderedTribes, castlistIdentifier, navigationState, req.body.member, req.body.channel_id, 'view', null, { playerData, guildId });
      console.log('[CASTLIST] Sent castlist via webhook follow-up');

    } catch (error) {
      console.error('Error handling castlist command:', error);
      const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;

      // Sanitize error message (prevent Cloudflare HTML pages from breaking display)
      const { sanitizeErrorMessage } = await import('./utils.js');
      const errorMessage = sanitizeErrorMessage(error);

      await DiscordRequest(endpoint, {
        method: 'PATCH',
        body: {
          content: `Error displaying castlist: ${errorMessage}`,
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    }
    return;
} else if (name === 'castlist2') {
  try {
    console.log('Processing castlist2 command (Components V2 - Dynamic)');
    const guildId = req.body.guild_id;
    const userId = req.body.member.user.id;
    const requestedCastlist = data.options?.find(opt => opt.name === 'castlist')?.value;

    // Determine which castlist to show
    const castlistToShow = await determineCastlistToShow(guildId, userId, requestedCastlist);
    console.log(`Selected castlist: ${castlistToShow}`);

    // Load initial tribe data
    const rawTribes = await getGuildTribes(guildId, castlistToShow);
    console.log('Loaded raw tribes:', JSON.stringify(rawTribes));

    if (rawTribes.length === 0) {
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          flags: 1 << 15,
          components: [
            { type: 10, content: '# No Tribes Found' },
            { type: 10, content: 'No tribes have been added to the default Castlist yet. Please have Production add tribes via the `/prod_menu` > `üî• Tribes` Button > `üõ†Ô∏è Add Tribe`.' }
          ]
        }
      });
    }

    // Send deferred response
    res.send({ type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE });

    const guild = await client.guilds.fetch(guildId);
    const fullGuild = await client.guilds.fetch(guildId, { force: true });
    await fullGuild.roles.fetch();

    // Pre-load playerData for sorting (placements, etc.)
    const playerData = await loadPlayerData();

    // Ensure member cache is fully populated (post-restart fix)
    console.log(`Fetching members for guild ${fullGuild.name} (${fullGuild.memberCount} total)`);
    const members = await fullGuild.members.fetch({ force: true });

    // Process tribes and gather member data
    const tribesWithMembers = await Promise.all(rawTribes.map(async (tribe) => {
      const role = await fullGuild.roles.fetch(tribe.roleId);
      if (!role) {
        console.warn(`Role not found for tribe ${tribe.roleId} on server ${fullGuild.name} (${fullGuild.id}), skipping...`);
        return null;
      }
      
      const tribeMembers = members.filter(member => member.roles.cache.has(role.id));
      return {
        ...tribe,
        name: role.name,
        memberCount: tribeMembers.size,
        members: Array.from(tribeMembers.values())
      };
    }));

    // Filter out tribes with missing roles
    const validTribes = tribesWithMembers.filter(tribe => tribe !== null);
    
    if (validTribes.length === 0) {
      const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
      await DiscordRequest(endpoint, {
        method: 'PATCH',
        body: {
          content: 'No valid tribes found. Some tribe roles may have been deleted. Please use the Add Tribes button to set up tribes again.',
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
      return;
    }

    // Apply user-first tribe ordering for default castlists
    const orderedTribes = reorderTribes(validTribes, userId, "user-first", castlistToShow);

    // Determine display scenario based on component calculations
    const scenario = determineDisplayScenario(orderedTribes);
    console.log(`Component scenario: ${scenario}`);

    // Log component calculations for debugging
    orderedTribes.forEach(tribe => {
      const withSeparators = calculateComponentsForTribe(tribe.memberCount, true);
      const withoutSeparators = calculateComponentsForTribe(tribe.memberCount, false);
      console.log(`Tribe ${tribe.name}: ${tribe.memberCount} members = ${withSeparators} components (with separators), ${withoutSeparators} (without)`);
    });

    // Create navigation state for initial display (first tribe, first page)
    const navigationState = createNavigationState(orderedTribes, scenario, 0, 0, fullGuild, { playerData, guildId });

    await sendCastlist2Response(req, fullGuild, orderedTribes, castlistToShow, navigationState, req.body.member, req.body.channel_id, 'view', null, { playerData, guildId });

  } catch (error) {
    console.error('Error handling castlist2 command:', error);
    const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;

    // Sanitize error message (prevent Cloudflare HTML pages from breaking display)
    const { sanitizeErrorMessage } = await import('./utils.js');
    const errorMessage = sanitizeErrorMessage(error);

    await DiscordRequest(endpoint, {
      method: 'PATCH',
      body: {
        content: `Error displaying Components V2 castlist: ${errorMessage}`,
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
  }
  return;
// REMOVED: prod_menu command handler - merged into unified /menu command with admin detection
} else if (name === 'menu') {
  try {
    console.log(`Processing unified menu command ${discordLogTags.source.SLASH}`);

    // Send deferred response IMMEDIATELY (matches /castlist pattern)
    await res.send({
      type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
    console.log(`[MENU] ‚úÖ Sent deferred response ${discordLogTags.response.DEFERRED_NEW} ${discordLogTags.visibility.EPHEMERAL}`);

    // THEN check permissions and load data
    const member = req.body.member;
    const isAdmin = hasAdminPermissions(member);
    console.log(`[MENU] Menu access: Admin=${isAdmin}, User=${member?.user?.username || 'unknown'}`);

    const guildId = req.body.guild_id;
    const guild = await client.guilds.fetch(guildId);
    console.log(`[MENU] ‚è±Ô∏è Guild fetched: ${guild.name}`);
    
    // Get all tribes to find unique castlists
    const playerData = await loadPlayerData();
    const playerDataSize = JSON.stringify(playerData).length;
    console.log(`[MENU] ‚è±Ô∏è PlayerData loaded (${playerDataSize} bytes, ${Object.keys(playerData).length} guilds)`);
    const allCastlists = new Set();
    const castlistTribes = {}; // Track tribes per castlist to get emojis
    
    if (playerData[guildId]?.tribes) {
      Object.entries(playerData[guildId].tribes).forEach(([roleId, tribeData]) => {
        if (!tribeData) return; // Skip null/undefined tribe entries
        const castlistName = tribeData.castlist || 'default';
        allCastlists.add(castlistName);
        
        // Store tribe info for each castlist (for emojis)
        if (!castlistTribes[castlistName]) {
          castlistTribes[castlistName] = [];
        }
        castlistTribes[castlistName].push({
          roleId,
          emoji: tribeData.emoji,
          color: tribeData.color,
          showPlayerEmojis: tribeData.showPlayerEmojis
        });
      });
    }
    
    if (isAdmin) {
      // Admin user - use createProductionMenuInterface function
      const userId = req.body.member?.user?.id;
      const menuResponse = await createProductionMenuInterface(guild, playerData, guildId, userId);
      console.log('[MENU] üìã Production menu interface created');

      const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
      console.log(`[MENU] üì§ Sending menu via webhook ${discordLogTags.response.WEBHOOK_PATCH} ${discordLogTags.visibility.EPHEMERAL}`);
      await DiscordRequest(endpoint, {
        method: 'PATCH',
        body: menuResponse
      });
      console.log('[MENU] ‚úÖ Menu sent successfully via webhook');

    } else {
      // Regular user - use new player management UI
      const userId = member.user.id;
      const targetMember = await guild.members.fetch(userId);

      // Create player management UI
      const managementUI = await createPlayerManagementUI({
        mode: PlayerManagementMode.PLAYER,
        targetMember,
        playerData,
        guildId,
        userId,
        channelId: req.body.channel_id,
        showUserSelect: false,
        showVanityRoles: false,
        title: 'CastBot | Player Menu',
        client
      });
      console.log('[MENU] üìã Player management UI created');

      const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
      console.log(`[MENU] üì§ Sending player menu via webhook ${discordLogTags.response.WEBHOOK_PATCH} ${discordLogTags.visibility.EPHEMERAL}`);
      await DiscordRequest(endpoint, {
        method: 'PATCH',
        body: managementUI
      });
      console.log('[MENU] ‚úÖ Player menu sent successfully via webhook');
    }
    
  } catch (error) {
    console.error('Error handling menu command:', error);
    
    try {
      const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
      await DiscordRequest(endpoint, {
        method: 'PATCH',
        body: {
          content: '‚ùå Error loading menu. Please try again.',
          components: [],
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    } catch (updateError) {
      console.error('Failed to update message with error:', updateError);
    }
  }
  return;
// REMOVED: clear_tribe command - functionality moved to /menu ‚Üí Production Menu ‚Üí Tribes
} else if (false && name === 'clear_tribe') {
    try {
      console.log('Processing /clear_tribe command');
      await res.send({
        type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
      });

      const guildId = req.body.guild_id;
      const guild = await client.guilds.fetch(guildId);
      const roleOption = data.options.find(opt => opt.name === 'role');
      const roleId = roleOption.value;
      const token = req.body.token; // Store the token for later use
      
      console.log(`Processing clear_tribe for role ${roleId} in guild ${guildId}`);

      // Load full data structure
      const playerData = await loadPlayerData();
      if (!playerData[guildId]?.tribes) {
        console.log('No guild data found');
        try {
          const endpoint = `webhooks/${process.env.APP_ID}/${token}/messages/@original`;
          await DiscordRequest(endpoint, {
            method: 'PATCH',
            body: {
              content: 'No tribe data found for this server',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        } catch (webhookError) {
          console.error('Webhook response error:', webhookError);
          // If webhook fails, we can't do anything, just log it
        }
        return;
      }

      // Check if tribe exists
      if (!playerData[guildId].tribes[roleId]) {
        console.log('No tribe found with this role ID');
        try {
          const endpoint = `webhooks/${process.env.APP_ID}/${token}/messages/@original`;
          await DiscordRequest(endpoint, {
            method: 'PATCH',
            body: {
              content: `No tribe found with role <@&${roleId}>`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        } catch (webhookError) {
          console.error('Webhook response error:', webhookError);
          // If webhook fails, we can't do anything, just log it
        }
        return;
      }

      // Store the tribe name and castlist before deletion for the message
      const tribeName = (await guild.roles.fetch(roleId))?.name || roleId;
      const castlist = playerData[guildId].tribes[roleId].castlist || 'default';

      // Get all members with this tribe role (REST API)
      const members = await guild.members.list({ limit: 1000 });
      const targetMembers = members.filter(m => m.roles.cache.has(roleId));
      console.log(`Found ${targetMembers.size} members with tribe role`);

      const resultLines = [];

      // Process each member with the tribe role
      for (const [memberId, member] of targetMembers) {
        if (playerData[guildId].players[memberId]?.emojiCode) {
          const emojiCode = playerData[guildId].players[memberId].emojiCode;
          const emoji = parseEmojiCode(emojiCode);
          
          if (emoji?.id) {
            try {
              const guildEmoji = await guild.emojis.fetch(emoji.id);
              if (guildEmoji) {
                await guildEmoji.delete();
                console.log(`Deleted ${emoji.animated ? 'animated' : 'static'} emoji for ${member.displayName}`);
                resultLines.push(`Deleted ${emoji.animated ? 'animated' : 'static'} emoji for ${member.displayName}`);
              }
            } catch (err) {
              console.error(`Error deleting emoji for ${member.displayName}:`, {
                error: err,
                emojiCode: emojiCode,
                emojiData: emoji
              });
              resultLines.push(`Failed to delete emoji for ${member.displayName}`);
            }
          }
          // Clear emoji code
          playerData[guildId].players[memberId].emojiCode = null;
        }
      }

      // Remove tribe
      delete playerData[guildId].tribes[roleId];

      // Save updated data
      await savePlayerData(playerData);
      console.log('Saved updated player data');

      // Send response
      try {
        const endpoint = `webhooks/${process.env.APP_ID}/${token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: resultLines.length > 0 
              ? `Cleared tribe ${tribeName} from castlist '${castlist}'.\n${resultLines.join('\n')}`
              : `Cleared tribe ${tribeName} from castlist '${castlist}'. No emojis needed to be removed.`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      } catch (webhookError) {
        console.error('Error updating webhook response:', webhookError);
        // The webhook might have expired, but the operation has completed successfully
        console.log('However, tribe deletion was successful');
      }

    } catch (error) {
      console.error('Error in clear_tribe:', error);
      try {
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: 'Error clearing tribe. Please check server logs.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      } catch (webhookError) {
        console.error('Could not send error message via webhook:', webhookError);
        // Webhook has likely expired, nothing more we can do
      }
    }
    return;
// REMOVED: set_players_age command - functionality moved to /menu system
    // REMOVED: pronouns_add command - functionality moved to /menu ‚Üí Production Menu ‚Üí Pronouns & Timezones
    } else if (false && name === 'pronouns_add') {     // Changed from addpronouns
      try {
        console.log('Processing pronouns_add command');
        await res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
        });
    
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        
        // Process all possible role options (up to 12)
        const roleOptions = [];
        for (let i = 1; i <= 12; i++) {
          const roleOption = data.options.find(opt => opt.name === `role${i}`);
          if (roleOption) {
            roleOptions.push(roleOption.value);
          }
        }

        console.log('Roles to add:', roleOptions);
    
        // Load current pronouns from guild data
        const currentPronouns = new Set(await getGuildPronouns(guildId));
        const added = [];
        const alreadyExists = [];
    
        // Add new roles
        for (const roleId of roleOptions) {
          const role = await guild.roles.fetch(roleId);
          if (currentPronouns.has(roleId)) {
            alreadyExists.push(`<@&${roleId}> (${roleId})`);
          } else {
            currentPronouns.add(roleId);
            added.push(`<@&${roleId}> (${roleId})`);
          }
        }
    
        // Save updated pronouns
        await updateGuildPronouns(guildId, Array.from(currentPronouns));
    
        // Prepare response message  
        const addedMsg = added.length > 0 ? `Players can now be assigned the following roles which will show up on the dynamic castlist: ${added.join(', ')}` : '';
        const existsMsg = alreadyExists.length > 0 ? `Already existed: ${alreadyExists.join(', ')}` : '';
        const message = [addedMsg, existsMsg].filter(msg => msg).join('\n');
    
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: message || 'No changes made to pronoun roles.',
            flags: InteractionResponseFlags.EPHEMERAL
          },
        });
      } catch (error) {
        console.error('Error processing pronouns_add command:', error);
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: 'Error updating pronoun roles.',
            flags: InteractionResponseFlags.EPHEMERAL
          },
        });
      }
      return;
    } else if (name === 'remove_pronouns') {   // Changed from removepronouns
      try {
        console.log('Processing removepronouns command');
        await res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
        });

        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        const removedPronouns = [];
        const notFoundPronouns = [];

        // Process each role parameter (up to 12)
        for (let i = 1; i <= 12; i++) {
          const roleOption = data.options?.find(opt => opt.name === `role${i}`);
          if (roleOption) {
            const roleId = roleOption.value;
            const role = await guild.roles.fetch(roleId);
            const roleName = role ? role.name : roleId;
            
            // Check if pronoun exists in playerData
            const currentPronouns = await getGuildPronouns(guildId);
            if (currentPronouns.includes(roleId)) {
              const updatedPronouns = currentPronouns.filter(id => id !== roleId);
              await updateGuildPronouns(guildId, updatedPronouns);
              removedPronouns.push(`<@&${roleId}> (${roleId})`);
            } else {
              notFoundPronouns.push(`<@&${roleId}> (${roleId})`);
            }
          }
        }

        // Construct response message
        let message = '';
        if (removedPronouns.length > 0) {
          message += `Successfully removed the following pronouns: ${removedPronouns.join(', ')}\n`;
        }
        if (notFoundPronouns.length > 0) {
          message += `The following pronouns were not found in the pronoun list, so nothing was removed: ${notFoundPronouns.join(', ')}`;
        }

        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: message || 'No pronouns were removed.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });

      } catch (error) {
        console.error('Error in removepronouns command:', error);
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: 'There was an error while removing pronouns.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    // REMOVED: timezones_add command - functionality moved to /menu ‚Üí Production Menu ‚Üí Pronouns & Timezones
    } else if (false && name === 'timezones_add') {    // Changed from addtimezone
  try {
    console.log('Processing addtimezone command');
    const guildId = req.body.guild_id;
    const updates = [];
    
    // Process each timezone-offset pair
    for (let i = 1; i <= 12; i++) {
      const tzOption = data.options?.find(opt => opt.name === `timezone${i}`);
      const offsetOption = data.options?.find(opt => opt.name === `timezone${i}_offset`);
      
      if (tzOption && offsetOption) {
        console.log(`Found timezone${i} data:`, {
          timezone: tzOption,
          offset: offsetOption
        });
        
        // Clean up the offset value (remove + if present) and preserve decimal portions
        const cleanOffset = parseFloat(offsetOption.value.replace(/^\+/, ''));
        
        if (isNaN(cleanOffset)) {
          console.error(`Invalid offset value for timezone${i}: ${offsetOption.value}`);
          continue;
        }
        
        updates.push({
          roleId: tzOption.value,
          offset: cleanOffset
        });
      }
    }
    
    if (updates.length === 0) {
      console.log('No valid timezone-offset pairs found');
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: 'No valid timezone-offset pairs provided',
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    }
    
    // Load and ensure guild data exists
    const storageData = await loadPlayerData();  // Changed variable name from data to storageData
    if (!storageData[guildId]) {
      storageData[guildId] = { timezones: {} };
    }
    if (!storageData[guildId].timezones) {
      storageData[guildId].timezones = {};
    }
    
    // Process updates
    const results = [];
    for (const update of updates) {
      const isNew = !storageData[guildId].timezones[update.roleId];
      
      // Add or update timezone
      storageData[guildId].timezones[update.roleId] = {
        offset: update.offset
      };
      
      // Get role name for the message
      const guild = await client.guilds.fetch(guildId);
      const role = await guild.roles.fetch(update.roleId);
      const roleName = role ? role.name : update.roleId;
      
      results.push(
        isNew
          ? `Timezone <@&${update.roleId}> (${update.roleId}) added with offset ${update.offset}`
          : `Timezone <@&${update.roleId}> (${update.roleId}) updated with offset ${update.offset}`
      );
    }
    
    // Save changes
    await savePlayerData(storageData);
    
    console.log('Updates processed:', results);
    
    return res.send({
      type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        content: results.join('\n'),
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
    
  } catch (err) {
    console.error('Error processing addtimezone command:', err);
    return res.send({
      type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        content: 'Failed to update timezones.',
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
  }
// REMOVED: timezones_remove command - functionality moved to /menu ‚Üí Production Menu ‚Üí Pronouns & Timezones
} else if (false && name === 'timezones_remove') {
  try {
    console.log('Processing timezones_remove command');
    await res.send({
      type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
    });

    const guildId = req.body.guild_id;
    const guild = await client.guilds.fetch(guildId);
    const removed = [];
    const notFound = [];

    // Process all possible role options (up to 12)
    const roleOptions = [];
    for (let i = 1; i <= 12; i++) {
      const roleOption = data.options?.find(opt => opt.name === `timezone${i}`);
      if (roleOption) {
        roleOptions.push(roleOption.value);
      }
    }

    console.log('Roles to remove:', roleOptions);

    // Load current timezone data
    const playerData = await loadPlayerData();
    if (!playerData[guildId]?.timezones) {
      const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
      await DiscordRequest(endpoint, {
        method: 'PATCH',
        body: {
          content: 'No timezones have been set up for this server yet.',
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
      return;
    }

    // Process each role
    for (const roleId of roleOptions) {
      if (playerData[guildId].timezones[roleId]) {
        delete playerData[guildId].timezones[roleId];
        removed.push(`<@&${roleId}> (${roleId})`);
      } else {
        notFound.push(`<@&${roleId}> (${roleId})`);
      }
    }

    // Save changes
    await savePlayerData(playerData);

    // Prepare response message
    const removedMsg = removed.length > 0 ? `Successfully removed: ${removed.join(', ')}` : '';
    const notFoundMsg = notFound.length > 0 ? `Not found in timezone list: ${notFound.join(', ')}` : '';
    const message = [removedMsg, notFoundMsg].filter(msg => msg).join('\n');

    const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
    await DiscordRequest(endpoint, {
      method: 'PATCH',
      body: {
        content: message || 'No timezone roles were specified for removal.',
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });

  } catch (error) {
    console.error('Error in timezones_remove:', error);
    const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
    await DiscordRequest(endpoint, {
      method: 'PATCH',
      body: {
        content: 'Error removing timezone roles.',
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
  }
  return;
} else if (name === 'react_timezones') {
  try {
    const guildId = req.body.guild_id;
    const guild = await client.guilds.fetch(guildId);

    // Get timezone roles from storage
    const timezones = await getGuildTimezones(guildId);
    if (!Object.keys(timezones).length) {
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: 'No timezone roles found. Ask an admin to add some using the "üó∫Ô∏è Add Timezone" button in the admin menu first!',
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    }

    // Get role objects and sort alphabetically
    const roles = await Promise.all(
      Object.keys(timezones).map(id => guild.roles.fetch(id))
    );
    const sortedRoles = roles
      .filter(role => role) // Remove any null roles
      .sort((a, b) => a.name.localeCompare(b.name));

    if (sortedRoles.length > REACTION_EMOJIS.length) {
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: `Too many timezone roles to post React for Pronouns prompt (maximum ${REACTION_EMOJIS.length} supported due to Discord limits). Please remove timezones from \`/menu\` > Reaction Roles > Bulk Modify (no offset) until you have ${REACTION_EMOJIS.length} or less.`,
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    }

    // Create embed
    const embed = new EmbedBuilder()
      .setTitle('Timezone Role Selection')
      .setDescription('React with the emoji corresponding to your timezone:\n\n' + 
        sortedRoles.map((role, i) => `${REACTION_EMOJIS[i]} - ${role.name}`).join('\n'))
      .setColor('#7ED321');

    // Send the message
    await res.send({
      type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        embeds: [embed]
      }
    });

    // Get the message we just sent
    const response = await fetch(
      `https://discord.com/api/v10/channels/${req.body.channel_id}/messages`,
      {
        headers: {
          Authorization: `Bot ${process.env.DISCORD_TOKEN}`,
          'Content-Type': 'application/json',
        },
      }
    );
    const messages = await response.json();
    const message = messages[0];  // Get most recent message

    // Add reactions
    for (let i = 0; i < sortedRoles.length; i++) {
      await fetch(
        `https://discord.com/api/v10/channels/${req.body.channel_id}/messages/${message.id}/reactions/${encodeURIComponent(REACTION_EMOJIS[i])}/@me`,
        {
          method: 'PUT',
          headers: {
            Authorization: `Bot ${process.env.DISCORD_TOKEN}`,
          },
        }
      );
    }

    // Store role-emoji mappings in memory for reaction handler
    if (!client.roleReactions) client.roleReactions = new Map();
    client.roleReactions.set(message.id, 
      Object.fromEntries(sortedRoles.map((role, i) => [REACTION_EMOJIS[i], role.id]))
    );

  } catch (error) {
    console.error('Error in react_timezones:', error);
    return res.send({
      type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        content: 'Error creating reaction message',
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
  }
  return;
} else if (name === 'player_set_pronouns') {  // Changed from react_pronouns
  try {
    const guildId = req.body.guild_id;
    const guild = await client.guilds.fetch(guildId);

    // Get pronoun roles from storage
    const pronounRoleIDs = await getGuildPronouns(guildId);
    if (!pronounRoleIDs?.length) {
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: 'No pronoun roles found. Add some using /pronouns_add first!',
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    }

    // Get role objects and sort alphabetically
    const roles = await Promise.all(
      pronounRoleIDs.map(id => guild.roles.fetch(id))
    );
    const sortedRoles = roles
      .filter(role => role) // Remove any null roles
      .sort((a, b) => a.name.localeCompare(b.name));

    if (sortedRoles.length > REACTION_EMOJIS.length) {
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: `Too many pronoun roles (maximum ${REACTION_EMOJIS.length} supported due to Discord limits)`,
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    }

    // Create embed
    const embed = new EmbedBuilder()
      .setTitle('Pronoun Role Selection')
      .setDescription('React with the emoji corresponding to your pronouns:\n\n' + 
        sortedRoles.map((role, i) => `${REACTION_EMOJIS[i]} - ${role.name}`).join('\n'))
      .setColor('#7ED321');

    // Send initial response
    await res.send({
      type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
    });

    // Send the embed as a follow-up and get the message directly
    const followUpResponse = await DiscordRequest(`webhooks/${process.env.APP_ID}/${req.body.token}`, {
      method: 'POST',
      body: {
        embeds: [embed]
      }
    });

    if (!followUpResponse.id) {
      console.error('Failed to get message ID from follow-up response');
      return;
    }

    const messageId = followUpResponse.id;

    // Add reactions with proper error handling
    for (let i = 0; i < sortedRoles.length; i++) {
      try {
        await fetch(
          `https://discord.com/api/v10/channels/${req.body.channel_id}/messages/${messageId}/reactions/${encodeURIComponent(REACTION_EMOJIS[i])}/@me`,
          {
            method: 'PUT',
            headers: {
              Authorization: `Bot ${process.env.DISCORD_TOKEN}`,
            },
          }
        );
        // Small delay to avoid rate limits
        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (error) {
        console.error(`Failed to add reaction ${REACTION_EMOJIS[i]}:`, error);
      }
    }

    // Store role-emoji mappings in memory for reaction handler
    if (!client.roleReactions) client.roleReactions = new Map();
    client.roleReactions.set(messageId, 
      Object.fromEntries(sortedRoles.map((role, i) => [REACTION_EMOJIS[i], role.id]))
    );

  } catch (error) {
    console.error('Error in react_pronouns:', error);
    return res.send({
      type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        content: 'Error creating reaction message',
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
  }
  return;
} else if (name === 'player_set_timezone') {  // Changed from react_timezones
  try {
    const guildId = req.body.guild_id;
    const guild = await client.guilds.fetch(guildId);

    // Get timezone roles from storage
    const timezones = await getGuildTimezones(guildId);
    if (!Object.keys(timezones).length) {
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: 'No timezone roles found. Ask an admin to add some using the "üó∫Ô∏è Add Timezone" button in the admin menu first!',
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    }

    // Get role objects and sort alphabetically
    const roles = await Promise.all(
      Object.keys(timezones).map(id => guild.roles.fetch(id))
    );
    const sortedRoles = roles
      .filter(role => role) // Remove any null roles
      .sort((a, b) => a.name.localeCompare(b.name));

    if (sortedRoles.length > REACTION_EMOJIS.length) {
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: `Too many timezone roles to post React for Pronouns prompt (maximum ${REACTION_EMOJIS.length} supported due to Discord limits). Please remove timezones from \`/menu\` > Reaction Roles > Bulk Modify (no offset) until you have ${REACTION_EMOJIS.length} or less.`,
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    }

    // Create embed
    const embed = new EmbedBuilder()
      .setTitle('Timezone Role Selection')
      .setDescription('React with the emoji corresponding to your timezone:\n\n' + 
        sortedRoles.map((role, i) => `${REACTION_EMOJIS[i]} - ${role.name}`).join('\n'))
      .setColor('#7ED321');

    // Send initial response
    await res.send({
      type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
    });

    // Send the embed as a follow-up and get the message directly
    const followUpResponse = await DiscordRequest(`webhooks/${process.env.APP_ID}/${req.body.token}`, {
      method: 'POST',
      body: {
        embeds: [embed]
      }
    });

    if (!followUpResponse.id) {
      console.error('Failed to get message ID from follow-up response');
      return;
    }

    const messageId = followUpResponse.id;

    // Add reactions with proper error handling
    for (let i = 0; i < sortedRoles.length; i++) {
      try {
        await fetch(
          `https://discord.com/api/v10/channels/${req.body.channel_id}/messages/${messageId}/reactions/${encodeURIComponent(REACTION_EMOJIS[i])}/@me`,
          {
            method: 'PUT',
            headers: {
              Authorization: `Bot ${process.env.DISCORD_TOKEN}`,
            },
          }
        );
        // Small delay to avoid rate limits
        await new Promise(resolve => setTimeout(resolve, 100));
      } catch (error) {
        console.error(`Failed to add reaction ${REACTION_EMOJIS[i]}:`, error);
      }
    }

    // Store role-emoji mappings in memory for reaction handler with timezone metadata
    if (!client.roleReactions) client.roleReactions = new Map();
    const roleMapping = Object.fromEntries(sortedRoles.map((role, i) => [REACTION_EMOJIS[i], role.id]));
    roleMapping.isTimezone = true;  // Mark this as a timezone role mapping
    client.roleReactions.set(messageId, roleMapping);

  } catch (error) {
    console.error('Error in player_set_timezone:', error);
    return res.send({
      type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        content: 'Error creating reaction message',
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
  }
  return;
} else if (name === 'player_set_age') {  // Changed from set_age
  try {
    const guildId = req.body.guild_id;
    const userId = req.body.member.user.id;
    const userName = req.body.member.nick || req.body.member.user.username;
    const age = data.options.find(opt => opt.name === 'age').value;

    // Load player data
    const playerData = await loadPlayerData();
    
    // Ensure guild and player data structures exist
    if (!playerData[guildId]) {
      playerData[guildId] = { players: {} };
    }
    if (!playerData[guildId].players) {
      playerData[guildId].players = {};
    }
    if (!playerData[guildId].players[userId]) {
      playerData[guildId].players[userId] = {};
    }

    // Update age
    playerData[guildId].players[userId].age = age;
    
    // Save data
    await savePlayerData(playerData);

    return res.send({
      type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        content: `${userName} has set their age to ${age}` // Public message visible to all
      }
    });

  } catch (error) {
    console.error('Error in player_set_age command:', error);
    return res.send({
      type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        content: 'Error setting age',
        flags: InteractionResponseFlags.EPHEMERAL // Only error messages are ephemeral
      }
    });
  }

// REMOVED: pronouns_remove command - functionality moved to /menu ‚Üí Production Menu ‚Üí Pronouns & Timezones
} else if (false && name === 'pronouns_remove') {
      try {
        console.log('Processing pronouns_remove command');
        await res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
        });

        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        
        // Process all possible role options (up to 12)
        const roleOptions = [];
        for (let i = 1; i <= 12; i++) {
          const roleOption = data.options.find(opt => opt.name === `role${i}`);
          if (roleOption) {
            roleOptions.push(roleOption.value);
          }
        }

        console.log('Roles to remove:', roleOptions);

        // Load current pronouns
        const currentPronouns = await getGuildPronouns(guildId);
        const removed = [];
        const notFound = [];

        // Process each role
        for (const roleId of roleOptions) {
          if (currentPronouns.includes(roleId)) {
            removed.push(`<@&${roleId}> (${roleId})`);
          } else {
            notFound.push(`<@&${roleId}> (${roleId})`);
          }
        }

        // Update pronouns list by removing the roles
        const updatedPronouns = currentPronouns.filter(id => !roleOptions.includes(id));
        await updateGuildPronouns(guildId, updatedPronouns);

        // Prepare response message
        const removedMsg = removed.length > 0 ? `Successfully removed: ${removed.join(', ')}` : '';
        const notFoundMsg = notFound.length > 0 ? `Not found in pronoun list: ${notFound.join(', ')}` : '';
        const message = [removedMsg, notFoundMsg].filter(msg => msg).join('\n');

        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: message || 'No changes made to pronoun roles.',
            flags: InteractionResponseFlags.EPHEMERAL
          },
        });
      } catch (error) {
        console.error('Error in pronouns_remove:', error);
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: 'Error removing pronoun roles.',
            flags: InteractionResponseFlags.EPHEMERAL
          },
        });
      }
      return;
// ...existing code...
// REMOVED: setup_castbot command - functionality moved to /menu ‚Üí Production Menu ‚Üí Initial Setup
} else if (false && name === 'setup_castbot') {  // Changed from role_generator
  try {
    console.log('üîç DEBUG: Processing setup_castbot slash command');
    await res.send({
      type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
    });

    const guildId = req.body.guild_id;
    const guild = await client.guilds.fetch(guildId);
    
    // Execute comprehensive setup using roleManager
    console.log('üîç DEBUG: Calling executeSetup from roleManager (slash command)');
    const setupResults = await executeSetup(guildId, guild);
    
    // Generate detailed response message with new format
    const responseMessage = generateSetupResponse(setupResults);
    
    // Send response
    const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
    await DiscordRequest(endpoint, {
      method: 'PATCH',
      body: {
        content: responseMessage,
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
    
    console.log('‚úÖ DEBUG: Slash command setup completed successfully');

  } catch (error) {
    console.error('‚ùå ERROR: setup_castbot slash command failed:', error);
    const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
    await DiscordRequest(endpoint, {
      method: 'PATCH',
      body: {
        content: '‚ùå Error during role setup. Please check bot permissions and try again.',
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
  }
  return;
// REMOVED: apply_button command - functionality moved to /menu ‚Üí Season Applications
} else if (false && name === 'apply_button') {
  try {
    console.log('Processing apply_button command');
    
    const guildId = req.body.guild_id;
    const guild = await client.guilds.fetch(guildId);
    
    // Create and show the application button configuration modal
    const modal = createApplicationButtonModal();
    
    return res.send({
      type: InteractionResponseType.MODAL,
      data: modal.toJSON()
    });

  } catch (error) {
    console.error('Error in apply_button command:', error);
    return res.send({
      type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
      data: {
        content: 'Error creating application button configuration.',
        flags: InteractionResponseFlags.EPHEMERAL
      }
    });
  }

// ...existing code...
}

  } // end if APPLICATION_COMMAND

  // Helper function for production menu message replacement logic
  async function shouldUpdateProductionMenuMessage(channelId) {
    try {
      const channel = await client.channels.fetch(channelId);
      const lastMessages = await channel.messages.fetch({ limit: 1 });
      const lastMessage = lastMessages.first();
      
      if (lastMessage && 
          lastMessage.author.id === client.user.id && 
          lastMessage.components && 
          lastMessage.components.length > 0) {
        
        // Check if this message contains production menu buttons
        const hasProductionMenuButton = lastMessage.components.some(row =>
          row.components && row.components.some(component =>
            component.customId && (
              component.customId === 'season_management_menu' ||
              component.customId === 'prod_manage_pronouns_timezones' ||
              component.customId === 'reeces_stuff' ||
              component.customId === 'castbot_tools' ||
              component.customId === 'prod_setup_tycoons' ||
              component.customId === 'admin_manage_player'
            )
          )
        );
        
        if (hasProductionMenuButton) {
          console.log('üîç DEBUG: Last message is CastBot Production Menu, will update message');
          return true;
        } else {
          console.log('üîç DEBUG: Last message is CastBot but not Production Menu, will create new message');
          return false;
        }
      } else {
        console.log('üîç DEBUG: Last message is not from CastBot, will create new message');
        return false;
      }
    } catch (error) {
      console.log('üîç DEBUG: Could not check last message, defaulting to new message:', error.message);
      return false;
    }
  }

  // Helper function to create back button for production submenus
  // Now uses centralized Back Button Factory for consistency
  function createBackToMainMenuButton() {
    return new ActionRowBuilder()
      .addComponents(createBackButton('prod_menu_back'));
  }

  // Helper function to send production submenu response with consistent UX
  async function sendProductionSubmenuResponse(res, channelId, components, shouldUpdateMessage = null) {
    // If shouldUpdateMessage not provided, check automatically
    if (shouldUpdateMessage === null) {
      shouldUpdateMessage = await shouldUpdateProductionMenuMessage(channelId);
    }
    
    const responseType = shouldUpdateMessage 
      ? InteractionResponseType.UPDATE_MESSAGE 
      : InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE;

    console.log(`üîç DEBUG: Using response type: ${shouldUpdateMessage ? 'UPDATE_MESSAGE' : 'CHANNEL_MESSAGE_WITH_SOURCE'}`);
    
    // Prepare response data
    const responseData = {
      flags: (1 << 15), // IS_COMPONENTS_V2 flag
      components: components
    };
    
    // Add ephemeral flag for new messages (user-only visibility)
    if (!shouldUpdateMessage) {
      responseData.flags |= InteractionResponseFlags.EPHEMERAL;
      console.log('üîç DEBUG: Adding ephemeral flag - only user can see this message');
    }
    
    return res.send({
      type: responseType,
      data: responseData
    });
  }

  /**
   * Handle button interactions (MESSAGE_COMPONENT) 
   */
  if (type === InteractionType.MESSAGE_COMPONENT) {
    let { custom_id } = data;
    console.log('Processing MESSAGE_COMPONENT with custom_id:', custom_id);
    console.log('Component type:', data.component_type, 'Values:', data.values);
    
    // Check if button uses new factory pattern or old pattern
    // Check exact match first, then check dynamic patterns
    let isFactoryButton = BUTTON_REGISTRY[custom_id];

    if (!isFactoryButton) {
      // Auto-discover wildcard patterns from BUTTON_REGISTRY
      // No manual list needed ‚Äî any 'foo_bar_*' registry entry automatically matches 'foo_bar_12345'
      for (const registryKey of Object.keys(BUTTON_REGISTRY)) {
        if (registryKey.endsWith('_*')) {
          const basePattern = registryKey.slice(0, -2); // Remove trailing '_*'
          if (custom_id.startsWith(basePattern + '_')) {
            isFactoryButton = BUTTON_REGISTRY[registryKey];
            break;
          }
        }
      }
    }
    
    let buttonType;
    if (isFactoryButton) {
      buttonType = isFactoryButton.requiresModal ? 'üìù MODAL' : '‚ú® FACTORY';
    } else {
      buttonType = 'ü™® LEGACY';
    }
    console.log(`üîç BUTTON DEBUG: Checking handlers for ${custom_id} [${buttonType}]`);

    // Analytics logging for button interactions
    const user = req.body.member?.user || req.body.user;
    const guild = req.body.guild;
    const member = req.body.member;
    const components = req.body.message?.components;
    const channelId = req.body.channel_id;
    
    
    if (user && guild) {
      // Get display name (nickname or global_name)
      const displayName = member?.nick || user.global_name || user.username;
      
      // Get channel name from Discord.js client (more reliable than REST API)
      let channelName = null;
      if (channelId) {
        try {
          // First try Discord.js client cache
          const channel = client?.channels?.cache?.get(channelId);
          if (channel?.name) {
            channelName = channel.name;
            console.log(`üìç DEBUG: Channel name from cache: #${channelName} (${channelId})`);
          } else {
            // Fallback to fetching via client
            if (client) {
              const fetchedChannel = await client.channels.fetch(channelId);
              if (fetchedChannel?.name) {
                channelName = fetchedChannel.name;
                console.log(`üìç DEBUG: Channel name from fetch: #${channelName} (${channelId})`);
              }
            }
          }
          
          // Last resort: Discord REST API
          if (!channelName) {
            const channelResponse = await DiscordRequest(`channels/${channelId}`, { method: 'GET' });
            if (channelResponse.ok) {
              const channelData = await channelResponse.json();
              channelName = channelData.name;
              console.log(`üìç DEBUG: Channel name from REST API: #${channelName} (${channelId})`);
            } else {
              console.log(`‚ö†Ô∏è DEBUG: REST API failed for channel ${channelId}, status:`, channelResponse.status);
            }
          }
        } catch (error) {
          console.log('Could not fetch channel name for analytics:', error.message);
        }
      }
      
      await logInteraction(
        user.id,
        req.body.guild_id,
        'BUTTON_CLICK',
        custom_id,
        user.username,
        guild.name || 'Unknown Server',
        components,
        channelName,
        displayName
      );
    }
    
    // ==================== RESTART TESTING TRACKER HANDLERS ====================
    if (custom_id === 'restart_test_not_tested') {
      return ButtonHandlerFactory.create({
        id: 'restart_test_not_tested',
        updateMessage: true,
        handler: async (context, req) => {
          console.log(`üîç START: restart_test_not_tested - user ${context.userId}`);
          
          const originalComponents = req.body.message?.components;
          
          // Handle Components V2 structure (Container with nested components)
          const updatedComponents = originalComponents.map(component => {
            if (component.type === 17) { // Container
              // Update nested components within the container
              const updatedNestedComponents = component.components.map(nestedComponent => {
                if (nestedComponent.type === 1) { // Action Row with buttons
                  const updatedButtons = nestedComponent.components.map(button => {
                    if (button.custom_id === 'restart_test_not_tested') {
                      return { 
                        ...button, 
                        disabled: false, // Activate Not Tested
                        style: 3 // Success (green)
                      };
                    } else if (button.custom_id === 'restart_test_tested') {
                      return { 
                        ...button, 
                        disabled: true, // Deactivate Tested
                        style: 2 // Secondary (grey)
                      };
                    } else {
                      return button;
                    }
                  });
                  return { ...nestedComponent, components: updatedButtons };
                }
                return nestedComponent;
              });
              return { 
                ...component, 
                accent_color: 0xe74c3c, // Red when not tested
                components: updatedNestedComponents 
              };
            } else if (component.type === 1) { // Direct Action Row (fallback for non-V2)
              const updatedButtons = component.components.map(button => {
                if (button.custom_id === 'restart_test_not_tested') {
                  return { 
                    ...button, 
                    disabled: false, // Activate Not Tested
                    style: 3 // Success (green)
                  };
                } else if (button.custom_id === 'restart_test_tested') {
                  return { 
                    ...button, 
                    disabled: true, // Deactivate Tested
                    style: 2 // Secondary (grey)
                  };
                } else {
                  return button;
                }
              });
              return { ...component, components: updatedButtons };
            }
            return component;
          });
          
          console.log(`‚úÖ SUCCESS: restart_test_not_tested - toggled to active`);
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2 - factory will strip for UPDATE_MESSAGE
            components: updatedComponents
          };
        }
      })(req, res, client);
    
    } else if (custom_id === 'restart_test_tested') {
      return ButtonHandlerFactory.create({
        id: 'restart_test_tested',
        updateMessage: true,
        handler: async (context, req) => {
          console.log(`üîç START: restart_test_tested - user ${context.userId}`);
          
          const originalComponents = req.body.message?.components;
          
          // Handle Components V2 structure (Container with nested components)
          const updatedComponents = originalComponents.map(component => {
            if (component.type === 17) { // Container
              // Update nested components within the container
              const updatedNestedComponents = component.components.map(nestedComponent => {
                if (nestedComponent.type === 1) { // Action Row with buttons
                  const updatedButtons = nestedComponent.components.map(button => {
                    if (button.custom_id === 'restart_test_tested') {
                      return { 
                        ...button, 
                        disabled: false, // Activate Tested
                        style: 3 // Success (green)
                      };
                    } else if (button.custom_id === 'restart_test_not_tested') {
                      return { 
                        ...button, 
                        disabled: true, // Deactivate Not Tested
                        style: 2 // Secondary (grey)
                      };
                    } else {
                      return button;
                    }
                  });
                  return { ...nestedComponent, components: updatedButtons };
                }
                return nestedComponent;
              });
              return { 
                ...component, 
                accent_color: 0x2ecc71, // Green when tested
                components: updatedNestedComponents 
              };
            } else if (component.type === 1) { // Direct Action Row (fallback for non-V2)
              const updatedButtons = component.components.map(button => {
                if (button.custom_id === 'restart_test_tested') {
                  return { 
                    ...button, 
                    disabled: false, // Activate Tested
                    style: 3 // Success (green)
                  };
                } else if (button.custom_id === 'restart_test_not_tested') {
                  return { 
                    ...button, 
                    disabled: true, // Deactivate Not Tested
                    style: 2 // Secondary (grey)
                  };
                } else {
                  return button;
                }
              });
              return { ...component, components: updatedButtons };
            }
            return component;
          });
          
          console.log(`‚úÖ SUCCESS: restart_test_tested - toggled to active`);
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2 - factory will strip for UPDATE_MESSAGE
            components: updatedComponents
          };
        }
      })(req, res, client);
    }
    
    // Handle store browse buttons (format: safari_store_browse_guildId_storeId)
    // Uses ephemeral (not updateMessage) because this button lives on BOTH:
    //   - Player menu (ephemeral) and posted channel messages (public)
    // updateMessage on a public message without IS_COMPONENTS_V2 flag = "interaction failed"
    if (custom_id.startsWith('safari_store_browse_')) {
      return ButtonHandlerFactory.create({
        id: 'safari_store_browse',
        handler: async (context) => {
          const parts = context.customId.split('_');
          const storeId = parts.slice(4).join('_'); // Handles underscores in storeId
          const { createStoreBrowseDisplay } = await import('./safariManager.js');
          const result = await createStoreBrowseDisplay(context.guildId, storeId, context.userId);
          result.flags = (1 << 15) | InteractionResponseFlags.EPHEMERAL;
          return result;
        }
      })(req, res, client);
    }

    // Handle store page navigation (format: safari_store_page_{storeId}_{page})
    if (custom_id.startsWith('safari_store_page_')) {
      return ButtonHandlerFactory.create({
        id: 'safari_store_page',
        updateMessage: true,
        handler: async (context) => {
          const withoutPrefix = context.customId.replace('safari_store_page_', '');
          const segments = withoutPrefix.split('_');
          const page = parseInt(segments.pop()); // Last segment = page number
          const storeId = segments.join('_'); // Rest = storeId (may have underscores)
          const { createStoreBrowseDisplay } = await import('./safariManager.js');
          return await createStoreBrowseDisplay(context.guildId, storeId, context.userId, page);
        }
      })(req, res, client);
    }

    // Handle store purchase buttons (format: safari_store_buy_guildId_storeId_itemId)
    if (custom_id.startsWith('safari_store_buy_')) {
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        
        // Parse storeId and itemId from custom_id: safari_store_buy_guildId_storeId_itemId
        const parts = custom_id.split('_');
        if (parts.length < 6) {
          throw new Error('Invalid store buy custom_id format');
        }
        
        // Find the delimiter between storeId and itemId by checking which combination exists
        const { loadSafariContent, saveSafariContent, addItemToInventory } = await import('./safariManager.js');
        const { getPlayer, updatePlayer, savePlayerData, loadPlayerData } = await import('./storage.js');
        const safariData = await loadSafariContent();
        
        let storeId, itemId;
        for (let i = 4; i < parts.length - 1; i++) {
          const potentialStoreId = parts.slice(4, i + 1).join('_');
          const potentialItemId = parts.slice(i + 1).join('_');
          
          if (safariData[guildId]?.stores?.[potentialStoreId] && safariData[guildId]?.items?.[potentialItemId]) {
            storeId = potentialStoreId;
            itemId = potentialItemId;
            break;
          }
        }
        
        if (!storeId || !itemId) {
          throw new Error('Could not parse storeId and itemId from custom_id');
        }
        
        console.log(`üõí DEBUG: User ${userId} attempting to buy item ${itemId} from store ${storeId}`);
        
        const store = safariData[guildId]?.stores?.[storeId];
        const item = safariData[guildId]?.items?.[itemId];
        
        if (!store || !item) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store or item not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Check if item is actually in the store
        const storeItem = store.items?.find(si => (si.itemId || si) === itemId);
        if (!storeItem) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Item is not available in this store.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const price = item.basePrice || 0;

        // Check if item is sold out (for old buttons where stock may have changed)
        const { hasStock, decrementStock } = await import('./safariManager.js');
        const hasStockAvailable = await hasStock(guildId, storeId, itemId);
        if (!hasStockAvailable) {
          // Create sold out response using Components V2
          const soldOutContainer = {
            type: 17, // Container
            accent_color: 0xff0000, // Red accent for error
            components: [
              {
                type: 10, // Text Display
                content: `# ‚ùå Item Sold Out\n\n**${item.emoji || 'üì¶'} ${item.name}** is currently out of stock.\n\nPlease check back later or browse other items in the store.`
              }
            ]
          };
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
              components: [soldOutContainer]
            }
          });
        }
        
        // Get player data and check currency
        const playerData = await loadPlayerData();
        // Access player data directly from the loaded structure
        const player = playerData[guildId]?.players?.[userId];
        const currentCurrency = player?.safari?.currency || 0;
        
        if (currentCurrency < price) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚ùå **Insufficient funds!**\n\nYou need ü™ô ${price} coins but only have ü™ô ${currentCurrency} coins.\n\nYou need ü™ô ${price - currentCurrency} more coins.`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Process purchase: deduct currency and add item to inventory
        const newCurrency = currentCurrency - price;
        
        // Initialize safari data if needed
        if (!player.safari) {
          player.safari = { currency: 0, inventory: {}, history: [], buttonUses: {}, storeHistory: [] };
        }
        if (!player.safari.inventory) {
          player.safari.inventory = {};
        }
        if (!player.safari.storeHistory) {
          player.safari.storeHistory = [];
        }
        
        // Update currency
        player.safari.currency = newCurrency;
        
        // Add item to inventory using proper function to avoid corruption (pass existing playerData to prevent race condition)
        // Attach channel metadata temporarily so the pickup log shows the channel where the purchase happened
        const channelObj = client?.channels?.cache?.get(channelId);
        playerData.channelName = channelObj?.name || null;
        playerData.channelId = channelId || null;
        playerData.username = req.body.member?.user?.username || req.body.user?.username || 'Unknown';
        playerData.displayName = req.body.member?.nick || req.body.member?.user?.global_name || req.body.member?.user?.username || 'Unknown';
        const finalQuantity = await addItemToInventory(guildId, userId, itemId, 1, playerData);
        // Clean up temp metadata so these keys are never saved to disk
        delete playerData.channelName;
        delete playerData.channelId;
        delete playerData.username;
        delete playerData.displayName;
        
        // Record purchase in store history
        player.safari.storeHistory.push({
          itemId: itemId,
          storeId: storeId,
          price: price,
          timestamp: Date.now()
        });
        
        // Update store sales count
        if (!store.metadata) {
          store.metadata = { totalSales: 0 };
        }
        store.metadata.totalSales = (store.metadata.totalSales || 0) + 1;
        
        // Update item sales count
        if (!item.metadata) {
          item.metadata = { totalSold: 0 };
        }
        item.metadata.totalSold = (item.metadata.totalSold || 0) + 1;

        // Decrement stock after successful purchase
        const stockUpdated = await decrementStock(guildId, storeId, itemId, 1);
        if (!stockUpdated) {
          // Rollback currency if stock update failed
          player.safari.currency = currentCurrency; // Restore original currency
          console.error(`‚ùå Stock update failed for ${itemId} in store ${storeId} - purchase cancelled and refunded`);
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Failed to update stock. Purchase cancelled and refunded.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Save all changes
        await savePlayerData(playerData);
        await saveSafariContent(safariData);
        
        console.log(`‚úÖ DEBUG: Purchase successful - ${userId} bought ${itemId} for ${price} coins`);
        
        // Get custom terms for inventory name
        const { getCustomTerms } = await import('./safariManager.js');
        const customTerms = await getCustomTerms(guildId);
        
        // Build Components V2 purchase confirmation
        const { validateComponentLimit } = await import('./utils.js');

        const purchaseContainer = {
          type: 17, // Container
          accent_color: 0x27ae60, // Green for success
          components: [
            {
              type: 10, // Text Display
              content: `## Purchase Successful`
            },
            { type: 14 }, // Separator
            {
              type: 10, // Text Display
              content: `${item.emoji || 'üì¶'} **${item.name}** x1 purchased for **${price}** coins\n\n**Balance:** ${newCurrency} coins\n**${item.name} owned:** ${finalQuantity}`
            },
            { type: 14 }, // Separator
            {
              type: 1, // Action Row
              components: [
                {
                  type: 2, // Button
                  custom_id: 'safari_player_inventory',
                  label: customTerms.inventoryName,
                  style: 1, // Primary
                  emoji: { name: customTerms.inventoryEmoji || 'üß∞' }
                }
              ]
            }
          ]
        };

        validateComponentLimit([purchaseContainer], "Store Purchase");

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
            components: [purchaseContainer]
          }
        });
        
      } catch (error) {
        console.error('Error in safari_store_buy handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error processing purchase. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    }
    
    // === MAP MOVEMENT HANDLERS (Button Factory) - MUST COME FIRST ===
    if (custom_id.startsWith('safari_move_')) {
      const targetCoordinate = custom_id.replace('safari_move_', '');
      return ButtonHandlerFactory.create({
        id: `safari_move_${targetCoordinate}`,
        deferred: true, // Movement takes time with permissions
        ephemeral: true,
        handler: async (context) => {
          console.log(`üó∫Ô∏è START: safari_move_${targetCoordinate} - user ${context.userId}`);
          
          try {
            // Import movement functions
            const { movePlayer, getMovementDisplay, getPlayerLocation, createMovementNotification } = await import('./mapMovement.js');
            const { loadSafariContent } = await import('./safariManager.js');
            
            // Validate that user is in the correct channel for their current position
            const mapState = await getPlayerLocation(context.guildId, context.userId);
            if (mapState) {
              const safariData = await loadSafariContent();
              const activeMapId = safariData[context.guildId]?.maps?.active;
              if (activeMapId) {
                const currentLocationChannelId = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[mapState.currentCoordinate]?.channelId;
                
                // If user is trying to move from a channel they're not supposed to be in
                if (currentLocationChannelId && currentLocationChannelId !== context.channelId) {
                  return {
                    content: `‚ùå You are no longer in this location. Your current position is **${mapState.currentCoordinate}**. Please check that channel for movement options.`,
                    ephemeral: true
                  };
                }
              }
            }
            
            // Execute movement
            const result = await movePlayer(context.guildId, context.userId, targetCoordinate, context.client);
            
            if (result.success) {
              // Post movement interface to new channel (if different from current)
              const safariData = await loadSafariContent();
              const activeMapId = safariData[context.guildId]?.maps?.active;
              const targetChannelId = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[targetCoordinate]?.channelId;
              const sourceChannelId = context.channelId;
              
              if (targetChannelId && targetChannelId !== sourceChannelId) {
                // Post arrival message with Navigate button
                const arrivalMessage = {
                  flags: (1 << 15), // IS_COMPONENTS_V2
                  components: [{
                    type: 17, // Container
                    accent_color: 0x2ecc71, // Green for movement
                    components: [
                      {
                        type: 10, // Text Display
                        content: `<@${context.userId}> has arrived at **${targetCoordinate}**`
                      },
                      {
                        type: 1, // Action Row
                        components: [{
                          type: 2, // Button
                          custom_id: `safari_navigate_${context.userId}_${targetCoordinate}`,
                          label: 'Navigate',
                          style: 1, // Primary
                          emoji: { name: 'üó∫Ô∏è' }
                        }]
                      }
                    ]
                  }]
                };
                
                console.log(`üîç DEBUG: Posting arrival message to new channel ${targetChannelId}`);
                await DiscordRequest(`channels/${targetChannelId}/messages`, {
                  method: 'POST',
                  body: arrivalMessage
                });
              }
              
              // Try to edit the original navigation message to remove buttons
              if (global.navigationInteractions) {
                const navData = global.navigationInteractions.get(`${context.userId}_${result.oldCoordinate}`);
                if (navData) {
                  try {
                    console.log(`üîç Attempting to edit navigation message - appId: ${navData.appId}, token exists: ${!!navData.token}`);
                    
                    // Import DiscordRequest if not already imported
                    const { DiscordRequest } = await import('./utils.js');
                    
                    // Use the stored app ID and token to edit the message
                    const editResponse = await DiscordRequest(`webhooks/${navData.appId}/${navData.token}/messages/@original`, {
                      method: 'PATCH',
                      body: {
                        components: createMovementNotification(context.guildId, context.userId, result.oldCoordinate, result.newCoordinate, targetChannelId).components
                      }
                    });
                    
                    console.log('‚úÖ Successfully updated original navigation message');
                    
                    // Clean up the stored interaction
                    global.navigationInteractions.delete(`${context.userId}_${result.oldCoordinate}`);
                  } catch (error) {
                    console.error('‚ùå Failed to update navigation message:', error.message);
                    if (error.response) {
                      console.error('Discord API response:', await error.response.text());
                    }
                  }
                }
              }
              
              console.log(`‚úÖ SUCCESS: safari_move_${targetCoordinate} - player moved successfully`);
              
              // Delete the deferred "thinking" message
              try {
                const { DiscordRequest } = await import('./utils.js');
                await DiscordRequest(`webhooks/${process.env.APP_ID}/${context.token}/messages/@original`, {
                  method: 'DELETE'
                });
                console.log('‚úÖ Deleted deferred thinking message');
              } catch (error) {
                console.error('Failed to delete deferred message:', error.message);
              }
              
              // Return null since we've handled everything
              return null;
            } else {
              console.log(`‚ùå FAILED: safari_move_${targetCoordinate} - ${result.message}`);
              return {
                content: result.message || '‚ùå Movement failed.',
                ephemeral: true
              };
            }
          } catch (error) {
            console.error(`‚ùå ERROR: safari_move_${targetCoordinate} - ${error.message}`);
            return {
              content: '‚ùå An error occurred while trying to move. Please try again or contact an admin.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    }
    
    // === SHOW MOVEMENT OPTIONS HANDLER (for admin-moved players) ===
    if (custom_id.startsWith('safari_show_movement_')) {
      const parts = custom_id.split('_');
      const targetUserId = parts[3];
      const coordinate = parts[4];
      
      return ButtonHandlerFactory.create({
        id: custom_id,
        ephemeral: true,
        handler: async (context) => {
          // Verify this button is for the correct user
          if (context.userId !== targetUserId) {
            return {
              content: '‚ùå This movement panel is for another player.',
              ephemeral: true
            };
          }
          
          // Import movement display function
          const { getMovementDisplay } = await import('./mapMovement.js');
          
          // Get and return movement display as ephemeral response
          const movementDisplay = await getMovementDisplay(context.guildId, context.userId, coordinate);
          
          return {
            ...movementDisplay,
            ephemeral: true
          };
        }
      })(req, res, client);
    }
    
    // === SAFARI NAVIGATE REFRESH HANDLER ===
    // IMPORTANT: Must come before general safari_navigate_ handler
    if (custom_id.startsWith('safari_navigate_refresh_')) {
      // Format: safari_navigate_refresh_userId_coordinate
      const afterPrefix = custom_id.replace('safari_navigate_refresh_', '');
      const lastUnderscoreIndex = afterPrefix.lastIndexOf('_');
      const targetUserId = afterPrefix.substring(0, lastUnderscoreIndex);
      const coordinate = afterPrefix.substring(lastUnderscoreIndex + 1);
      
      return ButtonHandlerFactory.create({
        id: custom_id,
        ephemeral: true,
        updateMessage: true, // Update existing message instead of creating new one
        handler: async (context) => {
          console.log(`üß≠ START: safari_navigate_refresh - user ${context.userId}, coordinate ${coordinate}`);
          
          // Verify this button is for the correct user
          if (context.userId !== targetUserId) {
            return {
              content: '‚ùå This refresh button is for another player.',
              ephemeral: true
            };
          }
          
          // Import movement display function
          const { getMovementDisplay, getPlayerLocation } = await import('./mapMovement.js');
          
          // Verify player is at this location
          const mapState = await getPlayerLocation(context.guildId, context.userId);
          if (!mapState || mapState.currentCoordinate !== coordinate) {
            return {
              content: `‚ùå You are no longer at ${coordinate}. Your current location is ${mapState?.currentCoordinate || 'unknown'}.`,
              ephemeral: true
            };
          }
          
          // Get updated movement display (with isDeferred=true since we're updating)
          const movementDisplay = await getMovementDisplay(context.guildId, context.userId, coordinate, true);

          console.log(`‚úÖ SUCCESS: safari_navigate_refresh - refreshed display`);
          return {
            ...movementDisplay,
            ephemeral: true
          };
        }
      })(req, res, client);
    }
    
    // === NAVIGATE HANDLER (shows movement and deletes arrival message) ===
    if (custom_id.startsWith('safari_navigate_')) {
      const parts = custom_id.split('_');
      const targetUserId = parts[2];
      const coordinate = parts[3];
      
      return ButtonHandlerFactory.create({
        id: custom_id,
        ephemeral: true,
        deferred: true, // CHANGED: Now deferred due to inventory checks
        handler: async (context) => {
          console.log(`üó∫Ô∏è START: safari_navigate - user ${context.userId}, coordinate ${coordinate}`);

          // Verify this button is for the correct user
          if (context.userId !== targetUserId) {
            return {
              content: '‚ùå This navigation panel is for another player.',
              ephemeral: true
            };
          }

          // Check if coordinate is 'none' (player not initialized)
          if (coordinate === 'none') {
            return {
              content: '‚ùå You are not initialized on the map. Use the "Start Exploring" button in Map Explorer to begin!',
              ephemeral: true
            };
          }

          // Import movement display function
          const { getMovementDisplay, getPlayerLocation } = await import('./mapMovement.js');

          // Verify player is at this location
          const mapState = await getPlayerLocation(context.guildId, context.userId);
          if (!mapState || mapState.currentCoordinate !== coordinate) {
            return {
              content: `‚ùå You are no longer at ${coordinate}. Your current location is ${mapState?.currentCoordinate || 'unknown'}.`,
              ephemeral: true
            };
          }

          // Delete the arrival message
          try {
            await DiscordRequest(`channels/${context.channelId}/messages/${context.messageId}`, {
              method: 'DELETE'
            });
            console.log(`üóëÔ∏è Deleted arrival message ${context.messageId}`);
          } catch (error) {
            console.error('Error deleting arrival message:', error);
          }

          // Get movement display with expensive inventory checks
          const movementDisplay = await getMovementDisplay(context.guildId, context.userId, coordinate, true);
          
          // Store the interaction token for later editing
          // We'll use a simple in-memory cache for this demo
          if (!global.navigationInteractions) {
            global.navigationInteractions = new Map();
          }
          
          // Ensure we have the correct app ID
          const appId = context.applicationId || req.body.application_id || process.env.APP_ID;
          console.log(`üîç Storing navigation interaction - userId: ${context.userId}, coordinate: ${coordinate}, appId: ${appId}`);
          
          global.navigationInteractions.set(`${context.userId}_${coordinate}`, {
            token: context.token,
            appId: appId
          });
          
          console.log(`‚úÖ SUCCESS: safari_navigate - displayed movement options`);
          return {
            ...movementDisplay,
            ephemeral: true
          };
        }
      })(req, res, client);
    }
    
    // === SAFARI WHISPER HANDLER ===
    if (custom_id.startsWith('safari_whisper_')) {
      const coordinate = custom_id.replace('safari_whisper_', '');
      
      return ButtonHandlerFactory.create({
        id: 'safari_whisper',
        ephemeral: true,
        handler: async (context) => {
          console.log(`üí¨ START: safari_whisper - user ${context.userId}, coordinate ${coordinate}`);
          
          const { showWhisperPlayerSelect } = await import('./whisperManager.js');
          const result = await showWhisperPlayerSelect(context, coordinate, client);
          
          console.log(`‚úÖ SUCCESS: safari_whisper - completed`);
          return result;
        }
      })(req, res, client);
    }
    
    // === WHISPER REPLY HANDLER ===
    if (custom_id.startsWith('whisper_reply_')) {
      // Format: whisper_reply_originalSenderId_coordinate
      const parts = custom_id.split('_');
      const originalSenderId = parts[2];
      const coordinate = parts.slice(3).join('_'); // Handle coordinates with underscores
      
      return ButtonHandlerFactory.create({
        id: 'whisper_reply',
        ephemeral: true,
        handler: async (context) => {
          console.log(`üí¨ START: whisper_reply - replying user ${context.userId} to ${originalSenderId}`);
          
          const { showReplyModal } = await import('./whisperManager.js');
          const result = await showReplyModal(context, originalSenderId, coordinate, client);
          
          console.log(`‚úÖ SUCCESS: whisper_reply - completed`);
          return result;
        }
      })(req, res, client);
    }
    
    // === WHISPER READ MESSAGE HANDLER ===
    if (custom_id.startsWith('whisper_read_')) {
      // Format: whisper_read_whisperId_targetUserId
      const parts = custom_id.replace('whisper_read_', '').split('_');
      const whisperId = parts[0] + '_' + parts[1]; // Reconstruct whisperId with underscore
      const targetUserId = parts[2];
      
      return ButtonHandlerFactory.create({
        id: 'whisper_read',
        ephemeral: true,
        handler: async (context) => {
          console.log(`üí¨ START: whisper_read - user ${context.userId} reading whisper ${whisperId}`);
          
          const { handleReadWhisper } = await import('./whisperManager.js');
          const result = await handleReadWhisper(context, whisperId, targetUserId, client);
          
          console.log(`‚úÖ SUCCESS: whisper_read - completed`);
          return result;
        }
      })(req, res, client);
    }

    // Handle modal launcher buttons for modal-triggered Custom Actions (riddle mechanics)
    if (custom_id.startsWith('modal_launcher_')) {
      // Parse the custom_id: modal_launcher_{guildId}_{actionId}_{timestamp}
      const parts = custom_id.split('_');
      const guildId = parts[2];
      const actionId = parts.slice(3, -1).join('_'); // Handle action IDs with underscores

      console.log(`üé≠ Modal launcher clicked for action: ${actionId} in guild ${guildId}`);

      // Get the Custom Action to access its configuration
      const { getCustomButton } = await import('./safariManager.js');
      const customAction = await getCustomButton(guildId, actionId);

      if (!customAction) {
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            content: '‚ùå Custom action not found.',
            components: [],
            flags: (1 << 15) | (1 << 6) // Components V2 + Ephemeral
          }
        });
      }

      // Build modal using Player Command pattern
      const modal = {
        title: customAction.label || 'Enter Answer',
        custom_id: `modal_answer_${guildId}_${actionId}_${Date.now()}`,
        components: [{
          type: 1, // Action Row
          components: [{
            type: 4, // Text Input
            custom_id: 'answer_input',
            label: customAction.description || 'Your Answer:',
            style: 1, // Short
            required: true,
            min_length: 1,
            max_length: 100,
            placeholder: 'Type your answer here...'
          }]
        }]
      };

      // Return MODAL response (type 9)
      console.log(`üéØ Showing modal for ${actionId} with title: ${modal.title}`);
      return res.send({
        type: InteractionResponseType.MODAL,
        data: modal
      });
    }

    // Handle safari dynamic buttons (format: safari_guildId_buttonId_timestamp)
    if (custom_id.startsWith('safari_') && custom_id.split('_').length >= 4 &&
        !custom_id.startsWith('safari_add_action_') &&
        !custom_id.startsWith('safari_finish_button_') &&
        !custom_id.startsWith('safari_action_modal_') &&
        !custom_id.startsWith('safari_currency_') &&
        !custom_id.startsWith('safari_create_') &&
        !custom_id.startsWith('safari_post_') &&
        !custom_id.startsWith('safari_manage_') &&
        !custom_id.startsWith('safari_view_') &&
        !custom_id.startsWith('safari_inventory_') &&
        !custom_id.startsWith('safari_log_') &&
        !custom_id.startsWith('safari_configure_log') &&
        !custom_id.startsWith('safari_my_') &&
        !custom_id.startsWith('safari_store_') &&
        !custom_id.startsWith('safari_item_') &&
        !custom_id.startsWith('safari_use_item_') &&
        !custom_id.startsWith('safari_attack_') &&
        !custom_id.startsWith('safari_schedule_') &&
        !custom_id.startsWith('safari_whisper_') &&
        !custom_id.startsWith('safari_button_') &&
        !custom_id.startsWith('safari_round_') &&
        !custom_id.startsWith('safari_edit_properties_') &&
        !custom_id.startsWith('safari_test_button_') &&
        !custom_id.startsWith('safari_deinit_player_') &&
        !custom_id.startsWith('safari_deinit_confirm_') &&
        !custom_id.startsWith('safari_pause_player_') &&
        !custom_id.startsWith('safari_unpause_player_') &&
        !custom_id.startsWith('safari_delete_button_') &&
        !custom_id.startsWith('safari_confirm_delete_button_') &&
        !custom_id.startsWith('safari_confirm_delete_store_') &&
        !custom_id.startsWith('safari_action_') &&
        !custom_id.startsWith('safari_remove_action_') &&
        !custom_id.startsWith('safari_edit_action_') &&
        !custom_id.startsWith('safari_config_') &&
        !custom_id.startsWith('safari_crafting_menu_') &&
        custom_id !== 'safari_player_menu_config' &&
        !custom_id.startsWith('safari_move_') &&
        !custom_id.startsWith('safari_drop_style_') &&
        !custom_id.startsWith('safari_drop_reset_') &&
        !custom_id.startsWith('safari_drop_save_') &&
        !custom_id.startsWith('safari_drop_type_') &&
        !custom_id.startsWith('safari_give_item_select_') &&
        !custom_id.startsWith('safari_follow_up_select_') &&
        !custom_id.startsWith('safari_give_role_select_') &&
        !custom_id.startsWith('safari_remove_role_select_') &&
        !custom_id.startsWith('safari_role_select_') &&
        !custom_id.startsWith('safari_role_update_') &&
        !custom_id.startsWith('safari_followup_execute_on_') &&
        !custom_id.startsWith('safari_followup_save_') &&
        !custom_id.startsWith('safari_item_limit_') &&
        !custom_id.startsWith('safari_item_operation_') &&
        !custom_id.startsWith('safari_item_quantity_') &&
        !custom_id.startsWith('safari_item_save_') &&
        !custom_id.startsWith('safari_item_reset_') &&
        !custom_id.startsWith('safari_currency_amount_') &&
        !custom_id.startsWith('safari_currency_limit_') &&
        !custom_id.startsWith('safari_currency_save_') &&
        !custom_id.startsWith('safari_currency_reset_') &&
        !custom_id.startsWith('safari_currency_execute_on_') &&
        !custom_id.startsWith('safari_item_execute_on_') &&
        !custom_id.startsWith('safari_display_text_edit_') &&
        !custom_id.startsWith('safari_display_text_execute_on_') &&
        !custom_id.startsWith('safari_calculate_results_scope_') &&
        !custom_id.startsWith('safari_calculate_results_display_') &&
        !custom_id.startsWith('safari_calculate_results_execute_on_') &&
        !custom_id.startsWith('safari_calculate_attack_scope_') &&
        !custom_id.startsWith('safari_calculate_attack_display_') &&
        !custom_id.startsWith('safari_calculate_attack_execute_on_') &&
        !custom_id.startsWith('safari_modify_attr_select_') &&
        !custom_id.startsWith('safari_modify_attr_operation_') &&
        !custom_id.startsWith('safari_modify_attr_display_') &&
        !custom_id.startsWith('safari_modify_attr_execute_on_') &&
        !custom_id.startsWith('safari_modify_attr_amount_') &&
        !custom_id.startsWith('safari_modify_attr_limit_') &&
        !custom_id.startsWith('safari_modify_attr_reset_') &&
        !custom_id.startsWith('safari_all_server_items_') &&
        !custom_id.startsWith('safari_progress_') &&
        !custom_id.startsWith('safari_inv_page_') &&  // Exclude inventory pagination buttons
        !custom_id.startsWith('safari_init_player_') &&  // Exclude player initialization button
        !custom_id.startsWith('safari_result_ordering_') &&  // Exclude result ordering buttons
        custom_id !== 'safari_map_init_player' &&
        custom_id !== 'safari_post_select_button' &&
        custom_id !== 'safari_confirm_reset_game' && 
        custom_id !== 'safari_paused_players' &&
        custom_id !== 'safari_pause_players_select' &&
        custom_id !== 'safari_show_advantages_public' &&
        !custom_id.startsWith('safari_start') &&
        !custom_id.startsWith('safari_remove_') &&
        !custom_id.startsWith('safari_map_admin') &&
        !custom_id.startsWith('safari_post_channel_')) {
      // Check if this Custom Action contains calculate_results actions that need deferred handling
      const parts = custom_id.split('_');
      const guildId = parts[1];

      // Button ID resolution: Try multiple approaches because custom_id format varies
      // - Player Menu Actions / Crafting Menu: safari_guildId_buttonId (NO timestamp)
      // - Location buttons with generateCustomId: safari_guildId_buttonId_timestamp
      // The buttonId itself may contain underscores AND timestamps (e.g., ifrit_1768144591278)

      // First try: full ID (everything after guildId) - for buttons without generateCustomId timestamp
      const fullButtonId = parts.slice(2).join('_');
      // Second try: drop last segment as timestamp - for buttons with generateCustomId timestamp
      const buttonIdWithoutTimestamp = parts.slice(2, -1).join('_');

      // ALWAYS use deferred response for Safari Custom Actions to prevent webhook failures
      // This gives us 15 minutes to process instead of 3 seconds
      console.log(`üöÄ DEBUG: Safari Custom Action - ALWAYS using deferred response to prevent webhook timeout`);
      console.log(`üîç DEBUG: Will try buttonId: "${fullButtonId}" first, then "${buttonIdWithoutTimestamp}" if not found`);

      // Always use deferred pattern for ALL Safari Custom Actions
      return ButtonHandlerFactory.create({
        id: custom_id,
        deferred: true, // ALWAYS defer Safari buttons to prevent webhook timeout
        handler: async (context) => {
          console.log(`üîç START (DEFERRED): ${custom_id} - user ${context.userId}`);

          // Import safari manager
          const { executeButtonActions, getCustomButton } = await import('./safariManager.js');

          // Try to resolve the correct buttonId
          let resolvedButtonId = fullButtonId;

          // Check if fullButtonId exists
          const fullButton = await getCustomButton(guildId, fullButtonId);
          if (!fullButton) {
            // Try without timestamp
            const buttonWithoutTimestamp = await getCustomButton(guildId, buttonIdWithoutTimestamp);
            if (buttonWithoutTimestamp) {
              resolvedButtonId = buttonIdWithoutTimestamp;
              console.log(`üîç DEBUG: Button found with timestamp dropped: ${resolvedButtonId}`);
            } else {
              console.log(`üîç DEBUG: Button not found with either ID approach`);
            }
          } else {
            console.log(`üîç DEBUG: Button found with full ID: ${resolvedButtonId}`);
          }

          console.log(`ü¶Å DEBUG: Safari button interaction - Guild: ${guildId}, Button: ${resolvedButtonId}, User: ${context.userId}`);

          // Create proper interaction object with token for follow-up messages
          const interactionData = {
            token: context.token,
            applicationId: context.applicationId,
            client: context.client,
            member: context.member, // Pass the full member object for role checks
            channelName: context.channelName, // Pass channel name for logging - CRITICAL for location fix
            user: context.member?.user || { id: context.userId }, // Pass user information with at minimum the userId
            channel: { name: context.channelName } // Pass channel information for logging
          };

          const result = await executeButtonActions(guildId, resolvedButtonId, context.userId, interactionData, client);

          console.log(`‚úÖ SUCCESS (DEFERRED): ${custom_id} - completed`);
          return {
            ...result,
            ephemeral: true // Make all Safari custom action responses ephemeral
          };
        }
      })(req, res, client);
    }
    
    // === SAFARI PROGRESS HANDLERS ===
    // Handle safari progress button
    if (custom_id === 'safari_progress') {
      return ButtonHandlerFactory.create({
        id: 'safari_progress',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: safari_progress - user ${context.userId}`);
          
          try {
            // Import Safari Progress module
            const { createSafariProgressUI } = await import('./safariProgress.js');
            
            // Create the UI for the first row (A)
            const progressUI = await createSafariProgressUI(context.guildId, 'A', client);
            
            console.log(`‚úÖ SUCCESS: safari_progress - displayed row A`);
            return progressUI;
          } catch (error) {
            console.error(`‚ùå ERROR: safari_progress - ${error.message}`);
            return {
              content: '‚ùå Error loading Safari Progress. Please try again.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    }
    
    // Handle safari progress navigation - previous row
    if (custom_id.startsWith('safari_progress_prev_')) {
      const currentRow = custom_id.replace('safari_progress_prev_', '');
      
      return ButtonHandlerFactory.create({
        id: 'safari_progress_prev',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_progress_prev - user ${context.userId}, current row ${currentRow}`);
          
          try {
            const { createSafariProgressUI, getAdjacentRow } = await import('./safariProgress.js');
            const prevRow = getAdjacentRow(currentRow, 'prev');
            
            const progressUI = await createSafariProgressUI(context.guildId, prevRow, client);
            
            console.log(`‚úÖ SUCCESS: safari_progress_prev - navigated to row ${prevRow}`);
            return progressUI;
          } catch (error) {
            console.error(`‚ùå ERROR: safari_progress_prev - ${error.message}`);
            return {
              content: '‚ùå Error navigating to previous row.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    }
    
    // Handle safari progress navigation - next row
    if (custom_id.startsWith('safari_progress_next_')) {
      const currentRow = custom_id.replace('safari_progress_next_', '');
      
      return ButtonHandlerFactory.create({
        id: 'safari_progress_next',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_progress_next - user ${context.userId}, current row ${currentRow}`);
          
          try {
            const { createSafariProgressUI, getAdjacentRow } = await import('./safariProgress.js');
            const nextRow = getAdjacentRow(currentRow, 'next');
            
            const progressUI = await createSafariProgressUI(context.guildId, nextRow, client);
            
            console.log(`‚úÖ SUCCESS: safari_progress_next - navigated to row ${nextRow}`);
            return progressUI;
          } catch (error) {
            console.error(`‚ùå ERROR: safari_progress_next - ${error.message}`);
            return {
              content: '‚ùå Error navigating to next row.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    }
    
    // Handle safari progress jump to row
    if (custom_id === 'safari_progress_jump') {
      return ButtonHandlerFactory.create({
        id: 'safari_progress_jump',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_progress_jump - user ${context.userId}`);
          
          try {
            const selectedRow = context.values[0];
            const { createSafariProgressUI } = await import('./safariProgress.js');
            
            const progressUI = await createSafariProgressUI(context.guildId, selectedRow, client);
            
            console.log(`‚úÖ SUCCESS: safari_progress_jump - jumped to row ${selectedRow}`);
            return progressUI;
          } catch (error) {
            console.error(`‚ùå ERROR: safari_progress_jump - ${error.message}`);
            return {
              content: '‚ùå Error jumping to selected row.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    }
    
    // Handle safari progress global items view
    if (custom_id === 'safari_progress_global_items') {
      return ButtonHandlerFactory.create({
        id: 'safari_progress_global_items',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_progress_global_items - user ${context.userId}`);
          
          try {
            const { createGlobalItemsUI } = await import('./safariProgress.js');
            // Pass isPublic=false (ephemeral), isUpdateMessage=true (updating existing message)
            const globalItemsUI = await createGlobalItemsUI(context.guildId, client, false, true);

            console.log(`‚úÖ SUCCESS: safari_progress_global_items - displayed global items`);
            return globalItemsUI;
          } catch (error) {
            console.error(`‚ùå ERROR: safari_progress_global_items - ${error.message}`);
            return {
              content: '‚ùå Error loading Global Items. Please try again.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    }
    
    // Handle safari progress back to rows
    if (custom_id === 'safari_progress_back_to_rows') {
      return ButtonHandlerFactory.create({
        id: 'safari_progress_back_to_rows',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_progress_back_to_rows - user ${context.userId}`);
          
          try {
            const { createSafariProgressUI } = await import('./safariProgress.js');
            const progressUI = await createSafariProgressUI(context.guildId, 'A', client);
            
            console.log(`‚úÖ SUCCESS: safari_progress_back_to_rows - returned to row A`);
            return progressUI;
          } catch (error) {
            console.error(`‚ùå ERROR: safari_progress_back_to_rows - ${error.message}`);
            return {
              content: '‚ùå Error returning to rows view.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    }

    // Handle safari show advantages public - creates NEW public message
    if (custom_id === 'safari_show_advantages_public') {
      return ButtonHandlerFactory.create({
        id: 'safari_show_advantages_public',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        // NO updateMessage: Creates NEW message instead of updating
        ephemeral: false, // CRITICAL: Must be false for public message
        handler: async (context) => {
          console.log(`üîç START: safari_show_advantages_public - user ${context.userId}`);
          console.log(`üì¢ Creating PUBLIC Advantages display for guild ${context.guildId}`);

          try {
            const { createGlobalItemsUI } = await import('./safariProgress.js');
            // Pass isPublic=true (public), isUpdateMessage=false (creating NEW message)
            const publicAdvantagesUI = await createGlobalItemsUI(context.guildId, client, true, false);

            console.log(`‚úÖ SUCCESS: safari_show_advantages_public - displayed public advantages`);
            return publicAdvantagesUI;
          } catch (error) {
            console.error(`‚ùå ERROR: safari_show_advantages_public - ${error.message}`);
            return {
              content: '‚ùå Error displaying public advantages.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    } else if (custom_id.startsWith('show_castlist2') || (req.body.data && req.body.data.custom_id && req.body.data.custom_id.startsWith('show_castlist2'))) {
      // Handle show_castlist2 - reuse existing logic but decode virtual IDs
      let requestedCastlist = 'unknown'; // Hoist for error handler access
      try {
        const currentCustomId = req.body.data?.custom_id?.startsWith('show_castlist2') ? req.body.data.custom_id : custom_id;

        // Extract castlist ID and display mode
        // Check if it ends with _edit specifically
        const displayMode = currentCustomId.endsWith('_edit') ? 'edit' : 'view';

        // Extract castlist ID
        if (displayMode === 'edit') {
          // Remove the _edit suffix
          const withoutEdit = currentCustomId.slice(0, -5); // Remove '_edit'
          requestedCastlist = withoutEdit.replace('show_castlist2_', '') || 'default';
        } else {
          // No edit suffix, extract everything after show_castlist2_
          requestedCastlist = currentCustomId.replace('show_castlist2_', '') || 'default';
        }

        // Decode virtual castlist ID if needed
        const { castlistVirtualAdapter } = await import('./castlistVirtualAdapter.js');
        requestedCastlist = castlistVirtualAdapter.decodeVirtualId(requestedCastlist);

        console.log('Processing show_castlist2 for:', requestedCastlist, 'in mode:', displayMode);

        // ‚úÖ CRITICAL: Send deferred response IMMEDIATELY for large guilds (prevents 3-second timeout)
        res.send({ type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE });
        console.log('[CASTLIST] Sent deferred response');

        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        const channelId = req.body.channel_id || null;
        const member = req.body.member || null;
        const guild = await client.guilds.fetch(guildId);

        // ‚úÖ NEW: Single unified call via Virtual Adapter (replaces 145 lines of inline filtering)
        const { getTribesForCastlist } = await import('./castlistDataAccess.js');
        const allTribes = await getTribesForCastlist(guildId, requestedCastlist, client);

        if (allTribes.length === 0) {
          const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
          await DiscordRequest(endpoint, {
            method: 'PATCH',
            body: {
              content: `No tribes found for castlist: ${requestedCastlist}`,
              flags: 1 << 6  // Ephemeral flag
            }
          });
          return;
        }

        // Import necessary functions
        const { loadPlayerData } = await import('./storage.js');
        const { determineDisplayScenario, createNavigationState, reorderTribes } = await import('./castlistV2.js');

        const playerData = await loadPlayerData();

        // Reorder tribes for display - apply user-first for default castlist
        // This fixes the pagination bug where initial display used different ordering than navigation
        const orderingStrategy = requestedCastlist === 'default' ? 'user-first' : 'default';
        const tribes = reorderTribes(allTribes, userId, orderingStrategy, requestedCastlist);

        // Check permissions if in channel
        if (channelId && member) {
          try {
            const memberObj = await guild.members.fetch(userId);
            const channel = await client.channels.fetch(channelId);
            const permissions = channel?.permissionsFor(memberObj);
            if (!permissions?.has('SendMessages')) {
              return res.send({
                type: 4,
                data: {
                  content: 'You do not have permission to send messages in this channel.',
                  flags: 1 << 6  // Ephemeral flag
                }
              });
            }
          } catch (error) {
            console.error('Error checking channel permissions:', error);
          }
        }

        // Calculate components for all tribes
        const scenario = determineDisplayScenario(tribes);
        const navigationState = createNavigationState(tribes, scenario, 0, 0, guild, { playerData, guildId });

        // Send castlist as a NEW message to the channel
        const memberObj = member ? await guild.members.fetch(userId) : null;

        // Build the response data using the new helper function
        // Create permission checker for ephemeral flag handling
        const permissionChecker = memberObj && channelId ?
          async (m, c) => await canSendMessagesInChannel(m, c, client) :
          null;

        // Get castlist name for display (Virtual Adapter already resolved this)
        const castlistEntity = playerData[guildId]?.castlistConfigs?.[requestedCastlist];
        const castlistName = castlistEntity?.name || requestedCastlist;

        // Pass ID for lookups, name for display
        const responseData = await buildCastlist2ResponseData(guild, tribes, requestedCastlist, navigationState, memberObj, channelId, permissionChecker, displayMode, castlistName, { playerData, guildId });

        // Post castlist via webhook follow-up (deferred response already sent)
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: responseData
        });
        console.log('[CASTLIST] Sent castlist via webhook follow-up');
        return; // Already sent via webhook
      } catch (error) {
        console.error('‚ùå [CASTLIST] Error in show_castlist2 handler:', error);
        console.error('  Castlist:', requestedCastlist);
        console.error('  Stack:', error.stack);

        // Send error via webhook follow-up
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            flags: (1 << 6), // EPHEMERAL - error only visible to clicker
            components: [{
              type: 17, // Container
              components: [{
                type: 10, // TextDisplay
                content: `# ‚ùå Error Loading Castlist\n\n**Castlist**: ${requestedCastlist || 'unknown'}\n**Error**: ${error.message}\n\nThis castlist may have data issues. Please contact an admin.`
              }]
            }]
          }
        });
        return; // Already sent via webhook
      }
    } else if (custom_id.startsWith('rank_')) {
      // Handle ranking button clicks - USING CAST RANKING MANAGER
      return ButtonHandlerFactory.create({
        id: 'rank_applicant',
        updateMessage: true, // Update existing message instead of creating new one
        handler: async (context) => {
          console.log(`üîç START: rank_applicant - user ${context.userId}, button ${context.customId}`);
          
          const { guildId, userId, client } = context;
          const guild = await client.guilds.fetch(guildId);
          const member = await guild.members.fetch(userId);
          
          // Check Cast Ranking permissions (includes special exception for server 1331657596087566398)
          if (!hasCastRankingPermissions(member, guildId)) {
            return {
              content: '‚ùå You need Manage Roles or Manage Channels permissions to rate applicants.',
              ephemeral: true
            };
          }

          // Use castRankingManager for ranking button handling
          console.log('üîß Using castRankingManager.handleRankingButton()');
          const { handleRankingButton } = await import('./castRankingManager.js');
          const result = await handleRankingButton({
            customId: context.customId,
            guildId,
            userId,
            guild,
            client
          });
          
          console.log(`‚úÖ SUCCESS: rank_applicant - ${context.customId} completed via castRankingManager`);
          return result;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('personal_ranker_')) {
      // Handle Personal Ranker button - creates ephemeral Cast Ranking interface
      return ButtonHandlerFactory.create({
        id: 'personal_ranker',
        updateMessage: false, // Always create new ephemeral message
        handler: async (context) => {
          console.log(`üîç START: personal_ranker - user ${context.userId}`);
          
          // Parse: personal_ranker_{channelId}_{appIndex}_{configId}
          const parts = context.customId.split('_');
          const channelId = parts[2];
          const appIndex = parseInt(parts[3]);
          const configId = parts.slice(4).join('_');
          
          const { guildId, userId, client } = context;
          const guild = await client.guilds.fetch(guildId);
          
          // Get applications and current app
          const { getAllApplicationsFromData, getApplicationsForSeason } = await import('./storage.js');
          const allApplications = configId ? await getApplicationsForSeason(guildId, configId) : await getAllApplicationsFromData(guildId);
          const currentApp = allApplications[appIndex];
          
          // Fetch applicant member
          let applicantMember;
          try {
            applicantMember = await guild.members.fetch(currentApp.userId);
          } catch (error) {
            applicantMember = {
              displayName: currentApp.displayName,
              user: { username: currentApp.username },
              displayAvatarURL: () => currentApp.avatarURL || `https://cdn.discordapp.com/embed/avatars/${currentApp.userId % 5}.png`,
              roles: []
            };
          }
          
          // Generate ephemeral Cast Ranking UI
          const { generateSeasonAppRankingUI } = await import('./castRankingManager.js');
          const result = await generateSeasonAppRankingUI({
            guildId, userId, configId, allApplications, currentApp, appIndex, applicantMember, guild,
            seasonName: 'Current Season',
            playerData: await import('./storage.js').then(m => m.loadPlayerData()),
            ephemeral: true
          });
          
          console.log(`‚úÖ SUCCESS: personal_ranker - ephemeral UI created`);
          return result;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('ranking_prev_') || custom_id.startsWith('ranking_next_') || custom_id.startsWith('ranking_view_all_scores')) {
      // Handle ranking navigation and view all scores - USING CAST RANKING MANAGER
      const isEphemeral = custom_id.includes('_ephemeral');
      return ButtonHandlerFactory.create({
        id: 'ranking_navigation',
        updateMessage: !isEphemeral, // Ephemeral creates new, shared updates existing
        handler: async (context) => {
          console.log(`üîç START: ranking_navigation - user ${context.userId}, button ${context.customId}`);
          
          const { guildId, userId, client } = context;
          const guild = await client.guilds.fetch(guildId);
          const member = await guild.members.fetch(userId);
          
          // Check Cast Ranking permissions (includes special exception for server 1331657596087566398)
          if (!hasCastRankingPermissions(member, guildId)) {
            return {
              content: '‚ùå You need Manage Roles or Manage Channels permissions to access Cast Ranking.',
              ephemeral: true
            };
          }
          
          // Use castRankingManager for navigation
          console.log('üîß Using castRankingManager.handleRankingNavigation()');
          const { handleRankingNavigation } = await import('./castRankingManager.js');
          const result = await handleRankingNavigation({
            customId: context.customId,
            guildId,
            userId,
            guild,
            client,
            ephemeral: isEphemeral
          });
          
          console.log(`‚úÖ SUCCESS: ranking_navigation - ${context.customId} completed via castRankingManager`);
          return result;
        }
      })(req, res, client);
    // REMOVED: 300+ lines of disabled legacy ranking code - cleaned up
    } else if (custom_id.startsWith('ranking_select_')) {
      // Handle applicant jump select menu - converted to Button Handler Factory
      return ButtonHandlerFactory.create({
        id: 'ranking_select',
        updateMessage: true, // Update existing message
        handler: async (context) => {
          console.log(`üîç START: ranking_select - user ${context.userId}, select ${context.customId}`);
          
          const { guildId, userId, client } = context;
          const guild = await client.guilds.fetch(guildId);
          const member = await guild.members.fetch(userId);
          
          // Check Cast Ranking permissions
          if (!hasCastRankingPermissions(member, guildId)) {
            return {
              content: '‚ùå You need Manage Roles or Manage Channels permissions to navigate applicants.',
              ephemeral: true
            };
          }
          
          // Use castRankingManager for select handling
          console.log('üîß Using castRankingManager.handleRankingSelect()');
          const { handleRankingSelect } = await import('./castRankingManager.js');
          const values = req.body.data.values;
          const result = await handleRankingSelect({
            customId: context.customId,
            values,
            guildId,
            userId,
            guild,
            client
          });
          
          console.log(`‚úÖ SUCCESS: ranking_select - completed`);
          return result;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('ranking_scores_back_')) {
      // Handle ranking scores summary back button - restore original Cast Ranking UI
      return ButtonHandlerFactory.create({
        id: 'ranking_scores_back',
        updateMessage: true, // Replace View All Scores with Cast Ranking UI
        handler: async (context) => {
          console.log(`üîç START: ranking_scores_back - user ${context.userId}`);
          
          // Parse context from custom_id: ranking_scores_back_{configId}_{userId}
          const backMatch = context.customId.match(/^ranking_scores_back_(.+)_(\d+)$/);
          if (!backMatch) {
            console.log(`‚ùå ERROR: ranking_scores_back - invalid custom_id format: ${context.customId}`);
            return {
              content: '‚ùå Error: Invalid back button format.',
              ephemeral: true
            };
          }
          
          const [, configId, originalUserId] = backMatch;
          console.log(`üîç DEBUG: ranking_scores_back - configId: ${configId}, originalUserId: ${originalUserId}`);
          
          // Import cast ranking functions
          const { getAllApplicationsFromData, getApplicationsForSeason } = await import('./storage.js');
          const { generateSeasonAppRankingUI } = await import('./castRankingManager.js');
          
          // Get applications using season-filtered function when configId is available
          const allApplications = (configId && configId !== 'none') 
            ? await getApplicationsForSeason(context.guildId, configId)
            : await getAllApplicationsFromData(context.guildId);
          
          if (!allApplications || allApplications.length === 0) {
            return {
              content: '‚ùå No applications found.',
              ephemeral: true
            };
          }
          
          // Default to first applicant for now (we could enhance this to remember the exact applicant later)
          const appIndex = 0;
          const currentApp = allApplications[appIndex];
          
          // Fetch the applicant as a guild member
          let applicantMember;
          try {
            const guild = await client.guilds.fetch(context.guildId);
            applicantMember = await guild.members.fetch(currentApp.userId);
          } catch (error) {
            // Fallback: create basic user object
            applicantMember = {
              displayName: currentApp.displayName,
              user: { username: currentApp.username },
              displayAvatarURL: () => currentApp.avatarURL || `https://cdn.discordapp.com/embed/avatars/${currentApp.userId % 5}.png`,
              roles: []
            };
          }
          
          // Restore the original Cast Ranking UI
          const guild = await client.guilds.fetch(context.guildId);
          const seasonName = 'Current Season'; // TODO: Get actual season name
          const result = await generateSeasonAppRankingUI({
            guildId: context.guildId,
            userId: context.userId,
            configId: configId !== 'none' ? configId : 'back',
            allApplications,
            currentApp,
            appIndex,
            applicantMember,
            guild,
            seasonName,
            playerData: await import('./storage.js').then(m => m.loadPlayerData())
          });
          
          console.log(`‚úÖ SUCCESS: ranking_scores_back - restored Cast Ranking UI`);
          return result;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('ranking_scores_refresh_')) {
      // Handle ranking scores summary refresh button
      return ButtonHandlerFactory.create({
        id: 'ranking_scores_refresh',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: ranking_scores_refresh - user ${context.userId}, button ${context.customId}`);
          
          const { guildId, userId, client } = context;
          const guild = await client.guilds.fetch(guildId);
          const member = await guild.members.fetch(userId);
          
          // Check Cast Ranking permissions
          if (!hasCastRankingPermissions(member, guildId)) {
            return {
              content: '‚ùå You need Manage Roles or Manage Channels permissions to refresh cast ranking data.',
              ephemeral: true
            };
          }
          
          // Extract configId from button: ranking_scores_refresh_{configId}
          const configId = context.customId.replace('ranking_scores_refresh_', '');
          const actualConfigId = configId === 'none' ? null : configId;
          
          console.log(`üîÑ Refreshing ranking scores for configId: ${actualConfigId || 'all'}`);
          
          // Create a synthetic ranking_view_all_scores custom_id to reuse existing logic
          const syntheticCustomId = actualConfigId ? `ranking_view_all_scores_${actualConfigId}` : 'ranking_view_all_scores';
          
          // Import and use castRankingManager.handleRankingNavigation to regenerate the UI
          const { handleRankingNavigation } = await import('./castRankingManager.js');
          const result = await handleRankingNavigation({
            customId: syntheticCustomId,
            guildId,
            userId,
            guild,
            client
          });
          
          console.log(`‚úÖ SUCCESS: ranking_scores_refresh - data refreshed`);
          return result;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('cast_player_') || custom_id.startsWith('cast_tentative_') || custom_id.startsWith('cast_reject_')) {
      // Handle casting status buttons - USING CAST RANKING MANAGER
      return ButtonHandlerFactory.create({
        id: 'casting_status',
        updateMessage: true, // This is an UPDATE_MESSAGE response
        handler: async (context) => {
          console.log(`üé¨ START: casting_status - user ${context.userId}, button ${context.customId}`);
          
          const { guildId, userId, client } = context;
          const guild = await client.guilds.fetch(guildId);
          const member = await guild.members.fetch(userId);
          
          // Check Cast Ranking permissions (includes special exception for server 1331657596087566398)
          if (!hasCastRankingPermissions(member, guildId)) {
            return {
              content: '‚ùå You need Manage Roles or Manage Channels permissions to set casting status.',
              ephemeral: true
            };
          }
          
          // Parse button ID: cast_[status]_[channelId]_[appIndex]_[configId] (new format) or cast_[status]_[channelId]_[appIndex] (legacy)
          const parts = context.customId.split('_');
          const status = parts[1]; // player, tentative, or reject
          const channelId = parts[2];
          const appIndex = parseInt(parts[3]);
          
          // Extract configId properly: cast_player_1398865589887434783_0_config_1749305698427_391415444084490240
          let configId = null;
          const configMatch = context.customId.match(/cast_\w+_\d+_\d+_(.+)$/);
          if (configMatch) {
            configId = configMatch[1]; // Everything after the appIndex
          }
          
          // Map button status to database status
          const statusMap = {
            'player': 'cast',
            'tentative': 'tentative', 
            'reject': 'reject'
          };
          const castingStatus = statusMap[status];
          
          // Load and update player data
          const playerData = await loadPlayerData();
          
          // Ensure application exists
          if (!playerData[guildId]?.applications?.[channelId]) {
            return {
              content: '‚ùå Application not found.',
              ephemeral: true
            };
          }
          
          // Update casting status
          playerData[guildId].applications[channelId].castingStatus = castingStatus;
          await savePlayerData(playerData);
          
          // Use castRankingManager to regenerate UI with updated casting status
          console.log('üîß Using castRankingManager.generateSeasonAppRankingUI() after casting status update');
          const { generateSeasonAppRankingUI } = await import('./castRankingManager.js');
          
          // Get application data for UI regeneration
          const { getAllApplicationsFromData, getApplicationsForSeason } = await import('./storage.js');
          const allApplications = configId 
            ? await getApplicationsForSeason(guildId, configId)
            : await getAllApplicationsFromData(guildId);
          const currentApp = allApplications[appIndex];
          
          if (!currentApp) {
            return {
              content: '‚ùå Application not found.',
              ephemeral: true
            };
          }
          
          // Fetch the applicant member
          let applicantMember;
          try {
            applicantMember = await guild.members.fetch(currentApp.userId);
          } catch (error) {
            applicantMember = {
              displayName: currentApp.displayName,
              user: { username: currentApp.username },
              displayAvatarURL: () => currentApp.avatarURL || `https://cdn.discordapp.com/embed/avatars/${currentApp.userId % 5}.png`,
              roles: []
            };
          }
          
          // Generate UI using castRankingManager
          const result = await generateSeasonAppRankingUI({
            guildId,
            userId,
            configId: configId || 'casting',
            allApplications,
            currentApp,
            appIndex,
            applicantMember,
            guild,
            seasonName: 'Current Season', // TODO: Get actual season name
            playerData
          });
          
          console.log(`‚úÖ SUCCESS: casting_status - status set to ${castingStatus} for ${currentApp.displayName} via castRankingManager`);
          return result;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('edit_player_notes_')) {
      // Handle edit player notes button clicks - converted to Button Handler Factory
      return ButtonHandlerFactory.create({
        id: 'edit_player_notes',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`‚úèÔ∏è START: edit_player_notes - user ${context.userId}, button ${context.customId}`);
          
          // Parse button ID: edit_player_notes_[channelId]_[appIndex]_[configId] (new) or edit_player_notes_[channelId]_[appIndex] (legacy)
          const parts = context.customId.split('_');
          const channelId = parts[3];
          const appIndex = parseInt(parts[4]);
          const configId = parts[5]; // May be undefined for legacy buttons
          
          console.log(`‚úèÔ∏è Editing notes for channel ${channelId}, app index ${appIndex}`);
          
          // Load existing notes
          const playerData = await loadPlayerData();
          const existingNotes = playerData[context.guildId]?.applications?.[channelId]?.playerNotes || '';
          
          // Create modal with shortened custom_id to avoid Discord's 100 char limit
          // We'll use a shorter format and store the full data in the modal interaction
          const modalCustomId = `save_notes_${channelId}_${appIndex}`;
            
          const modal = new ModalBuilder()
            .setCustomId(modalCustomId)
            .setTitle('Edit Player Notes');
          
          const notesInput = new TextInputBuilder()
            .setCustomId('player_notes_text')
            .setLabel('Add / Update Player Notes')
            .setPlaceholder('Record casting notes, connections, or potential issues...')
            .setStyle(TextInputStyle.Paragraph)
            .setMaxLength(2000)
            .setRequired(false);
          
          // Only set existing notes if they exist and are not the default placeholder text
          if (existingNotes && existingNotes !== 'Record casting notes, connections or potential issues...') {
            notesInput.setValue(existingNotes);
          }
          
          const actionRow = new ActionRowBuilder().addComponents(notesInput);
          modal.addComponents(actionRow);
          
          console.log(`‚úÖ SUCCESS: edit_player_notes modal created`);
          
          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('delete_application_mode_')) {
      // Handle delete application button clicks - show confirmation using Entity Framework pattern
      return ButtonHandlerFactory.create({
        id: 'delete_application_mode',
        updateMessage: true, // Replace existing message with confirmation
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üóëÔ∏è START: delete_application_mode - user ${context.userId}`);

          // Parse button ID: delete_application_mode_[channelId]_[appIndex]_[configId]
          const parts = context.customId.split('_');
          const channelId = parts[3];
          const appIndex = parseInt(parts[4]);
          const configId = parts.slice(5).join('_'); // Rejoin configId parts

          console.log(`üóëÔ∏è Delete mode for channel ${channelId}, app index ${appIndex}, config ${configId}`);

          // Load application data to get applicant info
          const playerData = await loadPlayerData();
          const application = playerData[context.guildId]?.applications?.[channelId];

          // Get applicant name - use stored data if available, otherwise use generic name
          // This handles the case where channel was manually deleted but data still exists
          const applicantName = application?.displayName || application?.username || `Channel ${channelId}`;

          console.log(`üóëÔ∏è Delete confirmation for: ${applicantName} (Channel exists: ${!!application})`);

          // Create confirmation UI using Entity Framework pattern
          const components = [{
            type: 17, // Container
            accent_color: 0xe74c3c, // Red for danger
            components: [
              {
                type: 10, // Text Display
                content: `## ‚ö†Ô∏è Delete Application\n\n**Applicant:** ${applicantName}\n**Channel:** <#${channelId}>\n\n‚ö†Ô∏è **This action cannot be undone and will:**\n‚Ä¢ Delete the application channel (if it exists)\n‚Ä¢ Remove all application data, votes, and notes\n‚Ä¢ Preserve the applicant's player profile data\n\nAre you sure you want to proceed?`
              },
              { type: 14 }, // Separator
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    style: 4, // Danger
                    label: 'Yes, Delete Application',
                    custom_id: `delete_application_confirm_${channelId}_${appIndex}_${configId}`,
                    emoji: { name: '‚ö†Ô∏è' }
                  },
                  {
                    type: 2, // Button
                    style: 2, // Secondary
                    label: 'Cancel',
                    custom_id: `cancel_delete_application_${channelId}_${appIndex}_${configId}`,
                    emoji: { name: '‚ùå' }
                  }
                ]
              }
            ]
          }];

          console.log(`‚úÖ SUCCESS: delete_application_mode - confirmation shown`);
          return {
            components
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('delete_application_confirm_')) {
      // Handle confirmed application deletion
      return ButtonHandlerFactory.create({
        id: 'delete_application_confirm',
        updateMessage: true, // Update existing confirmation dialog with ranking UI
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        // NOTE: No deferred flag - operation completes quickly (<1s) and we want UPDATE_MESSAGE not webhook
        handler: async (context) => {
          console.log(`üí• START: delete_application_confirm - user ${context.userId}`);
          
          const { guildId, userId, client } = context;
          const guild = await client.guilds.fetch(guildId);
          const member = await guild.members.fetch(userId);

          // Parse button ID: delete_application_confirm_[channelId]_[appIndex]_[configId]
          const parts = context.customId.split('_');
          const channelId = parts[3];
          const appIndex = parseInt(parts[4]);
          const configId = parts.slice(5).join('_'); // Rejoin configId parts
          
          console.log(`üí• Confirming deletion for channel ${channelId}, app index ${appIndex}`);

          // Load application data
          const playerData = await loadPlayerData();

          // Find application(s) by channelId - applications are keyed by application ID, not channel ID
          const applications = playerData[guildId]?.applications || {};
          const matchingEntries = Object.entries(applications).filter(([_, app]) => app.channelId === channelId);

          console.log(`üí• Found ${matchingEntries.length} application(s) with channelId ${channelId}`);
          if (matchingEntries.length > 1) {
            console.log(`‚ö†Ô∏è WARNING: Multiple applications found for same channel (duplicates will all be deleted)`);
          }

          // Get applicant info from first matching application
          const application = matchingEntries[0]?.[1];
          const applicantName = application?.displayName || application?.username || `Channel ${channelId}`;
          const applicantUserId = application?.userId;

          console.log(`üí• Application data exists: ${!!application}`);
          
          // Step 1: Try to delete the channel (silently handle if it doesn't exist)
          let channelDeletedMessage = '';
          try {
            const channel = await guild.channels.fetch(channelId);
            if (channel) {
              await channel.delete('Application deleted by admin');
              channelDeletedMessage = '‚úÖ Application channel deleted';
              console.log(`üóëÔ∏è Channel ${channelId} deleted successfully`);
            }
          } catch (error) {
            if (error.code === 10003) { // Unknown Channel
              channelDeletedMessage = '‚úÖ Channel already deleted';
              console.log(`üóëÔ∏è Channel ${channelId} was already deleted`);
            } else if (error.code === 50013) { // Missing Permissions
              console.error(`‚ùå No permission to delete channel ${channelId}:`, error);
              return {
                content: '‚ùå Missing permissions to delete the application channel. Please check bot permissions.',
                ephemeral: true
              };
            } else {
              console.error(`‚ùå Error deleting channel ${channelId}:`, error);
              channelDeletedMessage = '‚ö†Ô∏è Channel deletion failed, but data will be cleaned';
            }
          }
          
          // Step 2: Clean application data while preserving player data
          try {
            // Remove ALL applications with matching channelId (handles duplicates)
            let deletedCount = 0;
            for (const [appId, app] of matchingEntries) {
              if (playerData[guildId]?.applications?.[appId]) {
                delete playerData[guildId].applications[appId];
                deletedCount++;
                console.log(`üóëÔ∏è Removed application data for appId ${appId} (channel ${channelId})`);
              }
            }

            if (deletedCount === 0) {
              console.log(`‚ö†Ô∏è No application data found to delete for channel ${channelId}`);
            } else if (deletedCount > 1) {
              console.log(`üßπ Cleaned up ${deletedCount} duplicate applications for channel ${channelId}`);
            }

            // Rankings are automatically removed with application deletion (NEW SYSTEM)

            // NOTE: We preserve playerData[guildId].players[applicantUserId] and timezones as requested

            await savePlayerData(playerData);
            console.log(`‚úÖ Application data cleaned for ${applicantName}`);
            
          } catch (error) {
            console.error('‚ùå Error cleaning application data:', error);
            return {
              content: '‚ùå Error cleaning application data. Please try again.',
              ephemeral: true
            };
          }
          
          // Step 3: Log the deletion to server logs
          try {
            const deleterName = member.displayName || member.user.username;
            const serverName = guild.name;
            const isProduction = process.env.NODE_ENV === 'production';
            const logChannelId = isProduction ? '1385059476243218552' : '1386998800215969904';

            const channelDisplayName = application?.channelName || `Channel ${channelId}`;
            const userIdDisplay = applicantUserId || 'Unknown';
            const logMessage = `üóëÔ∏è **Application Deleted**\n**Applicant:** ${applicantName}${applicantUserId ? ` (${applicantUserId})` : ''}\n**Channel:** #${channelDisplayName}\n**Deleted by:** ${deleterName} (${userId})\n**Server:** ${serverName}\n**Time:** <t:${Math.floor(Date.now() / 1000)}:F>`;

            const logChannel = await client.channels.fetch(logChannelId);
            if (logChannel) {
              await logChannel.send(logMessage);
              console.log(`üìù Logged application deletion to ${logChannelId}`);
            }
          } catch (error) {
            console.error('‚ö†Ô∏è Failed to log deletion:', error);
            // Don't fail the operation if logging fails
          }
          
          // Step 4: Navigate to next application or show "no applications" message
          const { getApplicationsForSeason } = await import('./storage.js');
          const allApplications = await getApplicationsForSeason(guildId, configId);
          console.log(`üìä ${allApplications.length} applications remaining in season ${configId} after deletion`);

          if (allApplications.length === 0) {
            // No applications left - show the default message
            console.log(`‚úÖ SUCCESS: delete_application_confirm - no applications remaining`);
            return {
              content: '‚úÖ Application deleted successfully.\n\nüìù No applications found for this server. Create application buttons first using "Creation Application Process".',
              ephemeral: true
            };
          }
          
          // Calculate new navigation index
          let newIndex = appIndex;
          if (appIndex >= allApplications.length) {
            // If we deleted the last item, go to the new last item
            newIndex = allApplications.length - 1;
          }
          // If we deleted the first item, newIndex stays 0 (next item becomes first)
          
          const newApp = allApplications[newIndex];
          console.log(`üß≠ Navigating to application ${newIndex + 1} of ${allApplications.length}: ${newApp.displayName}`);

          // Regenerate Cast Ranking interface using castRankingManager
          const { generateSeasonAppRankingUI } = await import('./castRankingManager.js');

          // Fetch applicant member
          let applicantMember;
          try {
            applicantMember = await guild.members.fetch(newApp.userId);
          } catch (error) {
            // If member left server, create fallback object
            applicantMember = {
              displayName: newApp.displayName,
              user: { username: newApp.username },
              displayAvatarURL: () => newApp.avatarURL || `https://cdn.discordapp.com/embed/avatars/${newApp.userId % 5}.png`,
              id: newApp.userId,
              guild: null // Indicates member has left
            };
          }

          // Get season name from config
          const seasonConfig = playerData[guildId]?.applicationConfigs?.[configId];
          const seasonName = seasonConfig?.seasonName || 'Unknown Season';

          // Generate ranking UI using shared module
          const rankingResponse = await generateSeasonAppRankingUI({
            guildId,
            userId,
            configId,
            allApplications,
            currentApp: newApp,
            appIndex: newIndex,
            applicantMember,
            guild,
            seasonName,
            playerData
          });

          console.log(`‚úÖ SUCCESS: delete_application_confirm - deleted ${applicantName} and navigated to ${newApp.displayName}`);
          return rankingResponse;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('cancel_delete_application_')) {
      // Handle cancel deletion - return to normal ranking interface
      return ButtonHandlerFactory.create({
        id: 'cancel_delete_application',
        updateMessage: true, // Return to ranking interface
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`‚ùå CANCEL: cancel_delete_application - user ${context.userId}`);

          const { guildId, userId, client } = context;
          const guild = await client.guilds.fetch(guildId);

          // Parse button ID: cancel_delete_application_[channelId]_[appIndex]_[configId]
          const parts = context.customId.split('_');
          const channelId = parts[3];
          const appIndex = parseInt(parts[4]);
          const configId = parts.slice(5).join('_'); // Rejoin configId parts

          // Load application data for this season only
          const playerData = await loadPlayerData();
          const { getApplicationsForSeason } = await import('./storage.js');
          const allApplications = await getApplicationsForSeason(guildId, configId);
          const currentApp = allApplications[appIndex];

          if (!currentApp) {
            return {
              components: [{
                type: 17, // Container
                components: [{
                  type: 10, // Text Display
                  content: '‚ùå Application not found.'
                }]
              }]
            };
          }

          // Regenerate Cast Ranking interface using castRankingManager
          const { generateSeasonAppRankingUI } = await import('./castRankingManager.js');

          // Fetch applicant member
          let applicantMember;
          try {
            applicantMember = await guild.members.fetch(currentApp.userId);
          } catch (error) {
            // If member left server, create fallback object
            applicantMember = {
              displayName: currentApp.displayName,
              user: { username: currentApp.username },
              displayAvatarURL: () => currentApp.avatarURL || `https://cdn.discordapp.com/embed/avatars/${currentApp.userId % 5}.png`,
              id: currentApp.userId,
              guild: null
            };
          }

          // Get season name from config
          const seasonConfig = playerData[guildId]?.applicationConfigs?.[configId];
          const seasonName = seasonConfig?.seasonName || 'Unknown Season';

          // Generate ranking UI
          const rankingResponse = await generateSeasonAppRankingUI({
            guildId,
            userId,
            configId,
            allApplications,
            currentApp,
            appIndex,
            applicantMember,
            guild,
            seasonName,
            playerData
          });

          console.log(`‚úÖ SUCCESS: cancel_delete_application - returned to ${currentApp.displayName}`);
          return rankingResponse;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('show_castlist')) {
      // Extract castlist name from custom_id if present
      const castlistMatch = custom_id.match(/^show_castlist(?:_(.+))?$/);
      const requestedCastlist = castlistMatch?.[1] || 'default';
      
      console.log('Button clicked, processing legacy castlist for:', requestedCastlist);
      
      // Execute the exact same logic as the legacy castlist command
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member.user.id;

        // Determine which castlist to show
        const castlistToShow = await determineCastlistToShow(guildId, userId, requestedCastlist);
        console.log(`Selected castlist: ${castlistToShow}`);

        // Load tribe data based on selected castlist
        const tribes = await getGuildTribes(guildId, castlistToShow);
        console.log('Loaded tribes:', JSON.stringify(tribes));

        // Check if any tribes exist
        if (tribes.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              embeds: [{
                title: 'CastBot: Dynamic Castlist',
                description: 'No tribes have been added to the default Castlist yet. Please have Production add tribes via the `/prod_menu` > `üî• Tribes` Button > `üõ†Ô∏è Add Tribe`.',
                color: 0x7ED321
              }],
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Check permissions BEFORE sending deferred response to determine response type
        const member = req.body.member;
        const channelId = req.body.channel_id;
        const canSendMessages = await canSendMessagesInChannel(member, channelId, client);
        console.log(`Pre-deferred permission check: User ${member?.user?.username} can send messages in channel ${channelId}: ${canSendMessages}`);
        
        // Send appropriate deferred response based on permissions
        if (canSendMessages) {
          // User can send messages - public deferred response
          res.send({ type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE });
        } else {
          // User cannot send messages - ephemeral deferred response
          res.send({ 
            type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
            data: { flags: InteractionResponseFlags.EPHEMERAL }
          });
          console.log(`Sent ephemeral deferred response for user ${member?.user?.username}`);
        }

        const guild = await client.guilds.fetch(guildId);
        console.log('Guild:', guild.name);

        if (!guild) {
          throw new Error('Could not fetch guild');
        }

        // Fetch the full guild with roles cache
        const fullGuild = await client.guilds.fetch(guildId, { force: true });
        await fullGuild.roles.fetch();
        const members = await fullGuild.members.fetch();

        // Check if we should omit spacers to fit within Discord's 25 field limit
        const omitSpacers = await shouldOmitSpacers(tribes, fullGuild);
        if (omitSpacers) {
          console.log('Omitting spacers to fit content within 25 field limit');
        }

        // Check if total fields would exceed 25 (moved from /add_tribe for v1/v2 compatibility)
        let totalTribes = 0;
        let totalPlayers = 0;
        
        for (const tribe of tribes) {
          try {
            const tribeRole = await fullGuild.roles.fetch(tribe.roleId);
            if (!tribeRole) continue;
            
            totalTribes++;
            const tribeMembers = members.filter(member => member.roles.cache.has(tribe.roleId));
            totalPlayers += tribeMembers.size;
          } catch (error) {
            console.error(`Error counting fields for tribe ${tribe.roleId}:`, error);
          }
        }
        
        const totalFields = totalTribes + totalPlayers;
        if (totalFields > 25) {
          console.log(`Castlist v1 field limit exceeded: ${totalTribes} tribes + ${totalPlayers} players = ${totalFields} fields (max 25)`);
          const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
          await DiscordRequest(endpoint, {
            method: 'PATCH',
            body: {
              content: `You are trying to show too many players on your castlist at once. The maximum \`(number of tribes + number of players)\` must be 25 or less. Currently: \`${totalTribes} tribes + ${totalPlayers} players = ${totalFields} fields\`.

To fix this:
1) If you have any redundant / old tribes, remove them with \`/clear_tribe <@TribeRole>\`
2) If you are running a season with a large number of players / tribes, you can split these off to custom castlists. Use \`/clear_tribe <@TribeRole>\` to clear one or more tribes, then use \`/add_tribe <@TribeRole>\` and then under the slash command options click 'castlist' and type in a custom name (such as the tribe name). You can then display that castlist using \`/castlist <customname>\`, and any players who are on that castlist will see that with \`/castlist\` instead of the default.

**Tip:** Try using \`/castlist2\` which supports unlimited tribes with pagination!`,
              flags: InteractionResponseFlags.EPHEMERAL
            },
          });
          return;
        }

        // Default color (in hex format)
        const defaultColor = "#7ED321";
        let currentColor = defaultColor;

        // Create the embed first
        const embedTitle = castlistToShow === 'default' 
          ? 'CastBot: Dynamic Castlist'
          : `CastBot: Dynamic Castlist (${castlistToShow})`;
        
        const embed = new EmbedBuilder()
          .setTitle(embedTitle)
          .setAuthor({ 
            name: fullGuild.name || 'Unknown Server', 
            iconURL: fullGuild.iconURL() || undefined 
          })
          .setColor(defaultColor)  // Start with default color
          .setFooter({ 
            text: 'Want dynamic castlist for your ORG? Simply click on \'CastBot\' and click +Add App!',
            iconURL: client.user.displayAvatarURL()
          });

        console.log('Starting to process tribes for castlist. Initial color:', defaultColor);
        
        // Track if any tribe has a color
        let hasFoundColor = false;
        
        // Add each tribe that has members
        for (const tribe of tribes) {
          try {
            const tribeRole = await fullGuild.roles.fetch(tribe.roleId);
            if (!tribeRole) {
              console.log(`Could not find role for tribe ${tribe.roleId}`);
              continue;
            }

            console.log(`Processing tribe role: ${tribeRole.name} (${tribe.roleId})`);
            console.log('Tribe data:', JSON.stringify(tribe));

            // Update the embed color if this tribe has a color specified
            if (tribe.color) {
              hasFoundColor = true;
              currentColor = tribe.color;
              
              try {
                // Convert hex color to a format Discord.js can understand
                // If it already has the # prefix, use it directly
                const colorValue = tribe.color.startsWith('#') ? 
                  tribe.color : `#${tribe.color}`;
                
                console.log(`Setting embed color to ${colorValue} for tribe ${tribeRole.name}`);
                embed.setColor(colorValue);
              } catch (colorErr) {
                console.error(`Error setting color ${tribe.color}:`, colorErr);
              }
            }

            // Add spacer if this isn't the first tribe and we're not omitting spacers
            if (embed.data.fields?.length > 0 && !omitSpacers) {
              embed.addFields({ name: '\u200B', value: '\u200B', inline: false });
            }

            // Add tribe header
            const header = tribe.emoji
              ? `${tribe.emoji}  ${tribeRole.name}  ${tribe.emoji}`
              : tribeRole.name;
            
            embed.addFields({ name: header, value: '\u200B', inline: false });

            // Get members with this role
            const tribeMembers = members.filter(member => member.roles.cache.has(tribe.roleId));
            const memberFields = await createMemberFields(tribeMembers, fullGuild, tribe);
            console.log(`Generated ${memberFields.length} member fields for tribe ${tribeRole.name}`);

            if (embed.data.fields.length + memberFields.length > 25) {
              throw new Error('Embed field limit exceeded');
            }

            embed.addFields(memberFields);

          } catch (error) {
            if (error.message === 'Embed field limit exceeded') {
              console.error('Embed field limit exceeded, sending error message');
              const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
              await DiscordRequest(endpoint, {
                method: 'PATCH',
                body: {
                  content: 'Cannot display castlist: Too many fields (maximum 25). Consider splitting tribes into separate castlists using the castlist parameter in /add_tribe.',
                  flags: InteractionResponseFlags.EPHEMERAL
                },
              });
              return;
            }
            console.error(`Error processing tribe:`, error);
          }
        }

        // Check the color that will be used in the embed
        console.log(`Final embed color settings:`);
        console.log(`- hasFoundColor: ${hasFoundColor}`);
        console.log(`- currentColor: ${currentColor}`);
        console.log(`- embed.data.color: ${embed.data.color || 'not set'}`);

        // If no tribe had a color, make sure we're using the default color
        if (!hasFoundColor) {
          embed.setColor(defaultColor);
          console.log(`No tribe colors found, setting to default: ${defaultColor}`);
        }

        // Edit the initial response with the embed
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            embeds: [embed],
          },
        });

      } catch (error) {
        console.error('Error handling legacy castlist button:', error);
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: 'Error displaying castlist.',
            flags: InteractionResponseFlags.EPHEMERAL
          },
        });
      }
      return;
    } else if (custom_id === 'viral_menu') {
      // Handle menu button click from castlist (admin/user routing) - MIGRATED TO FACTORY
      return ButtonHandlerFactory.create({
        id: 'viral_menu',
        ephemeral: true,
        handler: async (context) => {
          const { member, guildId, client } = context;
          const isAdmin = hasAdminPermissions(member);
          
          console.log(`Menu button clicked: Admin=${isAdmin}, User=${member?.user?.username || 'unknown'}`);
          
          if (isAdmin) {
            // Admin user - redirect to production menu interface
            const guild = await client.guilds.fetch(guildId);
            const playerData = await loadPlayerData();
            const userId = member?.user?.id;
            const menuResponse = await createProductionMenuInterface(guild, playerData, guildId, userId);
            
            return {
              ...menuResponse,
              ephemeral: false // Admin menu is not ephemeral
            };
          } else {
            // Regular user - use new player management UI
            const playerData = await loadPlayerData();
            const userId = member.user.id;
            const guild = await client.guilds.fetch(guildId);
            const targetMember = await guild.members.fetch(userId);
            
            // Create player management UI
            const managementUI = await createPlayerManagementUI({
              mode: PlayerManagementMode.PLAYER,
              targetMember,
              playerData,
              guildId,
              userId,
              channelId: context.channelId,
              showUserSelect: false,
              showVanityRoles: false,
              title: 'CastBot | Player Menu',
              client
            });
            
            return {
              ...managementUI,
              ephemeral: true // Player menu is ephemeral
            };
          }
        }
      })(req, res, client);
    } else if (custom_id === 'restart_status_passed' || custom_id === 'restart_status_failed') {
      // Handle Pass/Fail toggle buttons from restart notifications
      return ButtonHandlerFactory.create({
        id: custom_id,
        updateMessage: true, // CRITICAL: Updates existing message instead of creating new one
        handler: async (context) => {
          console.log(`üîç START: ${context.customId} - user ${context.userId}`);
          
          try {
            // Discord sends components as array of action rows directly (no Container wrapper in incoming messages)
            const messageComponents = context.message?.components || [];
            console.log(`üîç Message has ${messageComponents.length} component row(s)`);
            
            // Debug: Log the actual structure
            if (messageComponents.length > 0) {
              console.log(`üîç First component row type: ${messageComponents[0].type}`);
              console.log(`üîç Component structure:`, JSON.stringify(messageComponents[0], null, 2));
            }
            
            // Log test result (lightweight, non-blocking) - Nice to have feature
            try {
              const isPass = context.customId === 'restart_status_passed';
              const testResult = {
                result: isPass ? 'PASSED' : 'FAILED',
                timestamp: new Date().toISOString(),
                messageId: context.message?.id,
                userId: context.userId
              };
              
              // Extract commit info from message content if available
              const containerContent = messageComponents[0]?.components?.[0]?.content || '';
              const changeMatch = containerContent.match(/## :gem: Change\n(.+?)(?:\n|$)/);
              if (changeMatch) {
                testResult.change = changeMatch[1];
              }
              
              console.log(`üìä TEST RESULT: ${JSON.stringify(testResult)}`);
            } catch (err) {
              // Silently continue - this is optional functionality
            }
            
            // Find the Action Row with our buttons
            // Note: Components V2 messages come with a Container wrapper type 17
            let actionRow;
            if (messageComponents[0]?.type === 17) {
              // It's a Components V2 Container - look inside for the action row
              const containerComponents = messageComponents[0].components || [];
              actionRow = containerComponents.find(row => row.type === 1 && row.components?.some(c => 
                c.custom_id === 'restart_status_passed' || c.custom_id === 'restart_status_failed'
              ));
            } else {
              // Direct action rows (legacy format)
              actionRow = messageComponents.find(row => row.type === 1 && row.components?.some(c => 
                c.custom_id === 'restart_status_passed' || c.custom_id === 'restart_status_failed'
              ));
            }
            
            if (!actionRow) {
              console.error('‚ùå Could not find Action Row with Pass/Fail buttons');
              return {
                content: '‚ùå Error: Button configuration issue',
                ephemeral: true
              };
            }
            
            const buttons = actionRow.components;
            const passButtonIndex = buttons.findIndex(b => b.custom_id === 'restart_status_passed');
            const failButtonIndex = buttons.findIndex(b => b.custom_id === 'restart_status_failed');
            
            if (passButtonIndex === -1 || failButtonIndex === -1) {
              console.error('‚ùå Could not find Pass/Fail buttons in Action Row');
              return {
                content: '‚ùå Error: Button configuration issue',
                ephemeral: true
              };
            }
            
            // Determine which button was clicked and set styles accordingly
            const isPass = context.customId === 'restart_status_passed';
            
            // Update button styles based on selection
            buttons[passButtonIndex].style = isPass ? 3 : 2; // 3=Success(green), 2=Secondary(grey)
            buttons[failButtonIndex].style = isPass ? 2 : 4; // 4=Danger(red), 2=Secondary(grey)
            
            console.log(`‚úÖ SUCCESS: ${context.customId} - toggled to ${isPass ? 'PASS' : 'FAIL'}`);
            
            // For UPDATE_MESSAGE with Components V2, we need to preserve the entire Container structure
            // Update the buttons in place
            actionRow.components = buttons;
            
            // For UPDATE_MESSAGE, we need to return the entire Container
            // Since Discord sent us a Container, we need to return the same structure
            if (messageComponents[0]?.type === 17) {
              // It's a Container - return it with updated buttons
              return {
                components: messageComponents // Return the Container with updated action row
              };
            } else {
              // Legacy format - just return the action rows
              return {
                components: messageComponents
              };
            }
          } catch (error) {
            console.error(`‚ùå ERROR: ${context.customId} - ${error.message}`);
            return {
              content: '‚ùå Error updating test status',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    } else if (custom_id === 'getting_started') {
      // Execute the same logic as the getting_started command
      try {
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        
        const embed = new EmbedBuilder()
          .setTitle('CastBot: Dynamic Castlist')
          .setAuthor({ 
            name: guild.name || 'Unknown Server', 
            iconURL: guild.iconURL() || undefined 
          })
          .setColor('#7ED321')
          .addFields([
            {
              name: 'Getting Started!',
              value: 'CastBot provides a simple to set up, dynamically updating castlist with auto-generated player emojis and live times for each player. Follow the instructions below to get the castlist setup for your next season!'
            },
            {
              name: 'Too Long; Didn\'t Read (tl;dr)',
              value: 'Run `/setup_castbot` to create your pronoun and timezone roles. Then assign your pronoun, timezone and tribe role to each player and type `/castlist`.'
            },
            {
              name: '1Ô∏è‚É£ Set up Pronouns and Timezone roles',
              value: 'CastBot uses Discord roles to track player Pronouns, Timezones and Tribes. Run `/setup_castbot` and CastBot will create the majority of pronouns and timezones roles needed in your server, and add them to its database. If you already have pronoun roles set up, it should automatically detect and add them.'
            },
            {
              name: '2Ô∏è‚É£ Assign Pronoun and Timezone roles to players',
              value: 'Now you must assign the corresponding Pronoun and Timezone roles to each player. You can do this either manually by assigning the player the relevant role in Discord (e.g., He/Him, EST), or you can have the players do the work for you by typing `/player_set_pronouns` and `/player_set_timezone` (such as in their subs) which will allow the players to self assign from a react for roles prompt! You can include these commands as instructions to applicants as part of your season application process so they set their own pronouns and timezones.'
            },
            {
              name: '3Ô∏è‚É£ Set Player Ages',
              value: 'Use `/menu` ‚Üí Manage Players to set player ages individually through the admin interface, or have players set their own age using `/menu` ‚Üí Age.'
            },
            {
              name: '4Ô∏è‚É£ Add Tribes to Castlist',
              value: 'Run `/add_tribe` for each tribe you want to add to your castlist, selecting the Discord Role for the tribe to add. Players with that role will appear in `/castlist`, and when the role is cleared (e.g., they are eliminated), they will no longer appear in the castlist. Use `/clear_tribe` to remove tribes from the castlist.'
            },
            {
              name: 'üìÉ Final Step - view the Castlist!',
              value: 'Type the `/castlist` command in a channel to see your default dynamic castlist. Be sure to let players know they can use the command themselves, such as in their subs or confessionals.'
            },
            {
              name: 'üîÅ How to swap / merge / exile / redemption',
              value: 'Remove your old tribes with `/clear_tribe @TribeRole` and add your new swap tribe roles with `/add_tribe @NewTribeRole`. If you are using redemption or exile style twists, simply create and assign a role for those players (e.g. @Exile) and add the role to the castlist.'
            },
            {
              name: 'How to create additional castlists',
              value: 'You can create additional castlists - for example if you want to show the Production team pronoun information, creating ad-hoc teams for challenges post-merge, etc. To do this, use `/add_tribe`, select the Tribe Role and then click on the castlist option and type a name for your new castlist (e.g., production). You can then view that castlist by typing `/castlist *castlistname*`, e.g. /castlist production.'
            }            
          ])
          .setFooter({ 
            text: 'Want dynamic castlist for your ORG? Simply click on \'CastBot\' and click +Add App!',
            iconURL: client.user.displayAvatarURL()
          });

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            embeds: [embed],
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error handling getting_started button:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error displaying getting started guide.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'admin_manage_player') {
      // üîò Convert to ButtonHandlerFactory
      return ButtonHandlerFactory.create({
        id: 'admin_manage_player',
        handler: async (context) => {
          MenuBuilder.trackLegacyMenu('admin_manage_player', 'Admin player management interface');
          const { guildId, userId, channelId, client, member } = context;
          const guild = await client.guilds.fetch(guildId);

          // Check admin permissions
          if (!hasAdminPermissions(member)) {
            return {
              content: '‚ùå You need Manage Roles, Manage Channels, or Manage Server permissions to use this feature.',
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }

          // Load player data
          const playerData = await loadPlayerData();

          // Create player management UI using the new module
          const managementUI = await createPlayerManagementUI({
            mode: PlayerManagementMode.ADMIN,
            targetMember: null, // No member selected initially
            playerData,
            guildId,
            userId,
            showUserSelect: true,
            showVanityRoles: true,
            title: `Player Management | ${guild.name}`,
            client
          });

          // ALWAYS create new ephemeral message for admin interface (never update production menu)
          managementUI.flags = (1 << 15) | InteractionResponseFlags.EPHEMERAL;
          return managementUI;
        }
      })(req, res, client);
    } else if (custom_id === 'prod_donate') {
      return ButtonHandlerFactory.create({
        id: 'prod_donate',
        updateMessage: true,
        handler: async (context) => {
          console.log(`‚òï Showing donation information`);

          // Import bot emojis
          const { formatBotEmoji } = await import('./botEmojis.js');
          const reeceEmoji = formatBotEmoji('reece');

          // Create donation UI following LEAN standards
          const donateContainer = {
            type: 17, // Container
            accent_color: 0xf39c12, // Orange for appreciation/warmth
            components: [
              {
                type: 10, // Text Display
                content: `## ‚òï Support CastBot Development`
              },
              { type: 14 }, // Separator
              {
                type: 10, // Text Display
                content: `Hey y'all, I develop CastBot to keep involved in the ORG community (and for a bit of fun!). I cover all the costs myself, but any support you can offer is appreciated!\n\n**Monthly Costs**\n‚Ä¢ US$100 - ClaudeMax 5x Plan (AI-assisted development)\n‚Ä¢ US$10 - AWS Lightsail (server hosting & performance)\n‚Ä¢ And typically I put in 20-40 hours of my own (night) time a month üòé\n\nNo expectations or obligation, but much appreciated if you can! No amount is too small, donate link is below :)\n\n**${reeceEmoji} Reece**\nCastBot Developer`
              },
              { type: 14 }, // Separator
              {
                type: 10, // Text Display
                content: `ü™ô **Donate via Ko-fi** ‚Üí https://ko-fi.com/castbot`
              },
              { type: 14 }, // Separator
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    style: 2, // Secondary
                    custom_id: 'prod_menu_back',
                    label: '‚Üê Menu'
                    // NO emoji - back buttons never have emojis
                  },
                  {
                    type: 2, // Button
                    style: 5, // Link style
                    label: 'ü™ô Donate (Ko‚Äëfi)',
                    url: 'https://ko-fi.com/castbot'
                  }
                ]
              }
            ]
          };

          return {
            components: [donateContainer]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_terms_of_service') {
      return ButtonHandlerFactory.create({
        id: 'prod_terms_of_service',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üìú Showing Terms of Service`);

          const tosContainer = {
            type: 17, // Container
            accent_color: 0x3498DB, // Blue
            components: [
              {
                type: 10, // Text Display
                content: `## üìú CastBot Terms of Service`
              },
              { type: 14 }, // Separator
              {
                type: 10, // Text Display
                content: `**Last Updated**: November 2025\n\n**In Plain English:**\n\nCastBot is a free Discord bot for running online reality games (ORGs). By using it, you agree to:\n\n‚Ä¢ **Use it responsibly** - Don't try to break it or abuse it\n‚Ä¢ **No warranties** - CastBot is provided "as is" and might have bugs\n‚Ä¢ **We can make changes** - Features and these terms may be updated\n‚Ä¢ **Your responsibility** - How you use CastBot in your games is up to you\n\nThat's it! No hidden gotchas, no weird legal stuff. If you have questions or concerns, reach out on our support server.\n\n**Contact**: https://discord.gg/H7MpJEjkwT`
              },
              { type: 14 }, // Separator
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    style: 2, // Secondary
                    custom_id: 'castbot_tools',
                    label: '‚Üê Setup'
                  }
                ]
              }
            ]
          };

          return {
            components: [tosContainer]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_privacy_policy') {
      return ButtonHandlerFactory.create({
        id: 'prod_privacy_policy',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîí Showing Privacy Policy`);

          const privacyContainer = {
            type: 17, // Container
            accent_color: 0x3498DB, // Blue
            components: [
              {
                type: 10, // Text Display
                content: `## üîí CastBot Privacy Policy`
              },
              { type: 14 }, // Separator
              {
                type: 10, // Text Display
                content: `**Last Updated**: November 2025\n**Effective Date**: November 2025\n\n## What We Collect\n\n**Server & User Identifiers:**\n‚Ä¢ Discord Server IDs, User IDs, Role IDs, Channel IDs\n‚Ä¢ Used for: Role assignments, castlist management, server configuration\n\n**Game Data:**\n‚Ä¢ Castlists, tribes, season information, player placements\n‚Ä¢ Used for: Displaying game rosters and managing ORG seasons\n\n**User Preferences:**\n‚Ä¢ Pronouns, timezones, availability times, vanity role selections\n‚Ä¢ Used for: Personalized player profiles and scheduling\n\n**Message Content (Application Channels Only):**\n‚Ä¢ Messages typed in private application channels\n‚Ä¢ Used for: Season application responses\n‚Ä¢ Scope: ONLY in channels created via "Apply" button\n‚Ä¢ Never collected: Messages in regular server channels, DMs, or non-application contexts`
              },
              { type: 14 }, // Separator
              {
                type: 10, // Text Display
                content: `## Data Retention\n\n**Active Data (Retained While Bot is Active):**\n‚Ä¢ Server configurations: Retained while bot is in server\n‚Ä¢ Player preferences: Retained while user is in server\n‚Ä¢ Game data: Retained while season is active or archived\n\n**Application Responses:**\n‚Ä¢ Retained: During application period + 90 days after season starts\n‚Ä¢ Auto-deleted: When season ends or application is withdrawn\n‚Ä¢ Manual deletion: Available on request anytime\n\n**Deleted Automatically When:**\n‚Ä¢ Bot is removed from server (all server data deleted)\n‚Ä¢ User leaves server (user-specific data removed)\n‚Ä¢ Season application period closes (90 days after season start)\n‚Ä¢ Admin requests data deletion via support server`
              },
              { type: 14 }, // Separator
              {
                type: 10, // Text Display
                content: `## How We Use Your Data\n\n**Purpose Limitation:**\nYour data is ONLY used for bot functionality. We do not:\n‚Ä¢ ‚ùå Sell or monetize your data\n‚Ä¢ ‚ùå Share with third parties (except as required by law)\n‚Ä¢ ‚ùå Use for advertising or marketing\n‚Ä¢ ‚ùå Train AI/ML models\n‚Ä¢ ‚ùå Track you outside Discord\n‚Ä¢ ‚ùå Read messages in non-application channels\n\n**Message Content Specifics:**\n‚Ä¢ Collected: Only in private application channels you create by clicking "Apply"\n‚Ä¢ Used for: Capturing application responses for host review\n‚Ä¢ Accessed by: Only server admins with manage permissions\n‚Ä¢ Not monitored: Regular server conversations, DMs, or non-application channels`
              },
              { type: 14 }, // Separator
              {
                type: 10, // Text Display
                content: `## Your Rights\n\n**Access & Portability:**\n‚Ä¢ Request a copy of your data anytime\n‚Ä¢ Data provided in JSON format within 7 days\n\n**Deletion:**\n‚Ä¢ Request deletion via support server: https://discord.gg/H7MpJEjkwT\n‚Ä¢ Data deleted within 48 hours\n‚Ä¢ Cannot be recovered after deletion\n\n**Opt-Out:**\n‚Ä¢ Application messages: Don't click "Apply" button\n‚Ä¢ Other features: Remove bot from server or leave server\n\n**Data Security:**\n‚Ä¢ Stored on AWS Lightsail (encrypted at rest)\n‚Ä¢ Access restricted to bot operations only\n‚Ä¢ Regular security updates and monitoring\n‚Ä¢ No unauthorized third-party access`
              },
              { type: 14 }, // Separator
              {
                type: 10, // Text Display
                content: `## Third-Party Services\n\n**Discord API:**\nCastBot uses Discord's official API to function. Discord's Privacy Policy applies: https://discord.com/privacy\n\n**AWS Lightsail:**\nData is stored on AWS servers (US region). AWS Privacy Policy: https://aws.amazon.com/privacy\n\n**No Other Third Parties:**\nWe do not share your data with any other services, analytics platforms, or external parties.\n\n## Updates to This Policy\n\nWe may update this policy to reflect feature changes. Updates will:\n‚Ä¢ Be posted in-bot (this menu)\n‚Ä¢ Include updated "Last Updated" date\n‚Ä¢ Take effect immediately upon posting\n\n## Contact & Data Requests\n\n**Support Server**: https://discord.gg/H7MpJEjkwT\n**For**: Data access, deletion requests, privacy questions, concerns\n**Response Time**: Within 48 hours for deletion, 7 days for data export`
              },
              { type: 14 }, // Separator
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    style: 2, // Secondary
                    custom_id: 'castbot_tools',
                    label: '‚Üê Setup'
                  }
                ]
              }
            ]
          };

          return {
            components: [privacyContainer]
          };
        }
      })(req, res, client);
    // ‚îÄ‚îÄ Player Card Menu (UI Mockup) ‚Äî self-contained in playerCardMenu.js ‚îÄ‚îÄ
    } else if (custom_id.startsWith('pcard_')) {
      return ButtonHandlerFactory.create({
        id: custom_id,
        updateMessage: true,
        handler: async (context) => {
          const { handlePlayerCardInteraction } = await import('./playerCardMenu.js');
          return await handlePlayerCardInteraction(context);
        }
      })(req, res, client);

    } else if (custom_id === 'attribute_management') {
      // Attribute Management Menu - displays server's custom attributes
      return ButtonHandlerFactory.create({
        id: 'attribute_management',
        updateMessage: true,
        handler: async (context) => {
          const { guildId } = context;
          console.log(`üìä Opening Attribute Management for guild ${guildId}`);

          // Get attribute definitions for this server
          const { getAttributeDefinitions } = await import('./safariManager.js');
          const { getAllPresets } = await import('./config/attributeDefaults.js');
          const attributes = await getAttributeDefinitions(guildId);
          const presets = getAllPresets();
          const attributeCount = Object.keys(attributes).length;

          // Build attribute list display
          let attributeListContent = '';
          if (attributeCount === 0) {
            attributeListContent = '*No attributes configured yet.*\n\nClick **Add Attribute** to create your first custom attribute, or **Enable Preset** to quickly enable built-in attributes like Mana or HP.';
          } else {
            const attrLines = Object.entries(attributes).map(([id, attr]) => {
              const emoji = attr.emoji || 'üìä';
              const type = attr.category === 'resource' ? 'Resource' : 'Stat';
              const regenInfo = attr.regeneration?.type !== 'none'
                ? ` (${attr.regeneration?.intervalMinutes || '?'}min regen)`
                : '';
              return `${emoji} **${attr.name}** - ${type}${regenInfo}`;
            });
            attributeListContent = attrLines.join('\n');
          }

          // Build available presets (not yet enabled)
          const enabledPresetIds = Object.keys(attributes).filter(id => presets[id]);
          const availablePresets = Object.entries(presets)
            .filter(([id]) => !enabledPresetIds.includes(id))
            .slice(0, 4); // Limit to 4 for select menu

          const attributeContainer = {
            type: 17, // Container
            accent_color: 0x9b59b6, // Purple for attributes
            components: [
              {
                type: 10, // Text Display
                content: `## üìä Attribute Management`
              },
              { type: 14 }, // Separator
              {
                type: 10, // Text Display
                content: `> **\`üìã Server Attributes (${attributeCount})\`**\n\n${attributeListContent}`
              },
              { type: 14 }, // Separator
              {
                type: 1, // ActionRow
                components: [
                  {
                    type: 2, // Button
                    custom_id: 'attr_add_custom',
                    label: 'Add Attribute',
                    style: 1, // Primary
                    emoji: { name: '‚ûï' }
                  },
                  ...(availablePresets.length > 0 ? [{
                    type: 2, // Button
                    custom_id: 'attr_enable_preset',
                    label: 'Enable Preset',
                    style: 2, // Secondary
                    emoji: { name: '‚ö°' }
                  }] : []),
                  ...(attributeCount > 0 ? [{
                    type: 2, // Button
                    custom_id: 'attr_manage_existing',
                    label: 'Edit/Delete',
                    style: 2, // Secondary
                    emoji: { name: '‚úèÔ∏è' }
                  }] : [])
                ]
              },
              { type: 14 }, // Separator
              {
                type: 1, // ActionRow - Navigation
                components: [
                  {
                    type: 2, // Button
                    custom_id: 'castbot_tools',
                    label: '‚Üê Tools',
                    style: 2 // Secondary
                  }
                ]
              }
            ]
          };

          return {
            components: [attributeContainer]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'attr_add_custom') {
      // Open modal to create new custom attribute
      return res.send({
        type: InteractionResponseType.MODAL,
        data: {
          custom_id: 'modal_attr_create',
          title: 'üìä Create Custom Attribute',
          components: [
            {
              type: 1, // ActionRow
              components: [{
                type: 4, // Text Input
                custom_id: 'attr_name',
                label: 'Attribute Name',
                style: 1, // Short
                placeholder: 'e.g., Mana, Luck, Energy',
                min_length: 1,
                max_length: 30,
                required: true
              }]
            },
            {
              type: 1,
              components: [{
                type: 4,
                custom_id: 'attr_emoji',
                label: 'Emoji',
                style: 1,
                placeholder: 'e.g., üîÆ, üçÄ, ‚ö°',
                min_length: 1,
                max_length: 10,
                required: true
              }]
            },
            {
              type: 1,
              components: [{
                type: 4,
                custom_id: 'attr_type',
                label: 'Type (resource or stat)',
                style: 1,
                placeholder: 'resource (has max, regens) or stat (single value)',
                min_length: 4,
                max_length: 8,
                required: true
              }]
            },
            {
              type: 1,
              components: [{
                type: 4,
                custom_id: 'attr_max_value',
                label: 'Default Max/Value',
                style: 1,
                placeholder: 'e.g., 100',
                min_length: 1,
                max_length: 6,
                required: true
              }]
            },
            {
              type: 1,
              components: [{
                type: 4,
                custom_id: 'attr_regen_minutes',
                label: 'Regeneration (minutes, 0 for none)',
                style: 1,
                placeholder: 'e.g., 60 (for resource types)',
                min_length: 1,
                max_length: 5,
                required: false
              }]
            }
          ]
        }
      });
    } else if (custom_id === 'attr_enable_preset') {
      // Show preset selection
      return ButtonHandlerFactory.create({
        id: 'attr_enable_preset',
        updateMessage: true,
        handler: async (context) => {
          const { guildId } = context;
          const { getAttributeDefinitions } = await import('./safariManager.js');
          const { getAllPresets } = await import('./config/attributeDefaults.js');

          const attributes = await getAttributeDefinitions(guildId);
          const presets = getAllPresets();

          // Filter to presets not yet enabled
          const availablePresets = Object.entries(presets)
            .filter(([id]) => !attributes[id]);

          if (availablePresets.length === 0) {
            return {
              components: [{
                type: 17,
                accent_color: 0x9b59b6,
                components: [
                  { type: 10, content: '## üìä Enable Preset Attribute' },
                  { type: 14 },
                  { type: 10, content: '‚úÖ All preset attributes are already enabled!' },
                  { type: 14 },
                  {
                    type: 1,
                    components: [{
                      type: 2,
                      custom_id: 'attribute_management',
                      label: '‚Üê Back',
                      style: 2
                    }]
                  }
                ]
              }]
            };
          }

          // Build preset options for select menu
          const presetOptions = availablePresets.slice(0, 25).map(([id, preset]) => ({
            label: preset.name,
            value: id,
            description: preset.description?.substring(0, 50) || `${preset.category} attribute`,
            emoji: { name: preset.emoji }
          }));

          return {
            components: [{
              type: 17,
              accent_color: 0x9b59b6,
              components: [
                { type: 10, content: '## ‚ö° Enable Preset Attribute' },
                { type: 14 },
                { type: 10, content: 'Select a preset to enable for your server:' },
                {
                  type: 1,
                  components: [{
                    type: 3, // String Select
                    custom_id: 'attr_preset_select',
                    placeholder: 'Choose a preset...',
                    options: presetOptions
                  }]
                },
                { type: 14 },
                {
                  type: 1,
                  components: [{
                    type: 2,
                    custom_id: 'attribute_management',
                    label: '‚Üê Back',
                    style: 2
                  }]
                }
              ]
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'attr_preset_select') {
      // Handle preset selection
      return ButtonHandlerFactory.create({
        id: 'attr_preset_select',
        updateMessage: true,
        handler: async (context) => {
          const { guildId } = context;
          const selectedPreset = req.body.data.values?.[0];

          if (!selectedPreset) {
            return { content: '‚ùå No preset selected' };
          }

          const { enableAttributePreset } = await import('./safariManager.js');

          try {
            const enabled = await enableAttributePreset(guildId, selectedPreset);
            console.log(`üìä Enabled preset '${enabled.name}' for guild ${guildId}`);

            return {
              components: [{
                type: 17,
                accent_color: 0x27ae60, // Green for success
                components: [
                  { type: 10, content: `## ‚úÖ Preset Enabled` },
                  { type: 14 },
                  { type: 10, content: `**${enabled.emoji} ${enabled.name}** has been enabled for your server!\n\n${enabled.description || ''}` },
                  { type: 14 },
                  {
                    type: 1,
                    components: [{
                      type: 2,
                      custom_id: 'attribute_management',
                      label: '‚Üê Back to Attributes',
                      style: 2
                    }]
                  }
                ]
              }]
            };
          } catch (error) {
            console.error(`‚ùå Failed to enable preset: ${error.message}`);
            return {
              components: [{
                type: 17,
                accent_color: 0xe74c3c, // Red for error
                components: [
                  { type: 10, content: `## ‚ùå Error` },
                  { type: 14 },
                  { type: 10, content: `Failed to enable preset: ${error.message}` },
                  { type: 14 },
                  {
                    type: 1,
                    components: [{
                      type: 2,
                      custom_id: 'attribute_management',
                      label: '‚Üê Back',
                      style: 2
                    }]
                  }
                ]
              }]
            };
          }
        }
      })(req, res, client);
    } else if (custom_id === 'attr_manage_existing') {
      // Show list of existing attributes for edit/delete
      return ButtonHandlerFactory.create({
        id: 'attr_manage_existing',
        updateMessage: true,
        handler: async (context) => {
          const { guildId } = context;
          const { getAttributeDefinitions } = await import('./safariManager.js');
          const attributes = await getAttributeDefinitions(guildId);

          const attrEntries = Object.entries(attributes);
          if (attrEntries.length === 0) {
            return {
              components: [{
                type: 17,
                accent_color: 0x9b59b6,
                components: [
                  { type: 10, content: '## ‚úèÔ∏è Edit/Delete Attributes' },
                  { type: 14 },
                  { type: 10, content: '*No attributes to edit.*\n\nCreate some attributes first!' },
                  { type: 14 },
                  {
                    type: 1,
                    components: [{
                      type: 2,
                      custom_id: 'attribute_management',
                      label: '‚Üê Back',
                      style: 2
                    }]
                  }
                ]
              }]
            };
          }

          // Build select options for attributes
          const attrOptions = attrEntries.slice(0, 25).map(([id, attr]) => ({
            label: attr.name,
            value: id,
            description: `${attr.category === 'resource' ? 'Resource' : 'Stat'} - ${attr.isPreset ? 'Preset' : 'Custom'}`,
            emoji: { name: attr.emoji }
          }));

          return {
            components: [{
              type: 17,
              accent_color: 0x9b59b6,
              components: [
                { type: 10, content: '## ‚úèÔ∏è Edit/Delete Attributes' },
                { type: 14 },
                { type: 10, content: 'Select an attribute to edit or delete:' },
                {
                  type: 1,
                  components: [{
                    type: 3, // String Select
                    custom_id: 'attr_edit_select',
                    placeholder: 'Choose an attribute...',
                    options: attrOptions
                  }]
                },
                { type: 14 },
                {
                  type: 1,
                  components: [{
                    type: 2,
                    custom_id: 'attribute_management',
                    label: '‚Üê Back',
                    style: 2
                  }]
                }
              ]
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'attr_edit_select') {
      // Show edit/delete options for selected attribute
      return ButtonHandlerFactory.create({
        id: 'attr_edit_select',
        updateMessage: true,
        handler: async (context) => {
          const { guildId } = context;
          const selectedAttrId = req.body.data.values?.[0];

          if (!selectedAttrId) {
            return { content: '‚ùå No attribute selected' };
          }

          const { getAttributeDefinitions } = await import('./safariManager.js');
          const attributes = await getAttributeDefinitions(guildId);
          const attr = attributes[selectedAttrId];

          if (!attr) {
            return { content: '‚ùå Attribute not found' };
          }

          // Build attribute details
          const typeLabel = attr.category === 'resource' ? 'Resource' : 'Stat';
          const regenInfo = attr.regeneration?.type !== 'none'
            ? `\n‚Ä¢ Regeneration: ${attr.regeneration?.intervalMinutes} minutes`
            : '\n‚Ä¢ Regeneration: None';
          const sourceLabel = attr.isPreset ? '(Preset)' : '(Custom)';

          return {
            components: [{
              type: 17,
              accent_color: 0x9b59b6,
              components: [
                { type: 10, content: `## ${attr.emoji} ${attr.name} ${sourceLabel}` },
                { type: 14 },
                { type: 10, content: `**Type:** ${typeLabel}\n**Default Value:** ${attr.defaultMax || attr.defaultValue}${regenInfo}\n\n${attr.description || ''}` },
                { type: 14 },
                {
                  type: 1,
                  components: [
                    {
                      type: 2,
                      custom_id: `attr_delete_${selectedAttrId}`,
                      label: 'Delete Attribute',
                      style: 4, // Danger (Red)
                      emoji: { name: 'üóëÔ∏è' }
                    },
                    {
                      type: 2,
                      custom_id: 'attr_manage_existing',
                      label: '‚Üê Back to List',
                      style: 2
                    }
                  ]
                }
              ]
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('attr_delete_')) {
      // Delete attribute confirmation and execution
      return ButtonHandlerFactory.create({
        id: 'attr_delete',
        updateMessage: true,
        handler: async (context) => {
          const { guildId } = context;
          const attrId = custom_id.replace('attr_delete_', '');

          const { deleteAttributeDefinition, getAttributeDefinitions } = await import('./safariManager.js');

          // Get attribute info before deletion for confirmation message
          const attributes = await getAttributeDefinitions(guildId);
          const attr = attributes[attrId];

          if (!attr) {
            return {
              components: [{
                type: 17,
                accent_color: 0xe74c3c,
                components: [
                  { type: 10, content: '## ‚ùå Not Found' },
                  { type: 14 },
                  { type: 10, content: 'Attribute not found or already deleted.' },
                  { type: 14 },
                  {
                    type: 1,
                    components: [{
                      type: 2,
                      custom_id: 'attribute_management',
                      label: '‚Üê Back',
                      style: 2
                    }]
                  }
                ]
              }]
            };
          }

          try {
            await deleteAttributeDefinition(guildId, attrId);
            console.log(`üìä Deleted attribute '${attr.name}' from guild ${guildId}`);

            return {
              components: [{
                type: 17,
                accent_color: 0x27ae60, // Green
                components: [
                  { type: 10, content: '## ‚úÖ Attribute Deleted' },
                  { type: 14 },
                  { type: 10, content: `**${attr.emoji} ${attr.name}** has been removed from your server.` },
                  { type: 14 },
                  {
                    type: 1,
                    components: [{
                      type: 2,
                      custom_id: 'attribute_management',
                      label: '‚Üê Back to Attributes',
                      style: 2
                    }]
                  }
                ]
              }]
            };
          } catch (error) {
            console.error(`‚ùå Failed to delete attribute: ${error.message}`);
            return {
              components: [{
                type: 17,
                accent_color: 0xe74c3c,
                components: [
                  { type: 10, content: '## ‚ùå Delete Failed' },
                  { type: 14 },
                  { type: 10, content: `Error: ${error.message}` },
                  { type: 14 },
                  {
                    type: 1,
                    components: [{
                      type: 2,
                      custom_id: 'attribute_management',
                      label: '‚Üê Back',
                      style: 2
                    }]
                  }
                ]
              }]
            };
          }
        }
      })(req, res, client);
    } else if (custom_id === 'setup_castbot') {
      // Execute setup using new roleManager module
      try {
        console.log('üîç DEBUG: Starting setup_castbot handler');
        
        // Send deferred response first
        await res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });

        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        
        // Execute comprehensive setup using roleManager
        console.log('üîç DEBUG: Calling executeSetup from roleManager');
        const setupResults = await executeSetup(guildId, guild);

        // NEW: Auto-consolidate duplicate timezone roles (Phase 2 integration)
        // Always run consolidation - it scans Discord for unregistered roles and has smart early-exit per timezone
        const playerData = await loadPlayerData();
        const timezones = playerData[guildId]?.timezones || {};

        console.log(`üîÄ Running timezone consolidation (includes Discord scan for unregistered roles)...`);
        const consolidationResults = await consolidateTimezoneRoles(guild, timezones);

        // Only update playerData and results if consolidation actually merged roles
        if (consolidationResults.merged.length > 0) {
          // Clean up deleted roles from playerData
          for (const deleted of consolidationResults.deleted) {
            delete playerData[guildId].timezones[deleted.roleId];
          }
          await savePlayerData(playerData);

          // Add consolidation results to setup results for display
          setupResults.timezones = setupResults.timezones || {};
          setupResults.timezones.consolidation = consolidationResults;

          console.log(`‚úÖ Consolidated ${consolidationResults.merged.length} groups, deleted ${consolidationResults.deleted.length} roles`);
        } else {
          console.log(`‚úÖ No duplicates found (consolidation scanned Discord and playerData)`);
        }

        // Generate detailed Components V2 response
        const componentsV2Response = generateSetupResponseV2(setupResults);
        
        // Send response with Components V2 formatting
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: '', // Empty content as we're using Components V2
            components: [componentsV2Response], // Wrap in array as Discord expects
            flags: InteractionResponseFlags.EPHEMERAL | (1 << 15) // Add IS_COMPONENTS_V2 flag
          }
        });

        console.log('‚úÖ DEBUG: Setup completed successfully');

        // Post setup run announcement to Discord analytics channel
        try {
          const { logSetupRun } = await import('./src/analytics/analyticsLogger.js');
          const userId = req.body.member.user.id;
          const userName = req.body.member.user.global_name || req.body.member.user.username;
          await logSetupRun(guild, userId, userName);
        } catch (error) {
          console.error('‚ö†Ô∏è Failed to log setup run announcement:', error);
          // Don't break setup if announcement fails
        }

      } catch (error) {
        console.error('‚ùå ERROR: setup_castbot handler failed:', error);
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            content: '‚ùå Error during role setup. Please check bot permissions and try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'castbot_tools') {
      // Setup - always show setup interface (no "subsequent run" detection)
      return ButtonHandlerFactory.create({
        id: 'castbot_tools',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        ephemeral: true,
        handler: async (context) => {
          console.log(`üîç START: prod_setup - user ${context.userId}`);

          // Create setup menu using MenuBuilder
          const setupContainer = await MenuBuilder.create('setup_menu', context);

          console.log(`‚úÖ SUCCESS: prod_setup - showing setup interface via MenuBuilder`);

          return {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL (admin UI)
            components: [setupContainer]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_manage_pronouns_timezones') {
      // Show reaction roles management menu
      return ButtonHandlerFactory.create({
        id: 'prod_manage_pronouns_timezones',
        updateMessage: true,  // Update the production menu message (button click)
        handler: async (context) => {
          MenuBuilder.trackLegacyMenu('prod_manage_pronouns_timezones', 'Reaction Roles submenu');

          const { guildId, channelId, client } = context;
          const guild = await client.guilds.fetch(guildId);

          const managementRow1 = new ActionRowBuilder()
            .addComponents(
              new ButtonBuilder()
                .setCustomId('prod_view_timezones')
                .setLabel('View Timezones')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üåç'),
              new ButtonBuilder()
                .setCustomId('prod_edit_timezones')
                .setLabel('Bulk Modify (no offset)')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('‚è≤Ô∏è'),
              new ButtonBuilder()
                .setCustomId('prod_add_timezone')
                .setLabel('Custom Timezone')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üó∫Ô∏è'),
              new ButtonBuilder()
                .setCustomId('prod_timezone_react')
                .setLabel('Post React for Timezones')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üëç')
            );

          const managementRow2 = new ActionRowBuilder()
            .addComponents(
              new ButtonBuilder()
                .setCustomId('prod_view_pronouns')
                .setLabel('View Pronouns')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üíú'),
              new ButtonBuilder()
                .setCustomId('prod_edit_pronouns')
                .setLabel('Edit Pronouns')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üíô'),
              new ButtonBuilder()
                .setCustomId('prod_pronoun_react')
                .setLabel('Post React for Pronouns')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üëç')
            );

          const otherRow = new ActionRowBuilder()
            .addComponents(
              new ButtonBuilder()
                .setCustomId('prod_ban_react')
                .setLabel('Post React for Ban')
                .setStyle(ButtonStyle.Danger)
                .setEmoji('üéØ')
            );

          // Create Components V2 Container with LEAN design
          const backRow = new ActionRowBuilder()
            .addComponents(
              new ButtonBuilder()
                .setCustomId('castbot_tools')
                .setLabel('‚Üê Tools')
                .setStyle(ButtonStyle.Secondary)
            );

          const reactionRolesComponents = [
            {
              type: 10, // Text Display component
              content: `## üéØ Reaction Roles | Role Management\n\nManage reaction-based role assignment. Post reaction panels for Timezones, Pronouns, or deploy Ban traps to catch spam bots.`
            },
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display component
              content: `> **\`üåç Timezone Management\`**`
            },
            managementRow1.toJSON(),
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display component
              content: `> **\`üíú Pronoun Management\`**`
            },
            managementRow2.toJSON(),
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display component
              content: `> **\`üéØ Other\`**`
            },
            otherRow.toJSON(),
            {
              type: 14 // Separator before navigation
            },
            backRow.toJSON()
          ];

          const reactionRolesContainer = {
            type: 17, // Container component
            accent_color: 0x9B59B6, // Purple accent color
            components: reactionRolesComponents
          };

          return {
            components: [reactionRolesContainer]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_availability') {
      // Show availability management menu
      return ButtonHandlerFactory.create({
        id: 'prod_availability',
        handler: async (context) => {
          console.log(`üîç START: prod_availability - user ${context.userId}`);
          MenuBuilder.trackLegacyMenu('prod_availability', 'Availability management submenu');
          
          const { guildId, channelId } = context;
          
          const availabilityRow1 = new ActionRowBuilder()
            .addComponents(
              new ButtonBuilder()
                .setCustomId('prod_availability_react')
                .setLabel('Post Availability Times')
                .setStyle(ButtonStyle.Primary)
                .setEmoji('üìÖ'),
              new ButtonBuilder()
                .setCustomId('prod_availability_options')
                .setLabel('View Availability Groups')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('üë•'),
              new ButtonBuilder()
                .setCustomId('prod_availability_clear')
                .setLabel('Clear My Availability')
                .setStyle(ButtonStyle.Danger)
                .setEmoji('üóëÔ∏è')
            );

          // Create Components V2 Container
          const availabilityComponents = [
            {
              type: 10, // Text Display component
              content: `## Availability Management`
            },
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display component
              content: `> **üìÖ Availability System:** Allows players to indicate when they're available for challenges`
            },
            {
              type: 10, // Text Display component
              content: `> **How it works:**\n> 1. Click "Post Availability Times" to create a reaction message\n> 2. Players react to indicate their available hours (in their local timezone)\n> 3. Use "View Availability Groups" to see optimal challenge times`
            },
            availabilityRow1.toJSON()
          ];

          // Add Back to Tools button
          const backRow = new ActionRowBuilder()
            .addComponents(
              new ButtonBuilder()
                .setCustomId('castbot_tools')
                .setLabel('‚Üê Tools')
                .setStyle(ButtonStyle.Secondary)
                .setEmoji('ü™õ')
            );
          availabilityComponents.push(
            { type: 14 }, // Separator
            backRow.toJSON()
          );
          
          const availabilityContainer = {
            type: 17, // Container component
            accent_color: 0x3498DB, // Blue accent color for availability
            components: availabilityComponents
          };
          
          console.log(`‚úÖ SUCCESS: prod_availability - showing availability menu`);
          return await sendProductionSubmenuResponse(res, channelId, [availabilityContainer]);
        }
      })(req, res, client);
    } else if (custom_id === 'reeces_stuff') {
      // Reece's Stuff - secret admin tools menu (Reece-only)
      // Access check BEFORE factory ‚Äî prevents Components V2 flag mismatch crash on public messages
      if (req.body.member?.user?.id !== '391415444084490240') {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: { content: '‚ùå Access denied.', flags: InteractionResponseFlags.EPHEMERAL }
        });
      }
      return ButtonHandlerFactory.create({
        id: 'reeces_stuff',
        updateMessage: true,
        handler: async (context) => {

          const container = {
            type: 17, accent_color: 0xe74c3c, // Red
            components: [
              { type: 10, content: "## üêß Reece's Stuff" },
              { type: 14 },
              { type: 10, content: '> **`ü¶† Experimental`**' },
              {
                type: 1,
                components: [
                  { type: 2, custom_id: 'pcard_open', label: 'Player Card', style: 2, emoji: { name: 'ü™™' } },
                  { type: 2, custom_id: 'castlist_test', label: 'Compact Castlist', style: 2, emoji: { name: 'üçí' } },
                  { type: 2, custom_id: 'msg_test', label: 'Msg Test', style: 2, emoji: { name: 'üí¨' } }
                ]
              },
              { type: 14 },
              { type: 10, content: '> **`üîß Admin Tools`**' },
              {
                type: 1,
                components: [
                  { type: 2, custom_id: 'test_role_hierarchy', label: 'Check Roles', style: 2, emoji: { name: 'üî∞' } },
                  { type: 2, custom_id: 'admin_populate_logs', label: 'Populate Logs', style: 2, emoji: { name: 'üìú' } }
                ]
              },
              { type: 14 },
              { type: 10, content: '> **`üìº Legacy`**' },
              {
                type: 1,
                components: [
                  { type: 2, custom_id: 'prod_manage_tribes_legacy_debug', label: 'Tribes (Legacy)', style: 2, emoji: { name: 'üî•' } },
                  { type: 2, custom_id: 'prod_live_analytics', label: 'Print Logs', style: 2, emoji: { name: '‚ö†Ô∏è' } },
                  { type: 2, custom_id: 'prod_toggle_live_analytics', label: 'Toggle Logs', style: 2, emoji: { name: 'üîÉ' } }
                ]
              },
              { type: 14 },
              { type: 1, components: [{ type: 2, custom_id: 'castbot_tools', label: '‚Üê Tools', style: 2 }] }
            ]
          };

          const { countComponents } = await import('./utils.js');
          countComponents([container], { verbosity: "summary", label: "Reece's Stuff" });

          return { components: [container] };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_manage_tribes_legacy_debug') {
      // Legacy tribes menu - debug access for Reece only
      return ButtonHandlerFactory.create({
        id: 'prod_manage_tribes_legacy_debug',
        updateMessage: true,
        handler: async (context) => {
          return {
            components: [{
              type: 17, accent_color: 0xE67E22, // Orange for tribes
              components: [
                { type: 10, content: '## üî• Tribes (Legacy)' },
                { type: 14 },
                { type: 10, content: '> **‚ö†Ô∏è** Spectators can view tribe names added before marooning via `/castlist`. Add tribes only after players have the tribe role.' },
                { type: 14 },
                { type: 10, content: '> **`üî• Tribe Actions`**' },
                {
                  type: 1,
                  components: [
                    { type: 2, custom_id: 'prod_view_tribes', label: 'View Tribes', style: 1, emoji: { name: 'üî•' } },
                    { type: 2, custom_id: 'prod_add_tribe', label: 'Add Tribe', style: 2, emoji: { name: 'üõ†Ô∏è' } },
                    { type: 2, custom_id: 'prod_clear_tribe', label: 'Clear Tribe', style: 2, emoji: { name: 'üßπ' } }
                  ]
                },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: 'reeces_stuff', label: "‚Üê Reece's Stuff", style: 2 }] }
              ]
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'season_management_menu') {
      return ButtonHandlerFactory.create({
        id: 'season_management_menu',
        handler: async (context) => {
          console.log(`üîç START: season_management_menu - user ${context.userId}`);
          MenuBuilder.trackLegacyMenu('season_management_menu', 'Season applications management menu');
          
          const { guildId, userId, channelId, client } = context;
          const guild = await client.guilds.fetch(guildId);
          
          // Check admin permissions
          const member = await guild.members.fetch(userId);
          if (!member.permissions.has(PermissionFlagsBits.ManageRoles) && 
              !member.permissions.has(PermissionFlagsBits.ManageChannels) && 
              !member.permissions.has(PermissionFlagsBits.ManageGuild)) {
            return {
              content: '‚ùå You need Manage Roles, Manage Channels, or Manage Server permissions to use this feature.',
              ephemeral: true
            };
          }

          // Load existing application configs and migrate them
          const playerData = await loadPlayerData();
          const guildData = playerData[guildId] || {};
          const applicationConfigs = guildData.applicationConfigs || {};
          
          // Migrate configs without seasonId/seasonName
          // Note: seasonId is somewhat redundant with config ID but kept for backwards compatibility
          for (const [configId, config] of Object.entries(applicationConfigs)) {
            if (!config.seasonId || !config.seasonName) {
              // Generate UUID-based season ID (legacy migration)
              const seasonId = `season_${crypto.randomUUID().replace(/-/g, '').substring(0, 16)}`;
              const seasonName = config.buttonText || `Season ${Object.keys(applicationConfigs).length}`;
              
              config.seasonId = seasonId;
              config.seasonName = seasonName;
              config.questions = config.questions || [];
            }
          }
          
          // Save migrated data
          if (Object.keys(applicationConfigs).length > 0) {
            await savePlayerData(playerData);
          }

          // Use our new reusable season selector
          const { createSeasonSelector } = await import('./seasonSelector.js');
          const seasonSelectDropdown = await createSeasonSelector(guildId, {
            customId: 'entity_select_seasons',
            // Uses default placeholder: 'Select your season...'
            includeCreateNew: true,
            showArchived: false
          });

          const selectRow = new ActionRowBuilder().addComponents(seasonSelectDropdown);

          // Create Components V2 interface following Safari pattern
          const seasonManagementComponents = [
            {
              type: 10, // Text Display
              content: `## :pencil: Season Applications | Manage Season Casting`
            },
            {
              type: 14 // Separator
            },
            selectRow.toJSON()
          ];

          // Add Back to Main Menu button (using centralized factory)
          const backRow = new ActionRowBuilder()
            .addComponents(createBackButton('prod_menu_back'));

          seasonManagementComponents.push(
            { type: 14 }, // Separator
            backRow.toJSON()
          );

          const seasonManagementContainer = {
            type: 17, // Container
            accent_color: 0xf39c12, // Orange like Safari
            components: seasonManagementComponents
          };

          // For submenu navigation, always update if it's a CastBot message with components
          const channel = await client.channels.fetch(channelId);
          const lastMessages = await channel.messages.fetch({ limit: 1 });
          const lastMessage = lastMessages.first();
          
          const shouldUpdateMessage = lastMessage && 
            lastMessage.author.id === client.user.id && 
            lastMessage.components && 
            lastMessage.components.length > 0;
            
          console.log(`üîç DEBUG: Season submenu - shouldUpdate: ${shouldUpdateMessage}`);

          // Count components for debugging (must wrap in array to count Container itself!)
          const { countComponents } = await import('./utils.js');
          countComponents([seasonManagementContainer], {
            enableLogging: true,
            label: 'Season Management Menu Components'
          });

          console.log(`‚úÖ SUCCESS: season_management_menu - completed`);

          return await sendProductionSubmenuResponse(res, channelId, [seasonManagementContainer], shouldUpdateMessage);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_question_up_')) {
      return ButtonHandlerFactory.create({
        id: 'season_question_up',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: season_question_up - user ${context.userId}`);
          const { guildId, userId } = context;
          
          // Extract configId, index, and currentPage: season_question_up_{configId}_{index}_{currentPage}
          const prefix = 'season_question_up_';
          const remaining = context.customId.replace(prefix, '');
          const parts = remaining.split('_');
          const currentPage = parseInt(parts.pop()); // Get page from end
          const questionIndex = parseInt(parts.pop()); // Get index 
          const configId = parts.join('_'); // Join remaining parts as configId
          
          console.log(`üîç DEBUG: Reordering question up - Config: ${configId}, Index: ${questionIndex}`);
          
          // Load player data
          const playerData = await loadPlayerData();
          const config = playerData[guildId]?.applicationConfigs?.[configId];
          
          if (!config || !config.questions || questionIndex <= 0 || questionIndex >= config.questions.length) {
            return {
              content: '‚ùå Unable to reorder question.',
              ephemeral: true
            };
          }
          
          // Swap questions
          const temp = config.questions[questionIndex];
          config.questions[questionIndex] = config.questions[questionIndex - 1];
          config.questions[questionIndex - 1] = temp;
          
          // Update order properties
          config.questions[questionIndex].order = questionIndex + 1;
          config.questions[questionIndex - 1].order = questionIndex;
          
          await savePlayerData(playerData);
          
          console.log(`‚úÖ SUCCESS: season_question_up - question reordered`);
          // Refresh the UI
          return refreshQuestionManagementUI(res, config, configId, currentPage);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_question_down_')) {
      return ButtonHandlerFactory.create({
        id: 'season_question_down',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: season_question_down - user ${context.userId}`);
          const { guildId } = context;
          
          // Extract configId, index, and currentPage: season_question_down_{configId}_{index}_{currentPage}
          const prefix = 'season_question_down_';
          const remaining = context.customId.replace(prefix, '');
          const parts = remaining.split('_');
          const currentPage = parseInt(parts.pop()); // Get page from end
          const questionIndex = parseInt(parts.pop()); // Get index 
          const configId = parts.join('_'); // Join remaining parts as configId
          
          console.log(`üîç DEBUG: Reordering question down - Config: ${configId}, Index: ${questionIndex}`);
          
          // Load player data
          const playerData = await loadPlayerData();
          const config = playerData[guildId]?.applicationConfigs?.[configId];
          
          if (!config || !config.questions || questionIndex < 0 || questionIndex >= config.questions.length - 1) {
            return {
              content: '‚ùå Unable to reorder question.',
              ephemeral: true
            };
          }
          
          // Swap questions
          const temp = config.questions[questionIndex];
          config.questions[questionIndex] = config.questions[questionIndex + 1];
          config.questions[questionIndex + 1] = temp;
          
          // Update order properties
          config.questions[questionIndex].order = questionIndex + 1;
          config.questions[questionIndex + 1].order = questionIndex + 2;
          
          await savePlayerData(playerData);
          
          console.log(`‚úÖ SUCCESS: season_question_down - question reordered`);
          // Refresh the UI
          return refreshQuestionManagementUI(res, config, configId, currentPage);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_question_edit_')) {
      return ButtonHandlerFactory.create({
        id: 'season_question_edit',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: season_question_edit - user ${context.userId}`);
          const { guildId } = context;
          
          // Extract configId, index, and currentPage: season_question_edit_{configId}_{index}_{currentPage}
          const prefix = 'season_question_edit_';
          const remaining = context.customId.replace(prefix, '');
          const parts = remaining.split('_');
          const currentPage = parseInt(parts.pop()); // Get page from end
          const questionIndex = parseInt(parts.pop()); // Get index 
          const configId = parts.join('_'); // Join remaining parts as configId
          
          // Load player data
          const playerData = await loadPlayerData();
          const config = playerData[guildId]?.applicationConfigs?.[configId];
          const question = config?.questions?.[questionIndex];
          
          if (!question) {
            return {
              content: '‚ùå Question not found.',
              ephemeral: true
            };
          }
          
          console.log(`‚úÖ SUCCESS: season_question_edit - modal created`);

          // Show edit modal using modern Label components (Type 18)
          return {
            type: InteractionResponseType.MODAL,
            data: {
              custom_id: `season_edit_question_modal_${configId}_${questionIndex}`,
              title: 'Edit Question',
              components: [
                {
                  type: 18, // Label component
                  label: 'Question Title',
                  description: 'Short, descriptive title for this question',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'questionTitle',
                    style: 1, // Short
                    value: question.questionTitle || '',
                    required: true,
                    max_length: 100
                  }
                },
                {
                  type: 18, // Label component
                  label: 'Question Text',
                  description: 'The full question applicants will answer',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'questionText',
                    style: 2, // Paragraph
                    value: question.questionText || '',
                    required: true,
                    max_length: 1000
                  }
                },
                {
                  type: 18, // Label component
                  label: 'Question Image Link (Optional)',
                  description: 'Shows image when player loads the question. To use, upload image to discord then select \'Copy Link\'.',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'imageURL',
                    style: 1, // Short
                    placeholder: 'Must be a discord URL e.g. https://cdn.discordapp.com/...',
                    value: question.imageURL || '',
                    required: false,
                    max_length: 500
                  }
                }
              ]
            }
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_question_delete_')) {
      return ButtonHandlerFactory.create({
        id: 'season_question_delete',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: season_question_delete - user ${context.userId}`);
          const { guildId } = context;
          
          // Extract configId, index, and currentPage: season_question_delete_{configId}_{index}_{currentPage}
          const prefix = 'season_question_delete_';
          const remaining = context.customId.replace(prefix, '');
          const parts = remaining.split('_');
          const currentPage = parseInt(parts.pop()); // Get page from end
          const questionIndex = parseInt(parts.pop()); // Get index 
          const configId = parts.join('_'); // Join remaining parts as configId
          
          // Load player data
          const playerData = await loadPlayerData();
          const config = playerData[guildId]?.applicationConfigs?.[configId];
          
          if (!config || !config.questions || questionIndex < 0 || questionIndex >= config.questions.length) {
            return {
              content: '‚ùå Unable to delete question.',
              ephemeral: true
            };
          }
          
          // Remove the question
          config.questions.splice(questionIndex, 1);
          
          // Re-index remaining questions
          config.questions.forEach((q, idx) => {
            q.order = idx + 1;
          });
          
          await savePlayerData(playerData);
          
          // Calculate the correct page to show after deletion
          const questionsPerPage = 5;
          const totalPages = Math.max(1, Math.ceil(config.questions.length / questionsPerPage));
          
          // If we're on a page that no longer exists, go to the last valid page
          const validPage = Math.min(currentPage, totalPages - 1);
          
          console.log(`‚úÖ SUCCESS: season_question_delete - question deleted, navigating to page ${validPage}`);
          // Refresh the UI with the correct page
          return refreshQuestionManagementUI(res, config, configId, validPage);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_delete_confirm_')) {
      // Handle confirmed season deletion
      return ButtonHandlerFactory.create({
        id: 'season_delete_confirm',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üí• START: season_delete_confirm - user ${context.userId}`);
          
          // Extract configId: season_delete_confirm_{configId}
          const configId = context.customId.replace('season_delete_confirm_', '');
          
          // Load player data with error handling
          let playerData;
          try {
            playerData = await loadPlayerData();
          } catch (error) {
            console.error(`‚ùå Error loading player data in season_delete_confirm:`, error);
            return {
              content: `‚ùå **Error loading data**\n\nThere was an error accessing the player data file. This might be due to file corruption or concurrent access.\n\nError: ${error.message}\n\nPlease try again in a moment.`,
              ephemeral: true
            };
          }
          
          const config = playerData[context.guildId]?.applicationConfigs?.[configId];
          
          if (!config) {
            return {
              content: `‚ùå Season configuration not found during deletion. ConfigId: ${configId}`,
              ephemeral: true
            };
          }
          
          const seasonName = config.seasonName || 'Unknown Season';
          
          // Count what we're about to delete
          const applications = playerData[context.guildId]?.applications || {};
          const seasonApplications = Object.values(applications).filter(app => app.configId === configId);
          const applicationCount = seasonApplications.length;
          const questionCount = config.questions?.length || 0;
          
          try {
            // Step 1: Delete all applications with matching configId
            const deletedChannelIds = [];
            for (const [channelId, application] of Object.entries(applications)) {
              if (application.configId === configId) {
                deletedChannelIds.push(channelId);
                delete applications[channelId];
              }
            }
            
            // Step 2: Delete the application config
            delete playerData[context.guildId].applicationConfigs[configId];
            
            // Step 3: Save the data
            await savePlayerData(playerData);
            
            console.log(`üí• Season deleted: ${seasonName} (configId: ${configId})`);
            console.log(`üí• Deleted ${applicationCount} applications: ${deletedChannelIds.join(', ')}`);
            console.log(`üí• Deleted ${questionCount} questions`);
            
            console.log(`‚úÖ SUCCESS: season_delete_confirm - season "${seasonName}" deleted (${questionCount} questions, ${applicationCount} applications)`);
            
            // Navigate back to main production menu and dismiss current message
            const menuData = await createProductionMenuInterface(context.guild, playerData, context.guildId, context.userId);
            
            // Add success notification at the top
            const successMessage = `‚úÖ **Season Successfully Deleted**\n\n**"${seasonName}"** has been permanently deleted.\n\n**Deleted:**\n‚Ä¢ ${questionCount} application questions\n‚Ä¢ ${applicationCount} submitted applications and voting data\n‚Ä¢ Season configuration\n\n‚ö†Ô∏è **Remember:** Application channels must be deleted manually if they still exist.\n\n---\n\n`;
            
            // Prepend success message to the existing menu content
            if (menuData.components && menuData.components[0] && menuData.components[0].components) {
              // Find the first text display component and prepend the success message
              const firstTextComponent = menuData.components[0].components.find(comp => comp.type === 10);
              if (firstTextComponent) {
                firstTextComponent.text = successMessage + firstTextComponent.text;
              }
            }
            
            return menuData;
          } catch (error) {
            console.error(`‚ùå Error deleting season ${configId}:`, error);
            return {
              content: `‚ùå **Error deleting season**\n\nSeason: "${seasonName}"\nConfigId: ${configId}\nError: ${error.message}\n\nPlease check the logs and try again or contact an administrator.`,
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_delete_cancel_')) {
      // Handle cancel season deletion
      return ButtonHandlerFactory.create({
        id: 'season_delete_cancel',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`‚ùå CANCEL: season_delete_cancel - user ${context.userId}`);
          
          // Extract configId to return to the manage questions interface
          const configId = context.customId.replace('season_delete_cancel_', '');
          
          // Load player data and return to manage questions interface
          const playerData = await loadPlayerData();
          const config = playerData[context.guildId]?.applicationConfigs?.[configId];
          
          if (!config) {
            return {
              content: '‚ùå Season configuration not found.',
              ephemeral: true
            };
          }
          
          console.log(`‚úÖ SUCCESS: season_delete_cancel - returning to manage questions for ${config.seasonName}`);
          // Return to the manage questions interface (use helper for ButtonHandlerFactory)
          return buildQuestionManagementUI(config, configId, 1);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_edit_info_')) {
      // Handle edit season info button clicks - show modal with pre-populated values
      return ButtonHandlerFactory.create({
        id: 'season_edit_info',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context, req, res) => {
          console.log(`‚úèÔ∏è START: season_edit_info - user ${context.userId}`);

          // Extract configId: season_edit_info_{configId}
          const configId = context.customId.replace('season_edit_info_', '');

          // Load player data to get existing season details
          const playerData = await loadPlayerData();
          const config = playerData[context.guildId]?.applicationConfigs?.[configId];

          if (!config) {
            return {
              content: '‚ùå Season configuration not found.',
              ephemeral: true
            };
          }

          console.log(`‚úÖ SUCCESS: season_edit_info - showing edit modal for ${config.seasonName}`);

          // Show modal with pre-populated values using modern Label components (Type 18)
          return res.send({
            type: InteractionResponseType.MODAL,
            data: {
              custom_id: `season_modal:${configId}`,
              title: 'Manage Season Details',
              components: [
                {
                  type: 18, // Label component
                  label: 'Season Name',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'season_name',
                    style: 1, // Short
                    placeholder: 'e.g., "Season 12 - Jurassic Park"',
                    required: true,
                    max_length: 100,
                    value: config.seasonName || '' // Pre-populate with existing value
                  }
                },
                {
                  type: 18, // Label component
                  label: 'Season Description',
                  description: 'Brief description of this season (optional)',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'season_description',
                    style: 2, // Paragraph
                    placeholder: 'Describe your season...',
                    required: false,
                    max_length: 500,
                    value: config.explanatoryText || '' // Pre-populate with existing value
                  }
                }
              ]
            }
          });
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_delete_')) {
      // Handle season delete button clicks - show confirmation dialog
      return ButtonHandlerFactory.create({
        id: 'season_delete',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üóëÔ∏è START: season_delete - user ${context.userId}`);
          
          // Extract configId: season_delete_{configId}
          const configId = context.customId.replace('season_delete_', '');
          
          // Load player data to get season info and count applications
          const playerData = await loadPlayerData();
          const config = playerData[context.guildId]?.applicationConfigs?.[configId];
          
          if (!config) {
            return {
              content: `‚ùå Season configuration not found. ConfigId: ${configId}`,
              ephemeral: true
            };
          }
          
          // Count applications for this configId
          const applications = playerData[context.guildId]?.applications || {};
          const seasonApplications = Object.values(applications).filter(app => app.configId === configId);
          const applicationCount = seasonApplications.length;
          const questionCount = config.questions?.length || 0;
          
          // Create confirmation UI
          const components = [{
            type: 17, // Container
            accent_color: 0xe74c3c, // Red for danger
            components: [
              {
                type: 10, // Text Display
                content: `## ‚ö†Ô∏è Delete Season: ${config.seasonName}\n\n**This action will permanently delete:**\n‚Ä¢ **${questionCount}** application questions\n‚Ä¢ **${applicationCount}** submitted applications and all voting data\n‚Ä¢ All season configuration data\n\n‚ö†Ô∏è **Channels will NOT be deleted automatically - you must delete them manually**\n\n**This action cannot be undone!**\n\nAre you sure you want to proceed?`
              },
              { type: 14 }, // Separator
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    style: 4, // Danger
                    label: 'Yes, Delete Season',
                    custom_id: `season_delete_confirm_${configId}`,
                    emoji: { name: '‚ö†Ô∏è' }
                  },
                  {
                    type: 2, // Button
                    style: 2, // Secondary
                    label: 'Cancel',
                    custom_id: `season_delete_cancel_${configId}`,
                    emoji: { name: '‚ùå' }
                  }
                ]
              }
            ]
          }];
          
          console.log(`‚úÖ SUCCESS: season_delete - confirmation shown for ${config.seasonName} (${questionCount} questions, ${applicationCount} applications)`);
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2
            components,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_nav_prev_')) {
      return ButtonHandlerFactory.create({
        id: 'season_nav_prev',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: season_nav_prev - user ${context.userId}`);
          const { guildId } = context;
          
          // Extract configId and currentPage: season_nav_prev_{configId}_{currentPage}
          const prefix = 'season_nav_prev_';
          const remaining = context.customId.replace(prefix, '');
          const lastUnderscoreIndex = remaining.lastIndexOf('_');
          const configId = remaining.substring(0, lastUnderscoreIndex);
          const currentPage = parseInt(remaining.substring(lastUnderscoreIndex + 1));
          
          // Load player data
          const playerData = await loadPlayerData();
          const config = playerData[guildId]?.applicationConfigs?.[configId];
          
          if (!config) {
            return {
              content: '‚ùå Season configuration not found.',
              ephemeral: true
            };
          }
          
          const newPage = Math.max(0, currentPage - 1);
          console.log(`‚úÖ SUCCESS: season_nav_prev - navigated to page ${newPage}`);
          return refreshQuestionManagementUI(res, config, configId, newPage);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_nav_next_')) {
      return ButtonHandlerFactory.create({
        id: 'season_nav_next',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: season_nav_next - user ${context.userId}`);
          const { guildId } = context;
          
          // Extract configId and currentPage: season_nav_next_{configId}_{currentPage}
          const prefix = 'season_nav_next_';
          const remaining = context.customId.replace(prefix, '');
          const lastUnderscoreIndex = remaining.lastIndexOf('_');
          const configId = remaining.substring(0, lastUnderscoreIndex);
          const currentPage = parseInt(remaining.substring(lastUnderscoreIndex + 1));
          
          // Load player data
          const playerData = await loadPlayerData();
          const config = playerData[guildId]?.applicationConfigs?.[configId];
          
          if (!config) {
            return {
              content: '‚ùå Season configuration not found.',
              ephemeral: true
            };
          }
          
          const questionsPerPage = 5;
          const totalPages = Math.ceil(config.questions.length / questionsPerPage);
          const newPage = Math.min(totalPages - 1, currentPage + 1);
          console.log(`‚úÖ SUCCESS: season_nav_next - navigated to page ${newPage}`);
          return refreshQuestionManagementUI(res, config, configId, newPage);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_new_question_')) {
      return ButtonHandlerFactory.create({
        id: 'season_new_question_config',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: season_new_question_config - user ${context.userId}`);
          
          // Extract configId and currentPage: season_new_question_{configId}_{currentPage}
          const prefix = 'season_new_question_';
          const remaining = context.customId.replace(prefix, '');
          const parts = remaining.split('_');
          const currentPage = parseInt(parts.pop()); // Get page from end
          const configId = parts.join('_'); // Join remaining parts as configId
          
          console.log(`‚úÖ SUCCESS: season_new_question_config - modal created`);

          // Show new question modal using modern Label components (Type 18)
          return {
            type: InteractionResponseType.MODAL,
            data: {
              custom_id: `season_new_question_modal_${configId}_${currentPage}`,
              title: 'Create New Question',
              components: [
                {
                  type: 18, // Label component
                  label: 'Question Title',
                  description: 'Short, descriptive title for this question',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'questionTitle',
                    style: 1, // Short
                    placeholder: 'Why do you want to join our season?',
                    required: true,
                    max_length: 100
                  }
                },
                {
                  type: 18, // Label component
                  label: 'Question Text',
                  description: 'The full question applicants will answer',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'questionText',
                    style: 2, // Paragraph
                    placeholder: 'Please provide a detailed explanation about...',
                    required: true,
                    max_length: 1000
                  }
                },
                {
                  type: 18, // Label component
                  label: 'Question Image Link (Optional)',
                  description: 'Shows image when player loads the question. To use, upload image to discord then select \'Copy Link\'.',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'imageURL',
                    style: 1, // Short
                    placeholder: 'Must be a discord URL e.g. https://cdn.discordapp.com/...',
                    required: false,
                    max_length: 500
                  }
                }
              ]
            }
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('season_post_button_')) {
      return ButtonHandlerFactory.create({
        id: 'season_post_button_config',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: season_post_button_config - user ${context.userId}`);
          const { guildId, client } = context;
          
          // Extract configId and currentPage: season_post_button_{configId}_{currentPage}
          const prefix = 'season_post_button_';
          const remaining = context.customId.replace(prefix, '');
          const parts = remaining.split('_');
          const currentPage = parseInt(parts.pop()); // Get page from end
          const configId = parts.join('_'); // Join remaining parts as configId
          
          const guild = await client.guilds.fetch(guildId);
          
          // Load existing config
          const playerData = await loadPlayerData();
          const existingConfig = playerData[guildId]?.applicationConfigs?.[configId];
          
          if (!existingConfig) {
            return {
              content: '‚ùå Season configuration not found.',
              ephemeral: true
            };
          }
          
          // Store the configId in a temporary location for the modal handler to use
          if (!req.body.guild_state) req.body.guild_state = {};
          req.body.guild_state.applicationConfigId = configId;
          
          // Show the standard application button modal
          const modal = createApplicationButtonModal();

          // Update modal title with season name (Discord limit: 45 chars)
          const seasonName = existingConfig.seasonName || 'Season';
          const titlePrefix = 'Apply to ';
          const maxTitleLength = 45;
          const maxSeasonNameLength = maxTitleLength - titlePrefix.length;

          let truncatedSeasonName = seasonName;
          if (truncatedSeasonName.length > maxSeasonNameLength) {
            truncatedSeasonName = truncatedSeasonName.substring(0, maxSeasonNameLength - 2) + '..';
          }

          modal.setTitle(`${titlePrefix}${truncatedSeasonName}`);

          // Pre-fill the modal with existing values if available
          modal.components[0].components[0].setValue(existingConfig.buttonText || '');
          modal.components[1].components[0].setValue(existingConfig.explanatoryText || '');

          // Modify the custom_id to indicate this is for an existing config
          modal.setCustomId(`application_button_modal_${configId}`);
          
          console.log(`‚úÖ SUCCESS: season_post_button_config - modal created`);
          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
    } else if (custom_id === 'emergency_app_reinit') {
      // Emergency re-initialization of application questions (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'emergency_app_reinit',
        handler: async (context, req, res, client) => {
          console.log(`üö® Emergency Re-Init: Channel ${context.channelId}, User ${context.userId}`);
          
          // Load player data to find application for this channel
          const playerData = await loadPlayerData();
          const application = playerData[context.guildId]?.applications?.[context.channelId];
          
          if (!application) {
            return {
              content: '‚ùå **Emergency Re-Init Error**\n\nNo application found for this channel. This button can only be used from an existing user\'s application channel.\n\n**Troubleshooting:**\n‚Ä¢ If this channel is broken, try deleting it and ask the user to re-apply\n‚Ä¢ Make sure you\'re running this from the user\'s application channel (e.g., #username-app)',
              ephemeral: true
            };
          }
          
          // Get the application configuration
          const config = await getApplicationConfig(context.guildId, application.configId);
          
          if (!config) {
            return {
              content: '‚ùå **Application Configuration Not Found**\n\nThe application config for this channel is missing or corrupted.\n\n**Next Steps:**\n‚Ä¢ Delete this channel\n‚Ä¢ Ask the user to re-apply through the main application flow\n‚Ä¢ Contact development team if this persists',
              ephemeral: true
            };
          }
          
          // Reset progress and restart from question 1
          application.currentQuestion = 0;
          await savePlayerData(playerData);
          
          console.log(`üîÑ Emergency re-init successful for ${application.displayName} in channel ${context.channelId}`);
          
          // Show first question (same as app_continue flow) - this handles its own response
          return showApplicationQuestion(res, config, context.channelId, 0);
        }
      })(req, res, client);

    } else if (custom_id === 'msg_test') {
      // Test sending a message from CastBot to user (USING DISCORD MESSENGER SERVICE)
      return ButtonHandlerFactory.create({
        id: 'msg_test',
        handler: async (context) => {
          console.log(`üîç START: msg_test - user ${context.userId}`);
          
          // Security check - only allow specific Discord ID
          if (context.userId !== '391415444084490240') {
            console.log(`‚ùå ACCESS DENIED: msg_test - user ${context.userId} not authorized`);
            return {
              content: 'Access denied. This feature is restricted.',
              ephemeral: true
            };
          }
          
          // Import Discord Messenger service
          const { default: DiscordMessenger } = await import('./discordMessenger.js');
          
          // Use the messaging service
          const { client, userId } = context;
          const result = await DiscordMessenger.sendTestMessage(client, userId);
          
          console.log(`‚úÖ SUCCESS: msg_test - completed`);
          return result.response;
        }
      })(req, res, client);

    } else if (custom_id === 'prod_setup_wizard') {
      // Setup Wizard - ephemeral channel response (shares UI with msg_test DM delivery)
      return ButtonHandlerFactory.create({
        id: 'prod_setup_wizard',
        handler: async (context) => {
          console.log(`üßô Setup Wizard requested by user ${context.userId}`);

          // Check if server has completed setup (at least 1 pronoun AND 1 timezone)
          const playerData = await loadPlayerData();
          const hasPronouns = playerData[context.guildId]?.pronounRoleIDs?.length > 0;
          const hasTimezones = playerData[context.guildId]?.timezones && Object.keys(playerData[context.guildId].timezones).length > 0;
          const hasSetup = hasPronouns && hasTimezones;

          console.log(`üßô Setup status: pronouns=${hasPronouns}, timezones=${hasTimezones}, hasSetup=${hasSetup}`);

          // Import Discord Messenger service for reusable components
          const { default: DiscordMessenger } = await import('./discordMessenger.js');

          // Get components in 'channel' context with setup status
          const welcomeComponents = DiscordMessenger.createWelcomeComponents({
            context: 'channel',
            hasSetup
          });

          console.log(`‚úÖ Setup Wizard: Returning ephemeral response with ${welcomeComponents.length} container(s)`);

          // Return ephemeral response with Components V2 structure
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2 - ButtonHandlerFactory adds EPHEMERAL automatically
            components: welcomeComponents,
            ephemeral: true
          };
        }
      })(req, res, client);

    } else if (custom_id === 'dm_poc_button') {
      // PoC: Button click in DM demonstrating UPDATE_MESSAGE with Components V2
      return ButtonHandlerFactory.create({
        id: 'dm_poc_button',
        handler: async (context) => {
          console.log(`üß™ PoC: dm_poc_button clicked in DM by user ${context.userId}`);

          // UPDATE_MESSAGE works identically in DMs and channels!
          // No REST API needed - standard interaction response
          return {
            type: InteractionResponseType.UPDATE_MESSAGE,
            data: {
              components: [
                {
                  type: 17, // Container
                  accent_color: 0x27ae60, // Green for success
                  components: [
                    {
                      type: 10, // Text Display
                      content: '## üëã Hello World!\n\nThis message was updated via **UPDATE_MESSAGE** (standard interaction response).\n\n**No REST API needed for button responses!**'
                    },
                    { type: 14 }, // Separator
                    {
                      type: 10,
                      content: '> **`üéØ Key Insight`**\n‚Ä¢ REST API: Only for initial DM send\n‚Ä¢ UPDATE_MESSAGE: Works natively with Components V2\n‚Ä¢ Button handlers: Identical for channels & DMs!'
                    }
                  ]
                }
              ]
            }
          };
        }
      })(req, res, client);

    // ‚úÖ NEW: Image Gallery System - Persistent URLs via tips.json
    // Reads from tips.json, auto-uploads if URLs missing for current environment
    } else if (custom_id === 'dm_view_tips') {
      return ButtonHandlerFactory.create({
        id: 'dm_view_tips',
        ephemeral: true,
        deferred: true, // Allow time for auto-upload if URLs missing
        handler: async (context) => {
          const { userId } = context;
          console.log(`üí° Loading tips gallery for user ${userId}`);

          // Load tips configuration and ensure URLs exist
          const {
            loadTipsConfig,
            getCurrentEnvironment,
            getTipUrls,
            getTipMetadata,
            getTipCount,
            ensureTipsUploaded
          } = await import('./tipsGalleryManager.js');

          let config = await loadTipsConfig();
          const env = getCurrentEnvironment();

          // Auto-upload if URLs missing (silent background operation)
          await ensureTipsUploaded(context.client, env);

          // Reload config after potential upload
          config = await loadTipsConfig();
          const cdnUrls = getTipUrls(config, env);
          const totalTips = getTipCount(config);

          console.log(`‚úÖ Got ${cdnUrls.length} Discord CDN URLs for ${env}`);

          // Display first tip image (with admin edit button if applicable)
          const index = 0;
          const currentTip = getTipMetadata(config, index);

          // Use UI builder with userId for admin edit button
          const { createTipsDisplayUI } = await import('./tipsGalleryUIBuilder.js');
          return createTipsDisplayUI(index, totalTips, currentTip, cdnUrls[index], 'viral_menu', userId);
        }
      })(req, res, client);

    /* üß™ ORIGINAL CODE (restore after Path A test):
    } else if (custom_id === 'dm_view_tips') {
      return ButtonHandlerFactory.create({
        id: 'dm_view_tips',
        deferred: true,
        handler: async (context) => {
          console.log('üéØ Loading tips gallery - reading all 10 images from filesystem...');
          const interaction = req.body;
          return await generateInitialTipsScreen(interaction, context.client);
        }
      })(req, res, client);
    */

    } else if (custom_id.startsWith('tips_next_') || custom_id.startsWith('tips_prev_')) {
      return ButtonHandlerFactory.create({
        id: custom_id,
        updateMessage: true, // UPDATE_MESSAGE (button response pattern)
        handler: async (context) => {
          const { userId } = context;
          // Parse index from button ID: tips_next_5 or tips_prev_5
          const match = custom_id.match(/^tips_(next|prev)_(\d+)$/);
          if (!match) {
            return {
              content: '‚ùå Invalid tips navigation button.',
              flags: (1 << 6) // EPHEMERAL
            };
          }

          const [, direction, currentIndexStr] = match;
          const currentIndex = parseInt(currentIndexStr);
          const newIndex = direction === 'next' ? currentIndex + 1 : currentIndex - 1;

          // Validate bounds (0-9 for 10 screenshots)
          if (newIndex < 0 || newIndex > 9) {
            return {
              content: '‚ùå Cannot navigate beyond tips gallery bounds.',
              flags: (1 << 6) // EPHEMERAL
            };
          }

          console.log(`üß≠ Navigating tips gallery: ${currentIndex} ‚Üí ${newIndex}`);

          // Load tips configuration (fast - just reads JSON file)
          const {
            loadTipsConfig,
            getCurrentEnvironment,
            getTipUrls,
            getTipMetadata,
            getTipCount
          } = await import('./tipsGalleryManager.js');

          const config = await loadTipsConfig();
          const env = getCurrentEnvironment();
          const cdnUrls = getTipUrls(config, env);
          const totalTips = getTipCount(config);
          const currentTip = getTipMetadata(config, newIndex);

          // Use UI builder with userId for admin edit button
          const { createTipsNavigationUI } = await import('./tipsGalleryUIBuilder.js');
          return createTipsNavigationUI(newIndex, totalTips, currentTip, cdnUrls[newIndex], 'viral_menu', userId);
        }
      })(req, res, client);

    // ‚úèÔ∏è Admin Tips Editor - Edit button handler
    } else if (custom_id.startsWith('edit_tip_')) {
      return ButtonHandlerFactory.create({
        id: 'edit_tip',
        handler: async (context) => {
          const { userId } = context;

          // Permission check (safety layer - UI also hides button)
          if (userId !== '391415444084490240') {
            return {
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå This feature is admin-only',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            };
          }

          // Parse tip index from custom_id
          const tipIndex = parseInt(custom_id.replace('edit_tip_', ''));

          // Load current tip data and environment
          const { loadTipsConfig, getCurrentEnvironment } = await import('./tipsGalleryManager.js');
          const config = await loadTipsConfig();
          const currentTip = config.tips[tipIndex];
          const env = getCurrentEnvironment();

          if (!currentTip) {
            return {
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå Tip ${tipIndex + 1} not found`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            };
          }

          // Get current URL for this environment
          const currentUrl = currentTip.urls?.[env] || '';

          console.log(`‚úèÔ∏è Admin ${userId} editing tip ${tipIndex + 1} (${env})`);

          // Create modal with pre-filled values
          const modal = {
            custom_id: `save_tip_${tipIndex}`,
            title: `Edit Tip ${tipIndex + 1}/10`,
            components: [
              {
                type: 18,  // Label
                label: "Title",
                description: "Feature name with emoji (max 100 chars)",
                component: {
                  type: 4,  // Text Input
                  custom_id: "title",
                  value: currentTip.title,
                  placeholder: "üèÜ Winners' Castlist",
                  max_length: 100,
                  required: true,
                  style: 1  // Short (single line)
                }
              },
              {
                type: 18,  // Label
                label: "Description",
                description: "One-line summary (max 150 chars)",
                component: {
                  type: 4,  // Text Input
                  custom_id: "description",
                  value: currentTip.description,
                  placeholder: "Create a Custom Castlist ordered by Season",
                  max_length: 150,
                  required: true,
                  style: 1  // Short
                }
              },
              {
                type: 18,  // Label
                label: "Showcase Content",
                description: "Full markdown content with heading, description, and setup instructions",
                component: {
                  type: 4,  // Text Input
                  custom_id: "showcase",
                  value: currentTip.showcase,
                  placeholder: "# ‚ú® CastBot New Features (X/10)\\n-# v3.0\\n\\n...",
                  max_length: 4000,  // Discord limit
                  required: true,
                  style: 2  // Paragraph (multi-line)
                }
              },
              {
                type: 18,  // Label
                label: `Image URL (${env})`,
                description: "Discord CDN URL - leave empty to keep existing",
                component: {
                  type: 4,  // Text Input
                  custom_id: "image_url",
                  value: currentUrl,
                  placeholder: "https://cdn.discordapp.com/attachments/...",
                  max_length: 500,
                  required: false,  // Empty = keep existing
                  style: 1  // Short (single line)
                }
              }
            ]
          };

          return {
            type: InteractionResponseType.MODAL,
            data: modal
          };
        }
      })(req, res, client);

    // üîÅ Share Tip - Posts non-ephemeral tip to channel
    } else if (custom_id.startsWith('share_tip_')) {
      return ButtonHandlerFactory.create({
        id: 'share_tip',
        handler: async (context) => {
          // Parse tip index from button ID: share_tip_5
          const tipIndex = parseInt(custom_id.replace('share_tip_', ''));

          console.log(`üîÅ Sharing tip ${tipIndex + 1} to channel`);

          // Load tips configuration
          const {
            loadTipsConfig,
            getCurrentEnvironment,
            getTipUrls,
            getTipMetadata,
            getTipCount
          } = await import('./tipsGalleryManager.js');

          const config = await loadTipsConfig();
          const env = getCurrentEnvironment();
          const cdnUrls = getTipUrls(config, env);
          const totalTips = getTipCount(config);
          const currentTip = getTipMetadata(config, tipIndex);

          // Use shared UI builder (no Back, no Share, no Edit buttons)
          const { createSharedTipsDisplayUI } = await import('./tipsGalleryUIBuilder.js');
          const ui = createSharedTipsDisplayUI(tipIndex, totalTips, currentTip, cdnUrls[tipIndex]);

          // Return as NEW message (CHANNEL_MESSAGE_WITH_SOURCE), NOT ephemeral
          return {
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: ui
          };
        }
      })(req, res, client);

    // üîÅ Shared Tips Navigation - For non-ephemeral shared tips
    } else if (custom_id.startsWith('tips_shared_next_') || custom_id.startsWith('tips_shared_prev_')) {
      return ButtonHandlerFactory.create({
        id: custom_id,
        updateMessage: true, // UPDATE_MESSAGE (edits the shared message)
        handler: async (context) => {
          // Parse index from button ID: tips_shared_next_5 or tips_shared_prev_5
          const match = custom_id.match(/^tips_shared_(next|prev)_(\d+)$/);
          if (!match) {
            return {
              content: '‚ùå Invalid shared tips navigation button.',
              flags: (1 << 6) // EPHEMERAL
            };
          }

          const [, direction, currentIndexStr] = match;
          const currentIndex = parseInt(currentIndexStr);
          const newIndex = direction === 'next' ? currentIndex + 1 : currentIndex - 1;

          // Validate bounds (0-9 for 10 screenshots)
          if (newIndex < 0 || newIndex > 9) {
            return {
              content: '‚ùå Cannot navigate beyond tips gallery bounds.',
              flags: (1 << 6) // EPHEMERAL
            };
          }

          console.log(`üîÅ Navigating shared tips: ${currentIndex} ‚Üí ${newIndex}`);

          // Load tips configuration
          const {
            loadTipsConfig,
            getCurrentEnvironment,
            getTipUrls,
            getTipMetadata,
            getTipCount
          } = await import('./tipsGalleryManager.js');

          const config = await loadTipsConfig();
          const env = getCurrentEnvironment();
          const cdnUrls = getTipUrls(config, env);
          const totalTips = getTipCount(config);
          const currentTip = getTipMetadata(config, newIndex);

          // Use shared UI builder (no Back, no Share, no Edit buttons)
          const { createSharedTipsDisplayUI } = await import('./tipsGalleryUIBuilder.js');
          return createSharedTipsDisplayUI(newIndex, totalTips, currentTip, cdnUrls[newIndex]);
        }
      })(req, res, client);

    } else if (custom_id === 'dm_back_to_welcome') {
      // Navigate back to welcome message from tips
      return ButtonHandlerFactory.create({
        id: 'dm_back_to_welcome',
        handler: async (context) => {
          console.log(`üè† Navigating back to welcome message`);

          // Re-send the original welcome message structure
          const { default: DiscordMessenger } = await import('./discordMessenger.js');
          const user = await context.client.users.fetch(context.userId);
          const dmChannel = await user.createDM();

          // Recreate welcome message structure (same as initial send)
          return {
            type: InteractionResponseType.UPDATE_MESSAGE,
            data: {
              components: [
                {
                  type: 17,
                  accent_color: 0x3498DB,
                  components: [
                    {
                      type: 10,
                      content: '## üé≠ Welcome to CastBot!\n\nThank you for trying the DM demo! CastBot helps you run online reality game seasons with powerful features:'
                    },
                    { type: 14 },
                    {
                      type: 10,
                      content: '> **`üíö Key Features`**\n‚Ä¢ üé¨ Season management & applications\n‚Ä¢ üèÜ Cast rankings & voting systems\n‚Ä¢ ü¶Å Safari adventure challenges\n‚Ä¢ üìã Dynamic castlist displays\n‚Ä¢ ‚è∞ Timezone & pronoun roles'
                    },
                    { type: 14 },
                    {
                      type: 10,
                      content: '> **`üí¨ Need Help?`**\nJoin our support server for:\n‚Ä¢ ‚úÖ Feature tutorials & guides\n‚Ä¢ üîß Technical support\n‚Ä¢ üéØ New feature announcements\n‚Ä¢ üë• Community discussions'
                    },
                    { type: 14 },
                    {
                      type: 1,
                      components: [
                        {
                          type: 2,
                          custom_id: 'dm_poc_button',
                          label: 'Try Interactive Button',
                          style: 3,
                          emoji: { name: 'üëã' }
                        },
                        // DISABLED: Tips gallery button (removed 2025-11-06)
                        // {
                        //   type: 2,
                        //   custom_id: 'dm_view_tips',
                        //   label: 'View Tips',
                        //   style: 1,
                        //   emoji: { name: 'üí°' }
                        // },
                        {
                          type: 2,
                          label: 'Join CastBot Server',
                          style: 5,
                          url: 'https://discord.gg/H7MpJEjkwT',
                          emoji: { name: 'üí¨' }
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          };
        }
      })(req, res, client);

    } else if (custom_id === 'castlist_test') {
      // EXPERIMENTAL: Test rendering castlist with multiple Text Display components in Section
      // DELETE THIS AFTER TESTING - This is temporary for Components V2 research
      // This tests if Sections can render multiple Text Display components as columns
      return ButtonHandlerFactory.create({
        id: 'castlist_test',
        handler: async (context) => {
          console.log(`üß™ EXPERIMENTAL: castlist_test - user ${context.userId}`);
          
          // Security check - only allow specific Discord ID
          if (context.userId !== '391415444084490240') {
            console.log(`‚ùå ACCESS DENIED: castlist_test - user ${context.userId} not authorized`);
            return {
              content: 'Access denied. This feature is restricted.',
              ephemeral: true
            };
          }
          
          // Import castlist functions
          const { loadPlayerData } = await import('./storage.js');
          const playerData = await loadPlayerData();
          
          // Get player list from this guild
          const guildPlayers = playerData[context.guildId]?.players || {};
          const playerIds = Object.keys(guildPlayers).slice(0, 3); // Test with first 3 players
          
          if (playerIds.length === 0) {
            return {
              content: '‚ö†Ô∏è No players found in this guild to test with.',
              ephemeral: true
            };
          }
          
          console.log(`üß™ Testing with ${playerIds.length} players`);
          
          // Fetch guild and members
          const guild = await context.client.guilds.fetch(context.guildId);
          const members = [];
          for (const playerId of playerIds) {
            try {
              const member = await guild.members.fetch(playerId);
              members.push(member);
            } catch (err) {
              console.log(`Could not fetch member ${playerId}: ${err.message}`);
            }
          }
          
          if (members.length === 0) {
            return {
              content: '‚ö†Ô∏è Could not fetch any guild members for testing.',
              ephemeral: true
            };
          }
          
          // EXPERIMENTAL: Test Section with SINGLE Text Display component
          // Testing Discord's actual Section limitations
          
          // Create ONE Text Display component with combined content
          const singleTextDisplay = {
            type: 10, // Text Display
            content: "Player 1 | Player 2 | Player 3"  // Combined content in single component
          };
          
          // Create Section with SINGLE Text Display component AND an accessory
          const experimentalSection = {
            type: 9, // Section
            components: [singleTextDisplay], // Array with exactly ONE Text Display
            accessory: {
              type: 2, // Button accessory (allowed per Discord docs)
              label: "Test Button",
              style: 2, // Secondary style
              custom_id: "section_test_button",
              emoji: { name: "üî¨" }
            }
          };
          
          console.log(`üß™ Created Section with SINGLE Text Display child AND Button accessory`);
          console.log('üîç Section structure:', JSON.stringify(experimentalSection, null, 2));
          console.log('üî¨ Accessory details:', experimentalSection.accessory ? 'Button present' : 'No accessory');
          
          // Build the response with Container
          const containerComponents = [
            {
              type: 10, // Text Display for header
              content: '## üß™ SECTION TEST - WITH ACCESSORY\n\n' +
                      '**Testing Section with ONE Text Display + Button Accessory**\n' +
                      'Combined content: "Player 1 | Player 2 | Player 3"\n' +
                      'Testing if Section requires an accessory component'
            },
            { type: 14 }, // Separator
            experimentalSection, // Section with SINGLE Text Display child
            { type: 14 }, // Separator
            {
              type: 10, // Text Display for footer
              content: `*Testing Section with Text Display + Button accessory*\n` +
                      `*Hypothesis: Section might REQUIRE an accessory to be valid*`
            }
          ];
          
          const response = {
            // DO NOT set flags directly - ButtonHandlerFactory will add (1 << 15) | EPHEMERAL
            ephemeral: true,
            components: [{
              type: 17, // Container
              accent_color: 0xFF00FF, // Magenta to indicate experimental
              components: containerComponents
            }]
          };
          
          // Detailed logging of the full response structure
          console.log('üì¶ Full response structure being sent to ButtonHandlerFactory:');
          console.log('  - flags:', response.flags || 'undefined (ButtonHandlerFactory will add)');
          console.log('  - ephemeral:', response.ephemeral);
          console.log('  - components array length:', response.components.length);
          console.log('  - Container type:', response.components[0].type);
          console.log('  - Container accent_color:', response.components[0].accent_color);
          console.log('  - Container components count:', response.components[0].components.length);
          console.log('  - Component types:', response.components[0].components.map(c => `type ${c.type}`).join(', '));
          console.log('üìã Full response JSON:', JSON.stringify(response, null, 2));
          
          console.log(`‚úÖ EXPERIMENTAL: castlist_test - completed`);
          return response;
        }
      })(req, res, client);
    } else if (custom_id === 'nuke_player_data') {
      // Nuke playerData for current guild - shows confirmation dialog (DELEGATED TO MODULE)
      return ButtonHandlerFactory.create({
        id: 'nuke_player_data',
        updateMessage: true,
        handler: async (context) => {
          const { handleNukeRequest } = await import('./dataNuker.js');
          return handleNukeRequest('playerData', context);
        }
      })(req, res, client);
    } else if (custom_id === 'nuke_player_data_confirm') {
      // Confirm and execute the data nuke (DELEGATED TO MODULE)
      return ButtonHandlerFactory.create({
        id: 'nuke_player_data_confirm',
        updateMessage: true,
        handler: async (context) => {
          const { handleNukeConfirm } = await import('./dataNuker.js');
          return handleNukeConfirm('playerData', context);
        }
      })(req, res, client);
    } else if (custom_id === 'nuke_player_data_cancel') {
      // Cancel the data nuke operation - return to analytics_admin
      return ButtonHandlerFactory.create({
        id: 'nuke_player_data_cancel',
        updateMessage: true,
        handler: async (context) => {
          // Return to Reece Stuff menu (admin menu)
          const reeceMenuData = await createReeceStuffMenu(context.guildId, context.channelId);

          return {
            ...reeceMenuData,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id === 'nuke_safari_content') {
      // Nuke safariContent for current guild - shows confirmation dialog (DELEGATED TO MODULE)
      return ButtonHandlerFactory.create({
        id: 'nuke_safari_content',
        updateMessage: true,
        handler: async (context) => {
          const { handleNukeRequest } = await import('./dataNuker.js');
          return handleNukeRequest('safariContent', context);
        }
      })(req, res, client);
    } else if (custom_id === 'nuke_safari_content_confirm') {
      // Confirm and execute the Safari data nuke (DELEGATED TO MODULE)
      return ButtonHandlerFactory.create({
        id: 'nuke_safari_content_confirm',
        updateMessage: true,
        handler: async (context) => {
          const { handleNukeConfirm } = await import('./dataNuker.js');
          return handleNukeConfirm('safariContent', context);
        }
      })(req, res, client);
    } else if (custom_id === 'nuke_safari_content_cancel') {
      // Cancel the Safari data nuke operation - return to analytics_admin
      return ButtonHandlerFactory.create({
        id: 'nuke_safari_content_cancel',
        updateMessage: true,
        handler: async (context) => {
          // Return to Reece Stuff menu (admin menu)
          const reeceMenuData = await createReeceStuffMenu(context.guildId, context.channelId);

          return {
            ...reeceMenuData,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_change_season') {
      // Handle Change Season - allows setting the active season for the server
      return ButtonHandlerFactory.create({
        id: 'prod_change_season',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: prod_change_season - user ${context.userId}`);
          MenuBuilder.trackLegacyMenu('prod_change_season', 'Change active season menu');
          
          // Security check - only allow specific Discord ID for now
          if (context.userId !== '391415444084490240') {
            console.log(`‚ùå ACCESS DENIED: prod_change_season - user ${context.userId} not authorized`);
            return {
              content: 'Access denied. This feature is in development.',
              ephemeral: true
            };
          }
          
          // Show season selector to change active season
          console.log(`‚úÖ SUCCESS: prod_change_season - showing season selector`);
          
          const menuData = await createCastlistMenu(context.guildId);
          
          return {
            ...menuData,
            flags: (menuData.flags || 0) | InteractionResponseFlags.EPHEMERAL
          };
        }
      })(req, res, client);
    } else if (custom_id === 'castlist_season_select') {
      // Handle season selection - save and refresh production menu
      return ButtonHandlerFactory.create({
        id: 'castlist_season_select',
        updateMessage: true, // Update the existing message
        handler: async (context) => {
          console.log(`üîç START: castlist_season_select - user ${context.userId}`);
          const playerData = await loadPlayerData();
          const { guildId, values } = context;
          const selectedValue = values[0];
          
          // Get the selected season details
          const season = playerData[guildId]?.applicationConfigs?.[selectedValue];
          
          if (!season) {
            return {
              content: '‚ùå Season not found. Please try again.',
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }
          
          // Save the active season to playerData
          if (!playerData[guildId]) {
            playerData[guildId] = {};
          }
          playerData[guildId].activeSeason = {
            id: selectedValue,
            name: season.seasonName,
            stage: season.currentStage || 'planning'
          };
          
          await savePlayerData(playerData);
          console.log(`‚úÖ Active season set to: ${season.seasonName}`);
          
          // Refresh the production menu to show the new season in header
          const menuData = await createProductionMenuInterface(context.guild, playerData, guildId, context.userId);
          return menuData;
        }
      })(req, res, client);
    } else if (custom_id === 'castlist_hub_main') {
      // Handle Castlist Hub main menu - Available to all production team members
      return ButtonHandlerFactory.create({
        id: 'castlist_hub_main',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üìã START: castlist_hub_main - user ${context.userId}`);

          const { createCastlistHub } = await import('./castlistHub.js');
          const hubData = await createCastlistHub(context.guildId, {
            mode: 'list',
            skipMemberFetch: false  // Fetch members for accurate initial display
          });

          console.log(`‚úÖ SUCCESS: castlist_hub_main - showing hub`);
          return hubData;
        }
      })(req, res, client);
    } else if (custom_id === 'castlist_hub_main_new') {
      // Handle Castlist Hub from Setup Wizard - Creates NEW ephemeral message instead of replacing
      return ButtonHandlerFactory.create({
        id: 'castlist_hub_main_new',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        // NO updateMessage - creates new ephemeral message
        handler: async (context) => {
          console.log(`üìã START: castlist_hub_main_new - user ${context.userId} (NEW ephemeral from Setup Wizard)`);

          const { createCastlistHub } = await import('./castlistHub.js');
          const hubData = await createCastlistHub(context.guildId, {
            mode: 'list',
            skipMemberFetch: false  // Fetch members for accurate initial display
          });

          console.log(`‚úÖ SUCCESS: castlist_hub_main_new - showing hub as NEW ephemeral message`);

          // Return as ephemeral response (not updateMessage)
          return {
            ...hubData,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id === 'castlist_select') {
      // Handle all castlist selections through the standard handler
      // 'create_new' selection triggers modal directly, others update hub view
      const { handleCastlistSelect } = await import('./castlistHandlers.js');
      return handleCastlistSelect(req, res, client);
    } else if (custom_id.startsWith('castlist_delete_confirm_')) {
      // Handle castlist deletion confirmation (SPECIFIC PATTERN FIRST)
      const { handleCastlistDeleteConfirm } = await import('./castlistHandlers.js');
      return handleCastlistDeleteConfirm(req, res, client, custom_id);
    } else if (custom_id.startsWith('castlist_delete_') && !custom_id.startsWith('castlist_delete_confirm_')) {
      // Handle castlist deletion (BROAD PATTERN SECOND with exclusion)
      const { handleCastlistDelete } = await import('./castlistHandlers.js');
      return handleCastlistDelete(req, res, client, custom_id);
    } else if (custom_id.startsWith('castlist_swap_merge_')) {
      // Handle tribe swap/merge modal display
      return ButtonHandlerFactory.create({
        id: 'castlist_swap_merge',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          // Extract castlistId from custom_id
          const castlistId = custom_id.replace('castlist_swap_merge_', '');
          console.log(`üîÄ Swap/Merge requested for castlist: ${castlistId}`);

          // VALIDATION: Only allow swap/merge on default castlist
          if (castlistId !== 'default') {
            console.log(`üîÄ Swap/Merge denied - not default castlist`);
            return {
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
              components: [{
                type: 17, // Container
                components: [{
                  type: 10, // Text Display
                  content: `## ‚ùå Swap/Merge Restricted\n\n` +
                           `You can only conduct a Tribe Swap/Merge using the **Active Castlist** (default).\n\n` +
                           `Please change to the Active Castlist and try again. You will then be able to select ` +
                           `the tribe roles for the new phase of the game, and a castlist will be created for ` +
                           `the past phase of the game.`
                }]
              }]
            };
          }

          console.log(`üîÄ Opening Tribe Swap/Merge modal for default castlist`);

          // Return modal with Components V2 Label components
          return {
            type: 9, // MODAL
            data: {
              custom_id: 'tribe_swap_merge_modal',
              title: 'Tribe Swap/Merge (Experimental)',
              components: [
                // 1. Role Select for new tribes
                {
                  type: 18, // Label
                  label: 'New Tribe Roles',
                  description: 'Select the role(s) your players will swap or merge into.',
                  component: {
                    type: 6, // Role Select
                    custom_id: 'new_tribe_roles',
                    placeholder: 'Choose new tribe roles...',
                    min_values: 1, // Allow single tribe for merges
                    max_values: 10
                  }
                },
                // 2. Last Phase Castlist Name (renamed from Archive)
                {
                  type: 18, // Label
                  label: 'Last Phase Castlist Name',
                  description: 'Archive castlist will be made for the last phase; suggest to keep old tribe roles on players.',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'archive_name',
                    style: 1, // Short
                    placeholder: 'e.g., OG Tribes, Swap 1 Tribes',
                    max_length: 50,
                    required: true
                  }
                },
                // 3. Vanity Roles
                {
                  type: 18, // Label
                  label: 'Create Vanity Roles?',
                  description: 'Shows past tribes under player\'s name on Castlist',
                  component: {
                    type: 3, // String Select
                    custom_id: 'vanity_roles',
                    options: [
                      {
                        label: 'Yes - show past tribes on castlists',
                        value: 'yes',
                        description: 'Assigns a vanity role in Castbot',
                        emoji: { name: '‚úÖ' }
                      },
                      {
                        label: 'No - don\'t show past tribes',
                        value: 'no',
                        description: 'Won\'t show past tribes on new castlist',
                        emoji: { name: '‚ùå' }
                      }
                    ]
                  }
                },
                // 4. Auto-Randomize
                {
                  type: 18, // Label
                  label: 'Have Castbot Randomize Swap?',
                  description: 'EXPERIMENTAL - CastBot will randomise swap and automatically assign new tribe roles',
                  component: {
                    type: 3, // String Select
                    custom_id: 'auto_randomize',
                    options: [
                      {
                        label: 'Yes - Automate via CastBot',
                        value: 'yes',
                        description: 'CastBot will conduct live swap in the channel you are in right now',
                        emoji: { name: 'üé≠' }
                      },
                      {
                        label: 'No - Manual Assignment',
                        value: 'no',
                        description: 'You assign roles after creation',
                        emoji: { name: '‚úã' }
                      }
                    ]
                  }
                },
                // 5. Odd Player Behaviour
                {
                  type: 18, // Label
                  label: 'Odd Player Number Behaviour',
                  description: 'What to do if players don\'t divide evenly (doesn\'t apply for merge)',
                  component: {
                    type: 3, // String Select
                    custom_id: 'odd_player_behaviour',
                    options: [
                      {
                        label: 'Randomise odd player into a tribe',
                        value: 'randomise',
                        description: 'CastBot assigns extra players randomly',
                        emoji: { name: 'üé≤' }
                      },
                      {
                        label: 'Manually handle',
                        value: 'manual',
                        description: 'You assign extra players later',
                        emoji: { name: '‚úã' }
                      }
                    ]
                  }
                }
              ]
            }
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('castlist_create_')) {
      // Handle castlist creation options
      const createType = custom_id.replace('castlist_create_', '');
      
      return ButtonHandlerFactory.create({
        id: custom_id,
        updateMessage: true,
        handler: async (context) => {
          console.log(`üìã Creating castlist type: ${createType}`);
          
          const { createCastlistWizard } = await import('./castlistHub.js');
          const wizardData = await createCastlistWizard(context.guildId, createType);
          
          return wizardData;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('castlist_view_') ||
               custom_id.startsWith('castlist_edit_info_') ||
               custom_id.startsWith('castlist_add_tribe_') ||
               custom_id.startsWith('castlist_order_') ||
               custom_id.startsWith('castlist_placements_')) {
      // Handle castlist management buttons
      const { handleCastlistButton } = await import('./castlistHandlers.js');
      const result = await handleCastlistButton(req, res, client, custom_id);
      
      // Check if we should redirect to show_castlist2 handler
      if (result && result.redirectToShowCastlist) {
        // Send deferred response immediately (castlist building takes >3 seconds)
        // UX TWEAK: For placements (edit mode), create new ephemeral message to keep hub visible
        if (result.createNewMessage) {
          await res.send({
            type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        } else {
          await res.send({
            type: InteractionResponseType.DEFERRED_UPDATE_MESSAGE
          });
        }

        // The handler has updated req.body.data.custom_id, so handle it as show_castlist2
        // Extract castlist ID from the modified custom_id
        const currentCustomId = req.body.data.custom_id;

        // Check for edit mode suffix FIRST
        const displayMode = currentCustomId.endsWith('_edit') ? 'edit' : 'view';
        let requestedCastlistId;

        if (displayMode === 'edit') {
          // Remove '_edit' suffix first, then extract castlist ID
          const withoutEdit = currentCustomId.slice(0, -5); // Remove '_edit'
          const castlistMatch = withoutEdit.match(/^show_castlist2(?:_(.+))?$/);
          requestedCastlistId = castlistMatch?.[1] || 'default';
        } else {
          // No edit suffix, extract everything after show_castlist2_
          const castlistMatch = currentCustomId.match(/^show_castlist2(?:_(.+))?$/);
          requestedCastlistId = castlistMatch?.[1] || 'default';
        }

        console.log('Redirecting to castlist display for:', requestedCastlistId, 'in mode:', displayMode);
        
        // Redirect means castlist_view button was clicked, custom_id has been updated
        // Just set the requestedCastlistId and let the existing show_castlist2 logic handle it
        console.log('Redirecting from castlist_view to show_castlist2 for:', requestedCastlistId);
        
        // Update the custom_id to trigger the show_castlist2 handler above
        custom_id = req.body.data.custom_id;
        // Fall through to the next handler check which will catch show_castlist2
        // Actually no, we need to handle it here since we're in a return statement
        
        // Decode virtual castlist ID if needed  
        const { castlistVirtualAdapter } = await import('./castlistVirtualAdapter.js');
        const decodedCastlist = castlistVirtualAdapter.decodeVirtualId(requestedCastlistId);
        
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        const channelId = req.body.channel_id || null;
        const guild = await client.guilds.fetch(guildId);
        const member = req.body.member ? await guild.members.fetch(userId) : null;

        // üîß FIX: Smart member caching (same pattern as save_placement handler)
        const cacheRatio = guild.members.cache.size / guild.memberCount;
        if (cacheRatio < 0.8) {
          console.log(`[CASTLIST NAV] Cache incomplete (${guild.members.cache.size}/${guild.memberCount}), fetching members...`);
          try {
            const fetchStart = Date.now();
            await guild.members.fetch({ timeout: 10000 }); // 10 second timeout
            const fetchTime = Date.now() - fetchStart;
            console.log(`[CASTLIST NAV] ‚úÖ Fetched ${guild.members.cache.size} members in ${fetchTime}ms`);
          } catch (fetchError) {
            console.warn(`[CASTLIST NAV] ‚ö†Ô∏è Member fetch failed after 10s: ${fetchError.message}`);
            console.warn(`[CASTLIST NAV] Continuing with partial cache (${guild.members.cache.size} members)`);
          }
        } else {
          console.log(`[CASTLIST NAV] Cache sufficiently populated (${guild.members.cache.size}/${guild.memberCount}), skipping fetch`);
        }

        // Import necessary functions
        const { loadPlayerData } = await import('./storage.js');
        const { determineCastlistToShow } = await import('./utils/castlistUtils.js');
        const { determineDisplayScenario, createNavigationState, reorderTribes } = await import('./castlistV2.js');
        
        // Determine which castlist to show
        const playerData = await loadPlayerData();
        let castlistName = await determineCastlistToShow(guildId, userId, decodedCastlist);

        // üîß If requestedCastlistId is a castlistId, look up the real name for display
        // (Keep requestedCastlistId as ID for tribe matching, but use name for display)
        let castlistEntity = null;
        if (requestedCastlistId && (requestedCastlistId.startsWith('castlist_') || requestedCastlistId === 'default')) {
          castlistEntity = playerData[guildId]?.castlistConfigs?.[requestedCastlistId];
          if (castlistEntity?.name) {
            castlistName = castlistEntity.name;
            console.log(`Resolved castlistId '${requestedCastlistId}' to name '${castlistName}' for display`);
          }
        }

        console.log('Determined castlist to show:', castlistName);

        // Get tribes for this castlist (using existing logic from main show_castlist2)
        const guildTribes = playerData[guildId]?.tribes || {};
        const allTribes = [];

        // Validate tribes object for invalid keys
        const invalidKeys = Object.keys(guildTribes).filter(key => !/^\d{17,19}$/.test(key));
        if (invalidKeys.length > 0) {
          console.error(`‚ùå [CASTLIST NAV] Found ${invalidKeys.length} invalid keys in tribes object:`, invalidKeys);
        }

        for (const [roleId, tribe] of Object.entries(guildTribes)) {
          // Validate role ID is a Discord snowflake
          if (!/^\d{17,19}$/.test(roleId)) {
            console.warn(`‚ö†Ô∏è [CASTLIST NAV] Skipping invalid role ID: ${roleId}`);
            continue;
          }

          // Check legacy 'castlist', transitional 'castlistId', and current 'castlistIds' array
          const matchesCastlist = (
            // Legacy string matching
            tribe.castlist === castlistName ||
            // Transitional entity ID matching (singular)
            tribe.castlistId === requestedCastlistId ||
            // CURRENT: Multi-castlist array matching (PRIMARY FORMAT)
            (tribe.castlistIds && Array.isArray(tribe.castlistIds) &&
             tribe.castlistIds.includes(requestedCastlistId)) ||
            // Default castlist special cases - REMOVED broad fallback
            (tribe.castlist === 'default' &&
             (castlistName === 'Active Castlist' || requestedCastlistId === 'default')) ||
            (tribe.castlistId === 'default' &&
             (castlistName === 'Active Castlist' || requestedCastlistId === 'default')) ||
            // Array support for default castlist
            (tribe.castlistIds?.includes('default') &&
             (castlistName === 'Active Castlist' || requestedCastlistId === 'default'))
          );

          if (matchesCastlist) {
            try {
              const role = await guild.roles.fetch(roleId);
              if (!role) continue;

              // Keep actual Discord.js member objects like the working show_castlist2 handler
              const tribeMembers = Array.from(role.members.values());

              allTribes.push({
                ...tribe,
                roleId,
                name: role.name,
                members: tribeMembers,
                memberCount: tribeMembers.length,
                // üîó PHASE 2: Attach castlist settings AND seasonId for placement lookups
                castlistSettings: {
                  ...castlistEntity?.settings,
                  seasonId: castlistEntity?.seasonId  // FIX: seasonId is at TOP LEVEL of entity, not in settings
                },
                castlistId: requestedCastlistId,
                guildId: guildId
              });
            } catch (error) {
              console.error(`Error fetching role ${roleId}:`, error);
            }
          }
        }
        
        if (allTribes.length === 0) {
          // üîß Use webhook endpoint (already sent deferred response)
          const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
          return await DiscordRequest(endpoint, {
            method: 'PATCH',
            body: {
              components: [{
                type: 17, // Container
                components: [{
                  type: 10, // Text Display
                  content: `‚ùå No tribes found for castlist: ${castlistName}`
                }]
              }],
              flags: (1 << 15) // IS_COMPONENTS_V2
            }
          });
        }
        
        // Reorder tribes for display
        // Fix: Pass correct parameters to reorderTribes (tribes, userId, strategy, castlistName)
        const tribes = reorderTribes(allTribes, userId, "default", castlistName);
        
        // Check permissions if in channel
        if (channelId && member) {
          try {
            const channel = await client.channels.fetch(channelId);
            const permissions = channel?.permissionsFor(member);
            if (!permissions?.has('SendMessages')) {
              // üîß Use webhook endpoint (already sent deferred response)
              const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
              return await DiscordRequest(endpoint, {
                method: 'PATCH',
                body: {
                  components: [{
                    type: 17, // Container
                    components: [{
                      type: 10, // Text Display
                      content: '‚ùå You do not have permission to send messages in this channel.'
                    }]
                  }],
                  flags: (1 << 15) // IS_COMPONENTS_V2
                }
              });
            }
          } catch (error) {
            console.error('Error checking channel permissions:', error);
          }
        }
        
        // Calculate components for first tribe
        // Safety check: ensure tribes is an array
        if (!Array.isArray(tribes) || tribes.length === 0) {
          console.error('Error: tribes is not a valid array after reorderTribes');
          // üîß Use webhook endpoint (already sent deferred response)
          const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
          return await DiscordRequest(endpoint, {
            method: 'PATCH',
            body: {
              components: [{
                type: 17, // Container
                components: [{
                  type: 10, // Text Display
                  content: '‚ùå Error processing castlist display'
                }]
              }],
              flags: (1 << 15) // IS_COMPONENTS_V2
            }
          });
        }

        const scenario = determineDisplayScenario(tribes);
        const navigationState = createNavigationState(tribes, scenario, 0, 0, guild, { playerData, guildId });

        // Send castlist response with display mode
        // üîß FIX: Pass ID for button encoding, name for display
        // UX TWEAK: Pass createNewMessage flag to force ephemeral for placements edit mode
        await sendCastlist2Response(req, guild, tribes, requestedCastlistId, navigationState, member, channelId, displayMode, castlistName, { playerData, guildId, forceEphemeral: result.createNewMessage });
        return;
      } else {
        return result;
      }
    // DEPRECATED: castlist_sort_ handler - Order button now uses modal (castlist_order_modal_)
    // } else if (custom_id.startsWith('castlist_sort_')) {
    //   const { handleCastlistSort } = await import('./castlistHandlers.js');
    //   return handleCastlistSort(req, res, client, custom_id);
    } else if (custom_id.startsWith('castlist_tribe_select_')) {
      // Handle tribe role selection - instant toggle add/remove with deduplication
      const { handleCastlistTribeSelect } = await import('./castlistHandlers.js');
      return handleCastlistTribeSelect(req, res, client, custom_id);
    } else if (custom_id.startsWith('tribe_edit_button|')) {
      // Handle tribe edit button - opens modal with existing tribe data
      // Button ID format: tribe_edit_button|{roleId}|{castlistId}
      const [prefix, roleId, castlistId] = custom_id.split('|');

      // Validate button format
      if (prefix !== 'tribe_edit_button') {
        console.error(`[TRIBE EDIT] Invalid button prefix: ${prefix}`);
        return res.send({
          type: 4,
          data: {
            content: '‚ùå Error: Invalid button format',
            flags: 64 // Ephemeral
          }
        });
      }

      if (!/^\d{17,19}$/.test(roleId)) {
        console.error(`[TRIBE EDIT] Invalid role ID: ${roleId}`);
        return res.send({
          type: 4,
          data: {
            content: '‚ùå Error: Invalid role ID',
            flags: 64
          }
        });
      }

      if (!castlistId) {
        console.error(`[TRIBE EDIT] Missing castlist ID`);
        return res.send({
          type: 4,
          data: {
            content: '‚ùå Error: Missing castlist ID',
            flags: 64
          }
        });
      }

      return ButtonHandlerFactory.create({
        id: custom_id,
        updateMessage: false, // Returns modal, not message update
        handler: async (context) => {
          console.log(`[TRIBE EDIT] Opening editor for role ${roleId}, castlist ${castlistId}`);

          // Load existing tribe data
          const { loadPlayerData } = await import('./storage.js');
          const playerData = await loadPlayerData();
          const tribeData = playerData[context.guildId]?.tribes?.[roleId] || {};

          // Get role info
          const guild = await client.guilds.fetch(context.guildId);
          const role = await guild.roles.fetch(roleId);
          const roleName = role?.name || 'Unknown Role';

          // Return modal with tribe name, emoji, and color fields
          return {
            type: 9, // MODAL
            data: {
              custom_id: `tribe_edit_modal|${roleId}|${castlistId}`,
              title: `Edit: ${roleName.substring(0, 30)}`,
              components: [
                {
                  type: 18, // Label (Components V2)
                  label: 'Tribe Name',
                  description: 'Change the name of the tribe. This will also update the Discord Role name.',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'tribe_name',
                    style: 1, // Short
                    placeholder: 'Enter tribe name',
                    value: roleName,
                    required: false,
                    max_length: 100 // Discord role name limit
                  }
                },
                {
                  type: 18, // Label (Components V2)
                  label: 'Tribe Emoji',
                  description: 'Unicode or Discord custom emoji',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'tribe_emoji',
                    style: 1, // Short
                    placeholder: 'üî• or <:custom:123>',
                    value: tribeData.emoji || '',
                    required: false,
                    max_length: 60 // Support custom emojis
                  }
                },
                {
                  type: 18, // Label
                  label: 'Accent Color',
                  description: 'Hex color code for tribe styling (with or without #)',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'tribe_color',
                    style: 1, // Short
                    placeholder: '#FF5733 or FF5733',
                    value: tribeData.color || '',
                    required: false,
                    max_length: 7
                  }
                }
              ]
            }
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('edit_placement_')) {
      // Handle placement edit button - show modal (MIGRATED TO FACTORY)
      // üîß FIX: Parse full navigation context from button ID
      // Format: edit_placement_{userId}_{seasonContext}_{castlistId}_{tribeIndex}_{tribePage}_{displayMode}
      // CRITICAL: Both seasonContext AND castlistId can contain underscores!
      // Example: edit_placement_123_season_abc_castlist_456_system_0_0_edit

      // Work backwards from the end (these are always single parts)
      const parts = custom_id.split('_');
      const displayMode = parts[parts.length - 1]; // 'edit' or 'view'
      const tribePage = parts[parts.length - 2];
      const tribeIndex = parts[parts.length - 3];

      // The castlistId starts at a known position and extends backward
      // Find the castlist by looking for "castlist_" pattern OR "default"
      let castlistIdStartIdx = -1;
      let castlistId;
      let seasonContext;

      // Special handling for default castlist which doesn't have "castlist_" prefix
      for (let i = parts.length - 4; i >= 3; i--) {
        if (parts[i] === 'castlist') {
          castlistIdStartIdx = i;
          break;
        } else if (parts[i] === 'default' && i === parts.length - 4) {
          // Default castlist special case
          castlistIdStartIdx = i;
          break;
        }
      }

      if (castlistIdStartIdx === -1) {
        console.error(`‚ùå Could not find 'castlist' or 'default' in button ID: ${custom_id}`);
        throw new Error('Invalid button ID format - missing castlist identifier');
      }

      const playerId = parts[2];

      // Handle both formats
      let castlistIdShort;  // For modal custom_id (short version to stay under 100 chars)
      if (parts[castlistIdStartIdx] === 'default') {
        castlistId = 'default';
        castlistIdShort = 'default';
        seasonContext = parts.slice(3, castlistIdStartIdx).join('_') || 'global';
      } else {
        seasonContext = parts.slice(3, castlistIdStartIdx).join('_') || 'global';
        castlistIdShort = parts.slice(castlistIdStartIdx, parts.length - 3).join('_');

        // üîß FIX: Use parsed castlistId as-is (includes type suffix like _system, _legacy)
        // DO NOT append guildId - entity IDs are castlist_{timestamp}_{type}, not castlist_{timestamp}_{guildId}
        castlistId = castlistIdShort;
      }

      return ButtonHandlerFactory.create({
        id: 'edit_placement',
        handler: async (context) => {
          // Load current placement from correct namespace
          const { loadPlayerData } = await import('./storage.js');
          const playerData = await loadPlayerData();

          // üîß PHASE 1: Read from correct namespace based on season context
          const placementNamespace = seasonContext === 'global'
            ? playerData[context.guildId]?.placements?.global
            : playerData[context.guildId]?.placements?.[seasonContext];

          const placement = placementNamespace?.[playerId]?.placement;

          console.log(`[PLACEMENT EDIT] Loading placement for player ${playerId} from namespace: ${seasonContext} (value: ${placement || 'none'})`);
          console.log(`[PLACEMENT EDIT] Context: castlist=${castlistId}, tribe=${tribeIndex}, page=${tribePage}, mode=${displayMode}`);

          // Return modal structure with FULL navigation context preserved
          return {
            type: InteractionResponseType.MODAL,
            data: {
              // Use shortened castlistId to stay under Discord's 100-char custom_id limit
              custom_id: `save_placement_${playerId}_${seasonContext}_${castlistIdShort}_${tribeIndex}_${tribePage}_${displayMode}`,
              title: "Edit Season Placement",
              components: [
                {
                  type: 18, // Label (Components V2)
                  label: "Placement (1-99)",
                  description: "Enter whole number only (1 = Winner, 2 = Runner-up, etc.). Leave blank if still in game.",
                  component: {
                    type: 4, // Text Input
                    custom_id: "placement",
                    value: placement ? placement.toString() : "",
                    placeholder: "e.g., 1, 2, 24",
                    max_length: 2,
                    required: false,
                    style: 1 // Short
                  }
                }
              ]
            }
          };
        }
      })(req, res, client);
    // TODO: MARKED FOR DELETION - prod_safari_menu removed (2025-02-11)
    // Safari features distributed to Production Menu (Map Admin, Actions) and Map Explorer (Location Editor, Safari Progress)
    // } else if (custom_id === 'prod_safari_menu') {
    //   // Handle Safari submenu - dynamic content management (MIGRATED TO FACTORY)
    //   const shouldUpdateMessage = await shouldUpdateProductionMenuMessage(req.body.channel_id);
    //
    //   return ButtonHandlerFactory.create({
    //     id: 'prod_safari_menu',
    //     requiresPermission: PermissionFlagsBits.ManageRoles,
    //     permissionName: 'Manage Roles',
    //     updateMessage: shouldUpdateMessage,
    //     handler: async (context) => {
    //       console.log('ü¶Å DEBUG: Creating Safari submenu');
    //       MenuBuilder.trackLegacyMenu('prod_safari_menu', 'Safari game management menu');
    //
    //       // Create Safari submenu
    //       const safariMenuData = await createSafariMenu(context.guildId, context.userId, context.member);
    //
    //       return {
    //         ...safariMenuData,
    //         ephemeral: true
    //       };
    //     }
    //   })(req, res, client);

    // TODO: MARKED FOR DELETION - safari_menu back button removed (2025-02-11)
    // Safari submenus now use prod_menu_back to return to Production Menu
    // } else if (custom_id === 'safari_menu') {
    //   // Handle Safari menu button (back button from various Safari submenus)
    //   return ButtonHandlerFactory.create({
    //     id: 'safari_menu',
    //     requiresPermission: PermissionFlagsBits.ManageRoles,
    //     permissionName: 'Manage Roles',
    //     updateMessage: true,
    //     handler: async (context) => {
    //       console.log('ü¶Å DEBUG: Returning to Safari menu');
    //
    //       // Create Safari submenu
    //       const safariMenuData = await createSafariMenu(context.guildId, context.userId, context.member);
    //
    //       return {
    //         ...safariMenuData,
    //         ephemeral: true
    //       };
    //     }
    //   })(req, res, client);
    } else if (custom_id === 'analytics_admin') {
      // Handle Analytics admin menu - special admin features (MIGRATED TO FACTORY)
      // Access check BEFORE factory ‚Äî prevents Components V2 flag mismatch crash on public messages (e.g. restart notification)
      if (req.body.member?.user?.id !== '391415444084490240') {
        console.log(`‚ùå ACCESS DENIED: analytics_admin - user ${req.body.member?.user?.id} not authorized`);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: { content: '‚ùå Access denied. This feature is restricted.', flags: InteractionResponseFlags.EPHEMERAL }
        });
      }
      return ButtonHandlerFactory.create({
        id: 'analytics_admin',
        updateMessage: true,  // Button clicks always update (per CLAUDE.md)
        deferred: true,       // Required: loads 933KB playerData + safariContent + Discord API calls
        handler: async (context) => {
          console.log(`üîç START: analytics_admin - user ${context.userId}`);
          MenuBuilder.trackLegacyMenu('analytics_admin', 'Analytics and admin tools menu');

          // Create Reece Stuff submenu (loads playerData.json 933KB + safariContent.json)
          const reeceMenuData = await createReeceStuffMenu(context.guildId, context.channelId);

          console.log(`‚úÖ SUCCESS: analytics_admin - completed`);
          return {
            ...reeceMenuData,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_manage_safari_buttons') {
      // Handle Safari Button Management submenu (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_manage_safari_buttons',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üéõÔ∏è DEBUG: Opening Safari button management interface`);
          
          // Import Safari manager functions
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const buttons = Object.values(safariData[context.guildId]?.buttons || {});
          
          // Create button management buttons
          const managementButtons = [
            new ButtonBuilder()
              .setCustomId('safari_create_button')
              .setLabel('Create Custom Button')
              .setStyle(ButtonStyle.Primary)
              .setEmoji('üìù'),
            new ButtonBuilder()
              .setCustomId('safari_view_buttons')
              .setLabel('View All Buttons')
              .setStyle(ButtonStyle.Secondary)
              .setEmoji('üìä'),
            new ButtonBuilder()
              .setCustomId('safari_button_manage_existing')
              .setLabel('Edit Existing Button')
              .setStyle(ButtonStyle.Secondary)
              .setEmoji('‚úèÔ∏è')
          ];
          
          const managementRow = new ActionRowBuilder().addComponents(managementButtons);
          
          // Create posting button row
          const postingButtons = [
            new ButtonBuilder()
              .setCustomId('safari_post_button')
              .setLabel('Post Custom Button')
              .setStyle(ButtonStyle.Success)
              .setEmoji('üì§')
          ];
          
          const postingRow = new ActionRowBuilder().addComponents(postingButtons);
          
          // Create back button
          const backButton = new ButtonBuilder()
            .setCustomId('prod_safari_menu')
            .setLabel('‚¨Ö Back to Safari')
            .setStyle(ButtonStyle.Secondary);
          
          const backRow = new ActionRowBuilder().addComponents(backButton);
          
          // Create button summary
          const buttonCount = buttons.length;
          const totalUsage = buttons.reduce((sum, btn) => sum + (btn.metadata?.usageCount || 0), 0);
          const buttonsWithActions = buttons.filter(btn => btn.actions && btn.actions.length > 0).length;
          
          // Build container components
          const containerComponents = [
            {
              type: 10, // Text Display component
              content: `## üìå Manage Safari Buttons\n\nCreate, edit, and manage your interactive custom buttons.\n\n**üìä Statistics:**\n‚Ä¢ **Total Buttons:** ${buttonCount}\n‚Ä¢ **With Actions:** ${buttonsWithActions}\n‚Ä¢ **Total Usage:** ${totalUsage} interactions`
            },
            managementRow.toJSON(), // Management buttons
            postingRow.toJSON(), // Posting buttons
            {
              type: 14 // Separator
            },
            backRow.toJSON() // Back navigation
          ];
          
          // Create Components V2 Container
          const container = {
            type: 17, // Container component
            accent_color: 0x3498db, // Blue accent color
            components: containerComponents
          };
          
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2 flag
            components: [container]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_menu_back') {
      // Handle Back to Main Menu (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'prod_menu_back',
        requiresPermission: PermissionFlagsBits.ManageRoles | PermissionFlagsBits.ManageChannels | PermissionFlagsBits.ManageGuild,
        permissionName: 'Manage Roles, Manage Channels, or Manage Server',
        updateMessage: true,
        handler: async (context) => {
          // Load player data and create main production menu
          const playerData = await loadPlayerData();
          const menuData = await createProductionMenuInterface(context.guild, playerData, context.guildId, context.userId);

          return menuData;
        }
      })(req, res, client);
    } else if (custom_id === 'prod_production_menu') {
      // Handle Back to Main Production Menu from Settings (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'prod_production_menu',
        requiresPermission: PermissionFlagsBits.ManageRoles | PermissionFlagsBits.ManageChannels | PermissionFlagsBits.ManageGuild,
        permissionName: 'Manage Roles, Manage Channels, or Manage Server',
        updateMessage: true,
        handler: async (context) => {
          // Load player data and create main production menu
          const playerData = await loadPlayerData();
          const menuData = await createProductionMenuInterface(context.guild, playerData, context.guildId, context.userId);

          return menuData;
        }
      })(req, res, client);
    } else if (custom_id === 'season_app_creation') {
      // Handle Creation Application Process - show the original application modal
      try {
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        const userId = req.body.member.user.id;

        // Check admin permissions
        const member = await guild.members.fetch(userId);
        if (!member.permissions.has(PermissionFlagsBits.ManageRoles) && 
            !member.permissions.has(PermissionFlagsBits.ManageChannels) && 
            !member.permissions.has(PermissionFlagsBits.ManageGuild)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå You need Manage Roles, Manage Channels, or Manage Server permissions to use this feature.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Show the application button configuration modal (original logic)
        const modal = createApplicationButtonModal();
        
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal
        });
        
      } catch (error) {
        console.error('Error handling season_app_creation button:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error loading application creation interface.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('season_app_ranking_')) {
      return ButtonHandlerFactory.create({
        id: 'season_app_ranking',
        handler: async (context) => {
          console.log(`üîç START: season_app_ranking - user ${context.userId}`);
          const { guildId, userId, client } = context;
          
          // Extract configId from custom_id: season_app_ranking_{configId}
          const configId = context.customId.replace('season_app_ranking_', '');
          console.log(`üèÜ Cast Ranking for season: ${configId}`);
          
          const guild = await client.guilds.fetch(guildId);
          const member = await guild.members.fetch(userId);
          
          // Check Cast Ranking permissions (includes special exception for server 1331657596087566398)
          if (!hasCastRankingPermissions(member, guildId)) {
            return {
              content: '‚ùå You need Manage Roles or Manage Channels permissions to access Cast Ranking.',
              ephemeral: true
            };
          }

          // Load season configuration to get season name
          const playerData = await loadPlayerData();
          const seasonConfig = playerData[guildId]?.applicationConfigs?.[configId];
          const seasonName = seasonConfig?.seasonName || 'Unknown Season';
          
          // Load applications data filtered by season
          const allApplications = await getApplicationsForSeason(guildId, configId);
          
          console.log(`Found ${allApplications.length} applications for ranking`);
          console.log('Debug - Guild ID:', guildId);
          
          // Debug: Check what's actually in playerData
          console.log('Debug - Guild exists in playerData:', !!playerData[guildId]);
          console.log('Debug - Applications section exists:', !!playerData[guildId]?.applications);
          if (playerData[guildId]?.applications) {
            console.log('Debug - Application keys:', Object.keys(playerData[guildId].applications));
            console.log('Debug - Application data:', JSON.stringify(playerData[guildId].applications, null, 2));
          }
          
          if (allApplications.length > 0) {
            console.log('Applications:', allApplications.map(app => `${app.displayName} (${app.channelName})`).join(', '));
          }

          if (allApplications.length === 0) {
            return {
              content: `üìù No applications found for season "${seasonName}". \n\nApplicants need to use the application button for this specific season to appear in Cast Ranking.`,
              ephemeral: true
            };
          }

          // Get first application for initial display
          const currentApp = allApplications[0];
          const appIndex = 0;
          
          // Fetch the applicant as a guild member to get their current avatar
          let applicantMember;
          try {
            applicantMember = await guild.members.fetch(currentApp.userId);
            console.log('üîç DEBUG: Successfully fetched applicant member:', applicantMember.displayName || applicantMember.user.username);
          } catch (error) {
            console.log('üîç DEBUG: Could not fetch applicant member, using fallback:', error.message);
            // Fallback: create a basic user object for avatar URL generation
            applicantMember = {
              displayName: currentApp.displayName,
              user: { username: currentApp.username },
              displayAvatarURL: () => currentApp.avatarURL || `https://cdn.discordapp.com/embed/avatars/${currentApp.userId % 5}.png`
            };
          }
          
          // Import and use the new castRankingManager for UI generation
          const { generateSeasonAppRankingUI } = await import('./castRankingManager.js');
          
          console.log('üîß PHASE 2 TEST: Using castRankingManager for UI generation');
          const uiResponse = await generateSeasonAppRankingUI({
            guildId,
            userId,
            configId,
            allApplications,
            currentApp,
            appIndex,
            applicantMember,
            guild,
            seasonName,
            playerData
          });
          
          console.log(`‚úÖ SUCCESS: season_app_ranking - castRankingManager generated interface`);
          return uiResponse;
        }
      })(req, res, client);
    } else if (custom_id === 'prod_setup_tycoons') {
      // Execute same logic as setup_tycoons slash command
      try {
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        const userId = req.body.member.user.id;

        // Check admin permissions
        const member = await guild.members.fetch(userId);
        if (!member.permissions.has(PermissionFlagsBits.ManageRoles) && 
            !member.permissions.has(PermissionFlagsBits.ManageChannels) && 
            !member.permissions.has(PermissionFlagsBits.ManageGuild)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå You need Manage Roles, Manage Channels, or Manage Server permissions to use this feature.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Call the original handleSetupTycoons function to get the detailed role output
        const result = await handleSetupTycoons(guild);
        
        // Create the full response with original detailed output + new summary
        const responseMessage = `Tycoons roles have been created successfully. Here are the role IDs in the format you requested:

${result.formattedOutput}

## Tycoons Setup Complete!

‚úÖ **Created roles:**
‚Ä¢ Host
‚Ä¢ Juror
‚Ä¢ Spectator
‚Ä¢ Pre-Jury

Your server is now ready for Tycoons gameplay!`;

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: responseMessage,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error handling prod_setup_tycoons button:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error setting up Tycoons roles.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'refresh_tips') {
      // Refresh Tips Gallery - Upload all tip images to Discord CDN
      return ButtonHandlerFactory.create({
        id: 'refresh_tips',
        deferred: true,
        ephemeral: true,
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üí° Refreshing tips gallery for user ${context.userId}`);

          // Get current environment
          const { refreshTips, getCurrentEnvironment } = await import('./tipsGalleryManager.js');
          const env = getCurrentEnvironment();

          console.log(`üåç Current environment: ${env}`);

          // Upload all tips to Discord CDN
          const uploadCount = await refreshTips(context.client, env);

          console.log(`‚úÖ Refreshed ${uploadCount} tips for ${env}`);

          return {
            flags: (1 << 15), // IS_COMPONENTS_V2
            components: [{
              type: 17, // Container
              accent_color: 0x27ae60, // Green (success)
              components: [{
                type: 10, // Text Display
                content: `## üí° Tips Gallery Refreshed!\n\n‚úÖ Uploaded ${uploadCount} tip images to Discord CDN\nüåç Environment: **${env.toUpperCase()}**\n\nUsers will now see the latest images when clicking "View Tips"!`
              }]
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_live_analytics') {
      // Special live analytics button (MIGRATED TO FACTORY - DEFERRED PATTERN)
      return ButtonHandlerFactory.create({
        id: 'prod_live_analytics',
        deferred: true,
        ephemeral: true,
        handler: async (context) => {
          console.log(`üîç START: prod_live_analytics - user ${context.userId}`);
          
          // Security check - only allow specific Discord ID
          if (context.userId !== '391415444084490240') {
            console.log(`‚ùå ACCESS DENIED: prod_live_analytics - user ${context.userId} not authorized`);
            return {
              content: '‚ùå Access denied. This feature is restricted.'
            };
          }

          console.log('‚úÖ DEBUG: Live analytics user authorized...');

          // Import fs and capture live analytics output
          const fs = await import('fs');
          const { getLogFilePath } = await import('./src/analytics/analyticsLogger.js');
          
          const ANALYTICS_LOG_FILE = getLogFilePath();
          
          // Function to format analytics line with Markdown
          function formatAnalyticsLine(line) {
            // Parse format: [8:33AM] Thu 19 Jun 25 | User (username) in Server Name (1234567890) | ACTION_TYPE | details
            const match = line.match(/^(\[[\d:APM]+\]\s+\w{3}\s+\d{1,2}\s+\w{3}\s+\d{2})\s+\|\s+(.+?)\s+in\s+(.+?)\s+\((\d+)\)\s+\|\s+([\w_]+)\s+\|\s+(.+)$/);
            
            if (!match) {
              return line; // Return original if parsing fails
            }
            
            const [, timestamp, user, serverName, serverId, actionType, details] = match;
            
            // Format components with Markdown
            const formattedUser = `**\`${user}\`**`;
            const formattedServer = `__\`${serverName}\`__`;
            
            // Format the action details based on action type
            let formattedDetails;
            if (actionType === 'SLASH_COMMAND') {
              // Bold the entire command for slash commands (e.g., **/menu**)
              formattedDetails = `**${details}**`;
            } else if (actionType === 'BUTTON_CLICK') {
              // For button clicks, bold just the button name (first part before parentheses)
              const buttonMatch = details.match(/^(.+?)\s+\((.+)\)$/);
              if (buttonMatch) {
                const [, buttonName, buttonId] = buttonMatch;
                formattedDetails = `**${buttonName}** (${buttonId})`;
              } else {
                // Fallback if no parentheses found, bold the whole thing
                formattedDetails = `**${details}**`;
              }
            } else {
              // For other action types, keep details as-is
              formattedDetails = details;
            }
            
            return `${timestamp} | ${formattedUser} in ${formattedServer} (${serverId}) | ${actionType} | ${formattedDetails}`;
          }
          
          // Default buttons to filter out (same as liveAnalytics.js)
          const DEFAULT_FILTERED_BUTTONS = [
            'disabled_',
            'castlist2_nav_disabled',
          ];
          
          function shouldFilterOut(logLine, filterPatterns) {
            if (!filterPatterns || filterPatterns.length === 0) return false;
            return filterPatterns.some(pattern => logLine.includes(pattern));
          }
          
          function isWithinRecentDays(logLine, days) {
            if (!days) return true;
            
            // Match format: [8:18AM] Thu 19 Jun 25
            const timestampMatch = logLine.match(/^\[(\d{1,2}:\d{2}[AP]M)\] (\w{3}) (\d{1,2}) (\w{3}) (\d{2})/);
            if (!timestampMatch) return true;
            
            const [, time, dayName, day, month, year] = timestampMatch;
            const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            const monthIndex = months.indexOf(month);
            
            if (monthIndex === -1) return true;
            
            const logDate = new Date(2000 + parseInt(year), monthIndex, parseInt(day));
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - days);
            
            return logDate >= cutoffDate;
          }
          
          let analyticsOutput = 'üî¥ LIVE ANALYTICS - Last 1 Day\n';
          analyticsOutput += '‚ïê'.repeat(50) + '\n\n';
          
          if (!fs.default.existsSync(ANALYTICS_LOG_FILE)) {
            analyticsOutput += 'üìä No analytics data found yet.\n';
            analyticsOutput += 'Use CastBot to generate some interactions!';
          } else {
            const logContent = fs.default.readFileSync(ANALYTICS_LOG_FILE, 'utf8');
            const lines = logContent.split('\n').filter(line => line.trim());
            let displayedCount = 0;
            
            lines.forEach(line => {
              // Check if line matches format: [8:18AM] Thu 19 Jun 25 | ...
              if (line.match(/^\[\d{1,2}:\d{2}[AP]M\]/)) {
                if (!shouldFilterOut(line, DEFAULT_FILTERED_BUTTONS) && isWithinRecentDays(line, 1)) {
                  // Parse and format the log line with Markdown
                  const formattedLine = formatAnalyticsLine(line);
                  analyticsOutput += `* ${formattedLine}\n`;
                  displayedCount++;
                }
              }
            });
            
            if (displayedCount === 0) {
              analyticsOutput += 'üí° No interactions found in the last 1 day.\n';
              analyticsOutput += 'Try running CastBot commands to generate data!';
            } else {
              analyticsOutput += '\n' + '‚ïê'.repeat(50) + '\n';
              analyticsOutput += `üìä Displayed ${displayedCount} interactions from last 1 day`;
            }
          }
          
          // Format the output for Discord
          const formattedOutput = analyticsOutput.trim();
          
          // Split into chunks if too long (Discord has 2000 char limit)
          const chunks = [];
          const maxLength = 1900; // Leave room for formatting
          
          if (formattedOutput.length <= maxLength) {
            chunks.push(formattedOutput);
          } else {
            let remaining = formattedOutput;
            while (remaining.length > 0) {
              let chunk = remaining.substring(0, maxLength);
              // Try to break at a newline
              const lastNewline = chunk.lastIndexOf('\n');
              if (lastNewline > maxLength * 0.8) {
                chunk = remaining.substring(0, lastNewline);
                remaining = remaining.substring(lastNewline + 1);
              } else {
                remaining = remaining.substring(maxLength);
              }
              chunks.push(chunk);
            }
          }
          
          console.log('‚úÖ DEBUG: Sending live analytics response with', chunks.length, 'chunks, content length:', chunks[0].length);
          
          // Send additional chunks as follow-ups if needed (using webhook with valid token)
          for (let i = 1; i < chunks.length; i++) {
            await DiscordRequest(`webhooks/${process.env.APP_ID}/${context.token}`, {
              method: 'POST',
              body: {
                content: chunks[i]
              }
            });
          }
          
          // Return first chunk for deferred update
          console.log(`‚úÖ SUCCESS: prod_live_analytics - completed with ${chunks.length} chunks`);
          return {
            content: chunks[0]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_toggle_live_analytics') {
      // Toggle live analytics logging (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'prod_toggle_live_analytics',
        handler: async (context) => {
          console.log(`üîç START: prod_toggle_live_analytics - user ${context.userId}`);
          
          // Security check - only allow specific Discord ID
          if (context.userId !== '391415444084490240') {
            console.log(`‚ùå ACCESS DENIED: prod_toggle_live_analytics - user ${context.userId} not authorized`);
            return {
              content: 'Access denied. This feature is restricted.',
              ephemeral: true
            };
          }

          console.log('ü™µ DEBUG: Starting live analytics toggle for user:', context.userId);
          
          // Load current configuration
          const config = await loadEnvironmentConfig();
          const currentStatus = config.liveDiscordLogging.enabled;
          
          console.log('ü™µ DEBUG: Current live logging status:', currentStatus);
          
          // Toggle the status
          const newStatus = !currentStatus;
          const updatedConfig = await updateLiveLoggingStatus(newStatus);
          
          console.log('ü™µ DEBUG: New live logging status:', newStatus);
          
          // Prepare response message
          let responseMessage;
          if (newStatus) {
            // Get the correct channel ID for current environment
            const targetChannelId = await getLoggingChannelId();
            responseMessage = `‚úÖ **Live Analytics Logging ENABLED**\n\n` +
                            `üì§ Analytics events will now be posted to <#${targetChannelId}>\n` +
                            `üö´ Excluded users: ${updatedConfig.excludedUserIds.length}`;
          } else {
            responseMessage = `üî¥ **Live Analytics Logging DISABLED**\n\n` +
                            `üìÑ Only file logging will continue\n` +
                            `üö´ Discord channel logging has been paused`;
          }
          
          console.log(`‚úÖ SUCCESS: prod_toggle_live_analytics - toggled to ${newStatus}`);
          return {
            content: responseMessage,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_server_usage_stats') {
      // Server usage analytics button (MIGRATED TO FACTORY - DEFERRED PATTERN)
      return ButtonHandlerFactory.create({
        id: 'prod_server_usage_stats',
        deferred: true,
        updateMessage: false, // Post new message for visual growth tracking
        ephemeral: false, // Results should be visible
        handler: async (context) => {
          console.log(`üîç START: prod_server_usage_stats - user ${context.userId}`);
          
          // Security check - only allow specific Discord ID
          if (context.userId !== '391415444084490240') {
            console.log(`‚ùå ACCESS DENIED: prod_server_usage_stats - user ${context.userId} not authorized`);
            return {
              content: '‚ùå Access denied. This feature is restricted.'
            };
          }

          console.log('‚úÖ DEBUG: User authorized, starting background analytics processing...');
          
          // Process analytics in the background
          const { generateServerUsageSummary, formatServerUsageForDiscordV2 } = await import('./src/analytics/serverUsageAnalytics.js');
          console.log('‚úÖ DEBUG: Server usage analytics imported successfully');
          
          // Generate 6-week usage summary
          console.log('‚úÖ DEBUG: Generating server usage summary...');
          const summary = await generateServerUsageSummary(42);
          console.log('‚úÖ DEBUG: Summary generated, formatting for Discord...');
          
          // Format for Discord display - use Components V2 with page 0
          const discordResponse = await formatServerUsageForDiscordV2(summary, 0);
          
          console.log(`‚úÖ DEBUG: Formatted for Discord using Components V2, payload size:`, JSON.stringify(discordResponse).length, 'characters');
          
          // Return the response for deferred update
          return discordResponse;
        }
      })(req, res, client);
    } else if (custom_id === 'prod_ultrathink_monitor') {
      // Ultrathink production health monitor (Components V2)
      return ButtonHandlerFactory.create({
        id: 'prod_ultrathink_monitor',
        deferred: true,
        updateMessage: false,
        ephemeral: true,
        handler: async (context) => {
          // Security check - only allow specific Discord ID
          if (context.userId !== '391415444084490240') {
            return {
              content: '‚ùå Access denied. This feature is restricted.'
            };
          }

          console.log('[üåà Ultramonitor] Starting health check');

          try {
            // Import and get singleton health monitor
            const { getHealthMonitor, getMonitoringState } = await import('./src/monitoring/healthMonitor.js');
            const monitor = getHealthMonitor(context.client);

            // Collect metrics
            const metrics = await monitor.collectMetrics();
            const scores = monitor.calculateHealthScores(metrics);
            const formatted = monitor.formatForDiscord(metrics, scores);

            // Get monitoring status
            const status = monitor.getStatus();

            console.log(`[üåà Ultramonitor] Health score: ${scores.overall}/100`);

            // Build container components
            const containerComponents = formatted.content;

            // Add monitoring status if active
            if (status.active) {
              containerComponents.push(
                { type: 14 },
                {
                  type: 10,
                  content: `## ‚è∞ Scheduled Monitoring\n**Interval**: Every ${status.hours} hours\n**Next Check**: <t:${Math.floor(status.nextRun?.getTime() / 1000)}:R>`
                }
              );
            }

            // Add divider before buttons
            containerComponents.push({
              type: 14 // Separator
            });

            // Add back, refresh, and schedule buttons
            const backButton = new ButtonBuilder()
              .setCustomId('analytics_admin')
              .setLabel('‚Üê Analytics')
              .setStyle(ButtonStyle.Secondary);

            const refreshButton = new ButtonBuilder()
              .setCustomId('prod_ultrathink_monitor')
              .setLabel('Refresh')
              .setStyle(ButtonStyle.Secondary)
              .setEmoji('üîÑ');

            const scheduleButton = new ButtonBuilder()
              .setCustomId('health_monitor_schedule')
              .setLabel('Schedule')
              .setStyle(ButtonStyle.Secondary)
              .setEmoji('üìÖ');

            const actionRow = new ActionRowBuilder().addComponents(backButton, refreshButton, scheduleButton);
            containerComponents.push(actionRow.toJSON());

            console.log(`[üåà Ultramonitor] Complete - score: ${scores.overall}/100`);

            return {
              flags: (1 << 15), // IS_COMPONENTS_V2
              components: [{
                type: 17, // Container
                accent_color: formatted.healthColor,
                components: containerComponents
              }]
            };

          } catch (error) {
            console.error('[üåà Ultramonitor] Error:', error.message);
            return {
              content: `‚ùå **Error running health monitor:**\n\`\`\`\n${error.message}\n\`\`\`\nThis is likely a temporary issue. Please try again.`
            };
          }
        }
      })(req, res, client);
    } else if (custom_id === 'health_monitor_schedule') {
      // Health monitor scheduling modal
      return ButtonHandlerFactory.create({
        id: 'health_monitor_schedule',
        updateMessage: false,
        ephemeral: true,
        handler: async (context) => {
          // Security check - only allow specific Discord ID
          if (context.userId !== '391415444084490240') {
            return {
              content: '‚ùå Access denied. This feature is restricted.'
            };
          }

          console.log('[üåà Ultramonitor] Opening schedule modal');

          // Get current monitoring status
          const { getMonitoringState } = await import('./src/monitoring/healthMonitor.js');
          const status = getMonitoringState();

          // Create scheduling modal
          const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = await import('discord.js');

          const modal = new ModalBuilder()
            .setCustomId(`health_monitor_schedule_modal`)
            .setTitle('Schedule Health Monitoring');

          // Input for minutes interval (0 to disable)
          const minutesInput = new TextInputBuilder()
            .setCustomId('monitor_minutes')
            .setLabel('Monitor every X minutes (0 to disable):')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('30')
            .setValue(status.config.hours ? Math.round(status.config.hours * 60).toString() : '0')
            .setMaxLength(4)
            .setRequired(true);

          // Show current status
          const statusInput = new TextInputBuilder()
            .setCustomId('current_status')
            .setLabel('Current Status (read-only):')
            .setStyle(TextInputStyle.Paragraph)
            .setValue(status.interval ?
              `‚úÖ Active - Every ${status.config.hours} hours\nNext check: ${status.config.nextRun?.toLocaleTimeString() || 'N/A'}\nChannel: #${status.config.channelId || 'Not set'}` :
              '‚èπÔ∏è Monitoring disabled')
            .setRequired(false);

          modal.addComponents(
            new ActionRowBuilder().addComponents(minutesInput),
            new ActionRowBuilder().addComponents(statusInput)
          );

          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('server_stats_page_')) {
      // Server stats pagination handler
      return ButtonHandlerFactory.create({
        id: 'server_stats_page',
        deferred: true,
        updateMessage: true, // Update existing message instead of creating new one
        ephemeral: false, // Keep consistent with main stats display
        handler: async (context) => {
          console.log(`üîç START: server_stats_page - user ${context.userId}`);
          
          // Security check - only allow specific Discord ID
          if (context.userId !== '391415444084490240') {
            console.log(`‚ùå ACCESS DENIED: server_stats_page - user ${context.userId} not authorized`);
            return {
              content: '‚ùå Access denied. This feature is restricted.'
            };
          }
          
          // Extract page number from custom_id
          const parts = context.customId.split('_');
          const targetPage = parseInt(parts[3]);
          
          console.log(`üìä DEBUG: Navigating to page ${targetPage + 1}`);
          
          // Generate fresh summary and display requested page
          const { generateServerUsageSummary, formatServerUsageForDiscordV2 } = await import('./src/analytics/serverUsageAnalytics.js');
          const summary = await generateServerUsageSummary(42);
          const discordResponse = await formatServerUsageForDiscordV2(summary, targetPage);
          
          console.log(`‚úÖ SUCCESS: server_stats_page - displayed page ${targetPage + 1}`);
          return discordResponse;
        }
      })(req, res, client);
    } else if (custom_id === 'prod_all_servers' || custom_id.startsWith('all_servers_page_')) {
      // All Servers listing - shows every guild the bot is installed in
      return ButtonHandlerFactory.create({
        id: custom_id.startsWith('all_servers_page_') ? 'all_servers_page' : 'prod_all_servers',
        deferred: true,
        updateMessage: custom_id.startsWith('all_servers_page_'), // Update for pagination, new msg for initial
        ephemeral: true,
        handler: async (context) => {
          if (context.userId !== '391415444084490240') {
            return { content: '‚ùå Access denied. This feature is restricted.' };
          }

          const currentPage = custom_id.startsWith('all_servers_page_')
            ? parseInt(custom_id.split('_')[3])
            : 0;

          const { loadPlayerData } = await import('./storage.js');
          const playerData = await loadPlayerData();

          // Build server list from guild cache + playerData
          const servers = [];
          for (const guild of context.client.guilds.cache.values()) {
            const pd = playerData[guild.id] || {};
            servers.push({
              id: guild.id,
              name: guild.name,
              memberCount: guild.memberCount,
              ownerId: guild.ownerId,
              ownerInfo: pd.ownerInfo || null,
              description: guild.description || null,
              preferredLocale: guild.preferredLocale || 'en-US',
              createdAt: guild.createdTimestamp,
              firstInstalled: pd.firstInstalled || null,
              lastUpdated: pd.lastUpdated || null,
              partnered: guild.partnered || false,
              verified: guild.verified || false,
              playerCount: pd.players ? Object.keys(pd.players).length : 0,
              tribeCount: pd.tribes ? Object.keys(pd.tribes).length : 0,
              hasTimezones: pd.timezones ? Object.keys(pd.timezones).length > 0 : false,
              hasPronounRoles: pd.pronounRoleIDs?.length > 0 || false,
              hasReactionMappings: pd.reactionMappings ? Object.keys(pd.reactionMappings).length > 0 : false,
              hasApplications: pd.applications ? Object.keys(pd.applications).length > 0 : false,
              castlistCount: pd.castlists ? Object.keys(pd.castlists).length : 0
            });
          }

          // Sort by member count descending
          servers.sort((a, b) => b.memberCount - a.memberCount);

          const SERVERS_PER_PAGE = 5;
          const totalPages = Math.max(1, Math.ceil(servers.length / SERVERS_PER_PAGE));
          const validPage = Math.max(0, Math.min(currentPage, totalPages - 1));
          const startIndex = validPage * SERVERS_PER_PAGE;
          const endIndex = Math.min(startIndex + SERVERS_PER_PAGE, servers.length);
          const pageServers = servers.slice(startIndex, endIndex);

          const containerComponents = [];

          // Header
          containerComponents.push({
            type: 10,
            content: `## üåê All Servers | ${servers.length} total\nPage ${validPage + 1}/${totalPages} ‚Ä¢ Sorted by member count`
          });

          // Render each server
          for (const server of pageServers) {
            containerComponents.push({ type: 14 }); // Separator

            let details = `### ${server.name}\n`;
            details += `üë• **${server.memberCount.toLocaleString()}** members`;
            if (server.verified) details += ' ‚Ä¢ ‚úÖ Verified';
            if (server.partnered) details += ' ‚Ä¢ ü§ù Partnered';
            details += '\n';

            // Owner
            if (server.ownerInfo) {
              const ownerDisplay = server.ownerInfo.globalName || server.ownerInfo.username;
              details += `üëë Owner: **${ownerDisplay}** (@${server.ownerInfo.username})\n`;
            } else {
              details += `üëë Owner ID: \`${server.ownerId}\`\n`;
            }

            // Locale & Description
            details += `üåç Locale: \`${server.preferredLocale}\``;
            if (server.description) {
              const desc = server.description.length > 80
                ? server.description.substring(0, 80) + '...'
                : server.description;
              details += ` ‚Ä¢ üìù ${desc}`;
            }
            details += '\n';

            // Dates
            const createdDate = new Date(server.createdAt).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            details += `üìÖ Created: \`${createdDate}\``;
            if (server.firstInstalled) {
              const installedDate = new Date(server.firstInstalled).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
              details += ` ‚Ä¢ ü§ñ Bot installed: \`${installedDate}\``;
            }
            if (server.lastUpdated) {
              const updatedDate = new Date(server.lastUpdated).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
              details += ` ‚Ä¢ üîÑ Updated: \`${updatedDate}\``;
            }
            details += '\n';

            // Features in use
            const features = [];
            if (server.playerCount > 0) features.push(`üéÆ ${server.playerCount} players`);
            if (server.tribeCount > 0) features.push(`üèïÔ∏è ${server.tribeCount} tribes`);
            if (server.castlistCount > 0) features.push(`üìã ${server.castlistCount} castlists`);
            if (server.hasTimezones) features.push('üïê Timezones');
            if (server.hasPronounRoles) features.push('üíú Pronouns');
            if (server.hasReactionMappings) features.push('‚ú® Reactions');
            if (server.hasApplications) features.push('üìù Apps');

            if (features.length > 0) {
              details += `‚öôÔ∏è ${features.join(' ‚Ä¢ ')}`;
            } else {
              details += `‚öôÔ∏è No features configured`;
            }

            // Guild ID (small text)
            details += `\n-# ID: ${server.id}`;

            containerComponents.push({ type: 10, content: details });
          }

          // Pagination buttons
          if (totalPages > 1) {
            containerComponents.push({ type: 14 }); // Separator

            const paginationButtons = [];
            if (totalPages <= 5) {
              for (let page = 0; page < totalPages; page++) {
                const start = (page * SERVERS_PER_PAGE) + 1;
                const end = Math.min((page + 1) * SERVERS_PER_PAGE, servers.length);
                paginationButtons.push({
                  type: 2,
                  custom_id: `all_servers_page_${page}`,
                  label: `${start}-${end}`,
                  style: page === validPage ? 1 : 2,
                  disabled: page === validPage
                });
              }
            } else {
              const pagesToShow = new Set([0, totalPages - 1, validPage]);
              if (validPage > 0) pagesToShow.add(validPage - 1);
              if (validPage < totalPages - 1) pagesToShow.add(validPage + 1);
              const sorted = Array.from(pagesToShow).sort((a, b) => a - b).slice(0, 5);
              for (const page of sorted) {
                const start = (page * SERVERS_PER_PAGE) + 1;
                const end = Math.min((page + 1) * SERVERS_PER_PAGE, servers.length);
                paginationButtons.push({
                  type: 2,
                  custom_id: `all_servers_page_${page}`,
                  label: `${start}-${end}`,
                  style: page === validPage ? 1 : 2,
                  disabled: page === validPage
                });
              }
            }

            containerComponents.push({
              type: 1,
              components: paginationButtons
            });
          }

          // Back + Refresh buttons
          containerComponents.push({ type: 14 });
          containerComponents.push({
            type: 1,
            components: [{
              type: 2,
              custom_id: 'analytics_admin',
              label: '‚Üê Analytics',
              style: 2
            }, {
              type: 2,
              custom_id: 'prod_all_servers',
              label: 'Refresh',
              style: 2,
              emoji: { name: 'üîÑ' }
            }]
          });

          return {
            flags: (1 << 15),
            components: [{
              type: 17,
              accent_color: 0x3498DB,
              components: containerComponents
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'test_role_hierarchy') {
      // Test role hierarchy functionality (MIGRATED TO FACTORY - DEFERRED PATTERN)
      return ButtonHandlerFactory.create({
        id: 'test_role_hierarchy',
        deferred: true,
        ephemeral: true,
        handler: async (context) => {
          // Security check - only allow specific Discord ID
          if (context.userId !== '391415444084490240') {
            return {
              content: 'Access denied. This feature is restricted.'
            };
          }

          console.log('üîß DEBUG: Starting role hierarchy test...');
          
          // Run the test function with your specified roles
          const testResults = await testRoleHierarchy(context.guild, context.client);
          
          // Handle potential errors
          if (testResults.error) {
            return {
              content: `‚ùå **Error:** ${testResults.error}\n\nPlease ensure CastBot is properly configured in this server.`
            };
          }

          // Create comprehensive response
          const responseLines = [
            '# üîß Role Hierarchy Test Results',
            '',
            `**Tests Run:** ${testResults.totalRoles || testResults.details.length}`,
            `**Passed:** ${testResults.testsPassed} ‚úÖ`,
            `**Failed:** ${testResults.testsFailed} ‚ùå`,
            ''
          ];

          // Add detailed results for each test - limit to first 10 to avoid message size limits
          const detailsToShow = testResults.details.slice(0, 10);
          for (const test of detailsToShow) {
            const statusEmoji = test.passed ? '‚úÖ' : '‚ùå';
            responseLines.push(`${statusEmoji} **${test.roleName}** (${test.category})`);
            responseLines.push(`   Expected: ${test.expected}, Got: ${test.actual}`);
            responseLines.push(`   Position: ${test.rolePosition} (Bot: ${test.botPosition})`);
            if (test.details) {
              responseLines.push(`   Details: ${test.details}`);
            }
            responseLines.push('');
          }

          // Add notice if there are more results
          if (testResults.details.length > 10) {
            responseLines.push(`*Showing first 10 of ${testResults.details.length} results. Check logs for complete results.*`);
            responseLines.push('');
          }

          // Add individual role checks using the new general-purpose function
          responseLines.push('## üîç Individual Role Analysis');
          responseLines.push('');

          const testRoleIds = ['1335645022774886490', '1385964464393949276'];
          for (const roleId of testRoleIds) {
            const check = canBotManageRole(context.guild, roleId, context.client);
            const statusEmoji = check.canManage ? '‚úÖ' : '‚ö†Ô∏è';
            
            responseLines.push(`${statusEmoji} **Role:** ${check.targetRoleName} (ID: ${roleId})`);
            responseLines.push(`   **Can Manage:** ${check.canManage}`);
            responseLines.push(`   **Bot Role:** ${check.botRoleName} (position ${check.botPosition})`);
            responseLines.push(`   **Target Role:** ${check.targetRoleName} (position ${check.targetPosition})`);
            responseLines.push(`   **Position Difference:** ${check.positionDifference}`);
            
            if (!check.canManage && !check.error) {
              responseLines.push('   **Warning:** This role cannot be assigned to users!');
            }
            
            responseLines.push('');
          }

          // Join response and truncate if necessary to avoid Discord's 2000 char limit
          let response = responseLines.join('\n');
          if (response.length > 1990) {
            response = response.substring(0, 1987) + '...';
            console.log(`‚ö†Ô∏è Response truncated from ${responseLines.join('\n').length} to 1990 characters`);
          }
          
          console.log(`‚úÖ SUCCESS: test_role_hierarchy - completed with ${responseLines.length} lines`);
          return {
            content: response
          };
        }
      })(req, res, client);
    } else if (custom_id === 'admin_dst_toggle') {
      // DST Toggle Manager - allows manual DST state changes for timezones
      return ButtonHandlerFactory.create({
        id: 'admin_dst_toggle',
        ephemeral: true,
        handler: async (context) => {
          // Security check - only allow specific Discord ID
          if (context.userId !== '391415444084490240') {
            return {
              content: 'Access denied. This feature is restricted.'
            };
          }

          console.log('üåç DEBUG: Opening DST Manager interface');

          // Load DST state and playerData to get timezone roles
          const { loadDSTState, loadPlayerData } = await import('./storage.js');
          const dstState = await loadDSTState();
          const playerData = await loadPlayerData();
          const guildData = playerData[context.guildId] || {};
          const timezones = guildData.timezones || {};

          // Get timezone roles that use the new DST system (deduplicated by timezoneId)
          const seenTimezoneIds = new Set();
          const dstTimezones = [];
          for (const [roleId, tzData] of Object.entries(timezones)) {
            if (tzData.timezoneId && dstState[tzData.timezoneId]) {
              // Only add each unique timezoneId once to dropdown
              if (!seenTimezoneIds.has(tzData.timezoneId)) {
                seenTimezoneIds.add(tzData.timezoneId);
                const tzInfo = dstState[tzData.timezoneId];
                dstTimezones.push({
                  timezoneId: tzData.timezoneId,
                  currentState: tzInfo.isDST ? 'Daylight' : 'Standard',
                  currentOffset: tzInfo.currentOffset,
                  displayName: tzInfo.displayName,
                  emoji: tzInfo.isDST ? '‚òÄÔ∏è' : '‚ùÑÔ∏è'
                });
              }
            }
          }

          // Check if server has any DST-aware timezones
          if (dstTimezones.length === 0) {
            return {
              content: '‚ö†Ô∏è **No DST-aware timezones found**\n\nThis server doesn\'t have any timezone roles using the new DST system.\n\nTo enable DST management:\n1. Run `/menu` ‚Üí Production Menu ‚Üí Initial Setup\n2. Timezones will be migrated to the new system\n3. Return here to toggle DST states',
              ephemeral: true
            };
          }

          // Create dropdown options for each timezone
          const options = dstTimezones.map(tz => ({
            label: `${tz.timezoneId}: ${tz.displayName}`,
            value: tz.timezoneId,
            description: `Currently: ${tz.currentState} (UTC${tz.currentOffset >= 0 ? '+' : ''}${tz.currentOffset})`,
            emoji: { name: tz.currentState === 'Daylight' ? '‚òÄÔ∏è' : '‚ùÑÔ∏è' }
          }));

          // Create Components V2 string select for timezone selection
          const timezoneSelect = {
            type: 3, // String Select
            custom_id: 'dst_timezone_select',
            placeholder: 'Choose timezone to toggle DST...',
            min_values: 1,
            max_values: 1,
            options: options.slice(0, 25) // Discord limit is 25 options
          };

          const selectRow = {
            type: 1, // Action Row
            components: [timezoneSelect]
          };

          // Build the response with Components V2 Container
          const containerComponents = [
            {
              type: 10, // Text Display
              content: `## üåç DST Toggle Manager\n\nSelect a timezone to toggle between Standard and Daylight Saving Time.\n\n**Available Timezones:** ${dstTimezones.length}`
            },
            selectRow
          ];

          const container = {
            type: 17, // Container
            components: containerComponents
          };

          return {
            flags: (1 << 15), // IS_COMPONENTS_V2
            components: [container],
            ephemeral: true
          };
        }
      })(req, res, client);
    // merge_timezone_roles removed ‚Äî superseded by setup_castbot which includes timezone consolidation
    } else if (custom_id === 'nuke_roles') {
      // Nuke Discord roles for current guild - shows confirmation dialog (DELEGATED TO MODULE)
      return ButtonHandlerFactory.create({
        id: 'nuke_roles',
        updateMessage: true,
        handler: async (context) => {
          const { handleNukeRequest } = await import('./dataNuker.js');
          return handleNukeRequest('roles', context);
        }
      })(req, res, client);
    } else if (custom_id === 'nuke_roles_confirm') {
      // Confirm and execute the roles nuke - uses deferred due to deletion time (DELEGATED TO MODULE)
      return ButtonHandlerFactory.create({
        id: 'nuke_roles_confirm',
        deferred: true,
        ephemeral: true,
        handler: async (context) => {
          const { handleNukeConfirm } = await import('./dataNuker.js');
          return handleNukeConfirm('roles', context);
        }
      })(req, res, client);
    } else if (custom_id === 'nuke_roles_cancel') {
      // Cancel the roles nuke operation - return to analytics_admin
      return ButtonHandlerFactory.create({
        id: 'nuke_roles_cancel',
        updateMessage: true,
        handler: async (context) => {
          // Return to Reece Stuff menu (admin menu)
          const reeceMenuData = await createReeceStuffMenu(context.guildId, context.channelId);

          return {
            ...reeceMenuData,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_create_button') {
      // Handle Create Custom Button - show initial modal
      console.log('üîç DEBUG: safari_create_button handler reached');
      try {
        const member = req.body.member;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to create custom buttons.')) return;

        console.log('üìù DEBUG: Create Custom Button clicked');
        
        // Create button creation modal
        const modal = new ModalBuilder()
          .setCustomId('safari_button_modal')
          .setTitle('Create Custom Button');

        // Button label input
        const labelInput = new TextInputBuilder()
          .setCustomId('button_label')
          .setLabel('Button Label')
          .setPlaceholder('e.g., "Start Adventure"')
          .setStyle(TextInputStyle.Short)
          .setRequired(true)
          .setMaxLength(80);

        // Button emoji input
        const emojiInput = new TextInputBuilder()
          .setCustomId('button_emoji')
          .setLabel('Button Emoji (optional)')
          .setPlaceholder('e.g., üó∫Ô∏è or <:custom:123456>')
          .setStyle(TextInputStyle.Short)
          .setRequired(false)
          .setMaxLength(100);

        // Button description input
        const descInput = new TextInputBuilder()
          .setCustomId('button_description')
          .setLabel('Button Description (for your reference)')
          .setPlaceholder('e.g., "Starts the jungle adventure safari"')
          .setStyle(TextInputStyle.Paragraph)
          .setRequired(false);

        const labelRow = new ActionRowBuilder().addComponents(labelInput);
        const emojiRow = new ActionRowBuilder().addComponents(emojiInput);
        const descRow = new ActionRowBuilder().addComponents(descInput);

        modal.addComponents(labelRow, emojiRow, descRow);
        
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal.toJSON()
        });
        
      } catch (error) {
        console.error('Error in safari_create_button:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error creating custom button.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_post_button') {
      // Handle Post Custom Button - MVP1 placeholder
      try {
        const member = req.body.member;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to post custom buttons.')) return;

        console.log('üì§ DEBUG: Post Custom Button clicked');
        
        const guildId = req.body.guild_id;
        console.log('üì§ DEBUG: Guild ID:', guildId);
        
        // Import Safari manager functions
        console.log('üì§ DEBUG: Importing safariManager...');
        const { listCustomButtons } = await import('./safariManager.js');
        console.log('üì§ DEBUG: safariManager imported successfully');
        
        // Get all custom buttons for this guild
        console.log('üì§ DEBUG: Listing custom buttons for guild...');
        const buttons = await listCustomButtons(guildId);
        console.log('üì§ DEBUG: Found buttons:', buttons.length);
        
        if (buttons.length === 0) {
          console.log('üì§ DEBUG: No buttons found, returning error message');
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå **No custom buttons found**\n\nCreate a custom button first using **üìù Create Custom Button**.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Create working button selection interface
        console.log('üì§ DEBUG: Creating working button selection interface...');
        
        // Create button selection dropdown (limit to 25 options for Discord)
        const buttonOptions = buttons.slice(0, 25).map(button => ({
          label: button.label.substring(0, 100), // Ensure label length is valid
          value: button.id,
          description: `${button.actions.length} action${button.actions.length !== 1 ? 's' : ''}`.substring(0, 100)
        }));
        
        const buttonSelect = new StringSelectMenuBuilder()
          .setCustomId('safari_post_select_button')
          .setPlaceholder('Choose a button to post...')
          .addOptions(buttonOptions);
        
        const selectRow = new ActionRowBuilder().addComponents(buttonSelect);
        
        // Create cancel button
        const cancelButton = new ButtonBuilder()
          .setCustomId('prod_safari_menu')
          .setLabel('Cancel')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji('‚ùå');
        
        const cancelRow = new ActionRowBuilder().addComponents(cancelButton);
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `## üì§ Post Custom Button\n\nSelect a button to post to a channel:\n\n**Available Buttons:** ${buttons.length}`,
            components: [selectRow, cancelRow],
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in safari_post_button:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error posting custom button.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_manage_currency') {
      // Handle Manage Currency - MVP1 placeholder (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_manage_currency',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        ephemeral: true,
        handler: async (context) => {
          console.log('üí∞ DEBUG: Manage Currency clicked');
          
          // Import Safari manager functions
          const { loadSafariContent } = await import('./safariManager.js');
          const playerData = await loadPlayerData();
          
          // Get all players with safari currency data
          const guildPlayers = playerData[context.guildId]?.players || {};
          const playersWithCurrency = Object.entries(guildPlayers)
            .filter(([userId, player]) => player.safari?.currency !== undefined)
            .sort(([, a], [, b]) => (b.safari?.currency || 0) - (a.safari?.currency || 0)); // Sort by currency desc
          
          // Create currency management buttons
          const managementButtons = [
            new ButtonBuilder()
              .setCustomId('safari_currency_view_all')
              .setLabel('View All Balances')
              .setStyle(ButtonStyle.Primary)
              .setEmoji('üë•'),
            new ButtonBuilder()
              .setCustomId('safari_currency_set_player')
              .setLabel('Set Player Currency')
              .setStyle(ButtonStyle.Secondary)
              .setEmoji('üí∞'),
            new ButtonBuilder()
              .setCustomId('safari_currency_reset_all')
              .setLabel('Reset All Currency')
              .setStyle(ButtonStyle.Danger)
              .setEmoji('üóëÔ∏è')
          ];
          
          const managementRow = new ActionRowBuilder().addComponents(managementButtons);

          // Create back button
          const backButton = new ButtonBuilder()
            .setCustomId('prod_menu_back')
            .setLabel('‚Üê Menu')
            .setStyle(ButtonStyle.Secondary);

          const backRow = new ActionRowBuilder().addComponents(backButton);
          
          // Create summary content
          const totalPlayers = playersWithCurrency.length;
          const totalCurrency = playersWithCurrency.reduce((sum, [, player]) => sum + (player.safari?.currency || 0), 0);
          const averageCurrency = totalPlayers > 0 ? Math.round(totalCurrency / totalPlayers) : 0;
          
          // Show top players (limit to 5)
          let topPlayersText = '';
          if (totalPlayers > 0) {
            const topPlayers = playersWithCurrency.slice(0, 5);
            topPlayersText = topPlayers.map(([userId, player], index) => {
              const rank = index + 1;
              const currency = player.safari?.currency || 0;
              return `**${rank}.** <@${userId}> - ${currency} coins`;
            }).join('\n');
          } else {
            topPlayersText = '*No players have currency yet.*';
          }
          
          // Create response with Components V2
          const containerComponents = [
            {
              type: 10, // Text Display component
              content: `## üí∞ Manage Currency\n\nUse the currency feature in Challenges, Idol Hunts or Safari. You can use it combination with the Stores and Items feature for an economy system.\n\nYou can manually assign players currency, or use the Actions system to automate currency collection. You can also update currency from the üß≠ \`Player Admin\` menu, and configure currency in the ‚öôÔ∏è \`Customize\` menu.`
            },
            {
              type: 10, // Text Display component
              content: `> **Players with Currency:** ${totalPlayers}\n> **Total Currency:** ${totalCurrency} coins\n> **Average per Player:** ${averageCurrency} coins`
            },
            {
              type: 10, // Text Display component
              content: `**üèÜ Top Players:**\n${topPlayersText}`
            },
            {
              type: 14 // Separator
            },
            managementRow.toJSON(), // Currency management buttons
            {
              type: 14 // Separator
            },
            backRow.toJSON() // Back button
          ];
          
          const container = {
            type: 17, // Container component
            accent_color: 0xf1c40f, // Gold accent color for currency theme
            components: containerComponents
          };
          
          return {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + Ephemeral
            components: [container]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_round_results') {
      // Handle Round Results - Player-Centric Card Display with Components V2 (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_round_results',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        deferred: true,
        ephemeral: false,  // Round results should be visible to all players
        handler: async (context) => {
          console.log(`üé® DEBUG: Processing round results for guild ${context.guildId} in channel ${context.channelId}`);
          
          // Import Safari manager functions
          const { processRoundResults } = await import('./safariManager.js');
          
          // Process round results using modern display - pass token and client for player names
          const roundData = await processRoundResults(context.guildId, context.token, context.client);
          
          // If roundData is null, it means the function already handled sending the response
          if (roundData === null) {
            console.log(`üé® DEBUG: Round results handled via followup messages`);
            return null; // Tell factory not to send another response
          }
          
          // Otherwise return the error response
          console.log(`üé® DEBUG: Sending error response with ${roundData?.data?.components?.length || 0} components${roundData?.data?.content ? ' and content message' : ''}`);
          
          // Return the round data - factory will handle webhook followup
          // Don't include content field if Components V2 flag is set
          const response = {
            flags: roundData.data.flags || 0,
            components: roundData.data.components
          };
          
          // Only add content if NOT using Components V2
          if (!(roundData.data.flags & (1 << 15))) {
            response.content = roundData.data.content;
          }
          
          return response;
        }
      })(req, res, client);
    } else if (custom_id === 'safari_confirm_reset_game') {
      return ButtonHandlerFactory.create({
        id: 'safari_confirm_reset_game',
        ephemeral: true,
        handler: async (context) => {
          // Check admin permissions
          const hasPermission = context.member?.permissions && 
            (BigInt(context.member.permissions) & BigInt(PERMISSIONS.MANAGE_ROLES)) !== 0n;
          
          if (!hasPermission) {
            return {
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå You need Manage Roles permission to reset the game.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            };
          }
          
          console.log(`üîÑ DEBUG: Confirming game reset for guild ${context.guildId}`);
          
          // Import Safari manager functions
          const { resetGameData } = await import('./safariManager.js');
          
          // Reset game data and get the result response
          const result = await resetGameData(context.guildId);
          
          // Log the action
          await logInteraction(
            context.userId,
            context.guildId,
            'BUTTON_CLICK',
            'safari_confirm_reset_game',
            context.username,
            'Unknown Server',
            null,
            context.channelName || null
          );
          
          return result;
        }
      })(req, res, client);
    } else if (custom_id === 'safari_restock_players') {
      // Handle Restock Players - Set all eligible players currency to 100
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to restock players.')) return;
        
        console.log(`ü™£ DEBUG: Restocking players for guild ${guildId}`);
        
        // Import Safari manager functions
        const { restockPlayers } = await import('./safariManager.js');
        
        // Restock players and get the result response
        const result = await restockPlayers(guildId, client);
        
        // Log the action
        await logInteraction(
          req.body.member.user.id,
          guildId,
          'BUTTON_CLICK',
          'safari_restock_players',
          req.body.member.user.username,
          'Unknown Server',
          null,
          req.body.channel?.name || null
        );
        
        return res.send(result);
        
      } catch (error) {
        console.error('Error in safari_restock_players:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error restocking players. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_view_buttons') {
      // Handle View All Buttons - MVP1 implementation
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to view custom buttons.')) return;

        console.log('üìä DEBUG: View All Buttons clicked');
        
        // Import safari manager and list buttons
        const { listCustomButtons } = await import('./safariManager.js');
        const buttons = await listCustomButtons(guildId);
        
        let content = '## üìä Custom Buttons\n\n';
        
        if (buttons.length === 0) {
          content += '*No custom buttons created yet.*\n\nUse **Create Custom Button** to get started!';
        } else {
          buttons.forEach((button, index) => {
            const createdDate = new Date(button.metadata.createdAt).toLocaleDateString();
            content += `**${index + 1}.** ${button.label} ${button.emoji || ''}\n`;
            content += `‚îî Created: ${createdDate} | Actions: ${button.actions.length} | Used: ${button.metadata.usageCount} times\n\n`;
          });
        }
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: content,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in safari_view_buttons:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error viewing custom buttons.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    // RESTORED 2025-10-20: Handler was commented out 2025-01-19, but button still exists in 10 locations
    // (playerManagement.js, safariManager.js, app.js) causing "interaction failed" errors
    } else if (custom_id === 'safari_player_inventory') {
      // Handle "My Inventory" player inventory display (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_player_inventory',
        handler: async (context) => {
          console.log(`ü•ö DEBUG: User ${context.userId} viewing inventory in guild ${context.guildId}`);

          // Start at page 0 when opening inventory
          const inventoryDisplay = await createPlayerInventoryDisplay(context.guildId, context.userId, context.member, 0);

          console.log(`üì§ DEBUG: About to send inventory response for user ${context.userId}`);
          console.log(`üìã DEBUG: Data keys: ${Object.keys(inventoryDisplay)}`);

          return inventoryDisplay;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_attack_player_disabled_')) {
      // Handle disabled attack button click
      console.log(`‚öîÔ∏è DEBUG: User clicked disabled attack button`);
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: '‚ùå You have no attacks available for this item. Attacks will be available again after the next round results.',
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    } else if (custom_id.startsWith('safari_attack_player_')) {
      // Handle attack player button click with deferred response (takes >3s due to Discord API lookups)
      return ButtonHandlerFactory.create({
        id: 'safari_attack_player',
        deferred: true, // Required - fetching 20+ player names from Discord API takes >3 seconds
        handler: async (context) => {
          const itemId = context.customId.replace('safari_attack_player_', '');

          console.log(`‚öîÔ∏è START: safari_attack_player - user ${context.userId} attacking with item ${itemId}`);

          try {
            // Import attack system functions
            const { createAttackPlanningUI } = await import('./safariManager.js');

            // Create attack planning UI (slow - fetches all player names from Discord)
            const response = await createAttackPlanningUI(context.guildId, context.userId, itemId, client);

            console.log(`‚úÖ SUCCESS: safari_attack_player - created attack UI for ${itemId}`);

            // Unwrap response for deferred pattern (ButtonHandlerFactory expects just the data, not {type, data})
            return response.data || response;

          } catch (error) {
            console.error(`‚ùå ERROR: safari_attack_player - ${error.message}`);
            return {
              content: '‚ùå Error loading attack interface.',
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_use_item_')) {
      // Handle consumable item use (stamina boost)
      return ButtonHandlerFactory.create({
        id: 'safari_use_item',
        handler: async (context) => {
          const itemId = context.customId.replace('safari_use_item_', '');
          console.log(`‚ö° START: safari_use_item - user ${context.userId} using item ${itemId}`);
          
          const { loadPlayerData, savePlayerData } = await import('./storage.js');
          const { loadSafariContent } = await import('./safariManager.js');
          const { addBonusPoints, getEntityPoints } = await import('./pointsManager.js');
          
          const playerData = await loadPlayerData();
          const safariData = await loadSafariContent();
          
          // Get player's inventory
          const player = playerData[context.guildId]?.players?.[context.userId];
          if (!player?.safari?.inventory?.[itemId]) {
            return {
              content: '‚ùå You do not have this item in your inventory.',
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }
          
          // Get item data
          const item = safariData[context.guildId]?.items?.[itemId];
          if (!item) {
            return {
              content: '‚ùå Item not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }
          
          // Verify item is consumable and has stamina boost
          if (item.consumable !== 'Yes' || !item.staminaBoost || item.staminaBoost <= 0) {
            return {
              content: '‚ùå This item cannot be used.',
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }
          
          // Get current stamina
          const entityId = `player_${context.userId}`;
          const currentStamina = await getEntityPoints(context.guildId, entityId, 'stamina');
          
          // Apply stamina boost
          const newStamina = await addBonusPoints(context.guildId, entityId, 'stamina', item.staminaBoost);
          
          // Consume the item (reduce quantity by 1)
          const inventoryItem = player.safari.inventory[itemId];
          if (typeof inventoryItem === 'number') {
            if (inventoryItem <= 1) {
              delete player.safari.inventory[itemId];
            } else {
              player.safari.inventory[itemId] = inventoryItem - 1;
            }
          } else if (typeof inventoryItem === 'object') {
            if (inventoryItem.quantity <= 1) {
              delete player.safari.inventory[itemId];
            } else {
              inventoryItem.quantity -= 1;
            }
          }
          
          await savePlayerData(playerData);
          
          console.log(`‚úÖ SUCCESS: safari_use_item - stamina boosted from ${currentStamina.current}/${currentStamina.max} to ${newStamina.current}/${newStamina.max}`);
          
          return {
            content: `‚úÖ **Item Used!**\n\n${item.emoji || '‚ö°'} You used **${item.name}** and gained **+${item.staminaBoost} stamina**!\n\n‚ö° **Stamina:** ${currentStamina.current}/${currentStamina.max} ‚Üí ${newStamina.current}/${newStamina.max}`,
            flags: InteractionResponseFlags.EPHEMERAL
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_attack_target')) {
      // Handle target player selection
      try {
        const guildId = req.body.guild_id;
        const attackerId = req.body.member?.user?.id || req.body.user?.id;
        const targetId = req.body.data.values[0];
        
        // Parse state from custom_id: safari_attack_target|itemId|quantity (pipe-separated to avoid underscore conflicts)
        const parts = custom_id.split('|');
        const itemId = parts[1];
        const previousQuantity = parseInt(parts[2]) || 0;
        
        console.log(`‚öîÔ∏è DEBUG: Attacker ${attackerId} selected target ${targetId} for item ${itemId}, previous quantity: ${previousQuantity}`);
        
        // Update the UI with the selected target
        const { createOrUpdateAttackUI } = await import('./safariManager.js');
        const response = await createOrUpdateAttackUI(guildId, attackerId, itemId, targetId, previousQuantity, client);
        
        return res.send(response);
        
      } catch (error) {
        console.error('Error in safari_attack_target handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error selecting target.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_attack_quantity')) {
      // Handle attack quantity selection
      try {
        const guildId = req.body.guild_id;
        const attackerId = req.body.member?.user?.id || req.body.user?.id;
        const quantity = parseInt(req.body.data.values[0]);
        
        // Parse state from custom_id: safari_attack_quantity|itemId|targetId (pipe-separated to avoid underscore conflicts)
        const parts = custom_id.split('|');
        const itemId = parts[1];
        const targetId = parts[2] !== 'none' ? parts[2] : null;
        
        console.log(`‚öîÔ∏è DEBUG: Attacker ${attackerId} selected ${quantity} attacks with item ${itemId}, target: ${targetId}`);
        
        // Update the UI with the selected quantity
        const { createOrUpdateAttackUI } = await import('./safariManager.js');
        const response = await createOrUpdateAttackUI(guildId, attackerId, itemId, targetId, quantity, client);
        
        return res.send(response);
        
      } catch (error) {
        console.error('Error in safari_attack_quantity handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error selecting attack quantity.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_schedule_attack_')) {
      // Handle attack scheduling with deferred response (logging + data operations take >3s)
      return ButtonHandlerFactory.create({
        id: 'safari_schedule_attack',
        deferred: true, // Required - scheduleAttack does logging, data operations, Discord API calls
        handler: async (context) => {
          console.log(`üîç START: safari_schedule_attack - user ${context.userId}`);

          // Parse custom_id properly: safari_schedule_attack_itemId_targetId_quantity
          // Handle itemIds with underscores (e.g., raider_499497)
          const parts = context.customId.split('_');
          const itemId = parts[3] + '_' + parts[4]; // Reconstruct itemId (e.g., raider_499497)
          const targetId = parts[5] !== 'none' ? parts[5] : null;
          const quantity = parseInt(parts[6]) || 0;

          console.log(`‚öîÔ∏è DEBUG: Scheduling attack - Attacker: ${context.userId}, Item: ${itemId}, Target: ${targetId}, Quantity: ${quantity}`);

          // Schedule the attack
          const { scheduleAttack } = await import('./safariManager.js');
          const response = await scheduleAttack(context.guildId, context.userId, itemId, req.body, context.client);

          console.log(`‚úÖ SUCCESS: safari_schedule_attack - scheduled ${quantity}x ${itemId} for target ${targetId}`);
          return response;
        }
      })(req, res, client);
    } else if (custom_id === 'safari_customize_terms') {
      // Handle "‚öôÔ∏è Customize Terms" button - NEW Components V2 Interface (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_customize_terms',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`‚öôÔ∏è DEBUG: User ${context.userId} opening Safari customization interface for guild ${context.guildId}`);
          
          // Get current custom terms
          const { getCustomTerms } = await import('./safariManager.js');
          const currentTerms = await getCustomTerms(context.guildId);
          
          // Create new Components V2 Safari customization interface
          const { createSafariCustomizationUI } = await import('./safariConfigUI.js');
          const interfaceData = await createSafariCustomizationUI(context.guildId, currentTerms);

          // Count and validate components
          const { countComponents } = await import('./utils.js');
          countComponents(interfaceData.components, {
            enableLogging: true,
            verbosity: "full",
            label: "Settings Menu (safari_customize_terms)"
          });

          return interfaceData;
        }
      })(req, res, client);
    } else if (custom_id === 'safari_configure_log') {
      // Handle Safari Log configuration button
      return ButtonHandlerFactory.create({
        id: 'safari_configure_log',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üìä DEBUG: User ${context.userId} opening Safari Log configuration for guild ${context.guildId}`);
          
          // Load current Safari log settings
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const logSettings = safariData[context.guildId]?.safariLogSettings || {
            enabled: false,
            logChannelId: null,
            productionRoleId: null,
            logTypes: {
              whispers: true,
              itemPickups: true,
              currencyChanges: true,
              storeTransactions: true,
              buttonActions: true,
              mapMovement: true,
              attacks: true,
              customActions: true
            }
          };
          
          // Create UI components
          const { ButtonBuilder, ActionRowBuilder, StringSelectMenuBuilder } = await import('discord.js');
          
          // Create enable/disable button
          const toggleButton = new ButtonBuilder()
            .setCustomId('safari_log_toggle')
            .setLabel(logSettings.enabled ? 'Disable Safari Log' : 'Enable Safari Log')
            .setStyle(logSettings.enabled ? 4 : 3) // Danger if enabled, Success if disabled
            .setEmoji(logSettings.enabled ? 'üî¥' : 'üü¢');
          
          // Create channel select button
          const channelButton = new ButtonBuilder()
            .setCustomId('safari_log_channel_select')
            .setLabel('Set Log Channel')
            .setStyle(2) // Secondary
            .setEmoji('üìù')
            .setDisabled(!logSettings.enabled);
          
          // Create log types configuration button
          const logTypesButton = new ButtonBuilder()
            .setCustomId('safari_log_types_config')
            .setLabel('Configure Log Types')
            .setStyle(2) // Secondary
            .setEmoji('‚öôÔ∏è')
            .setDisabled(!logSettings.enabled);
          
          // Create test message button
          const testButton = new ButtonBuilder()
            .setCustomId('safari_log_test')
            .setLabel('Send Test Message')
            .setStyle(2) // Secondary
            .setEmoji('üß™')
            .setDisabled(!logSettings.enabled || !logSettings.logChannelId);

          // Create back button
          const backButton = new ButtonBuilder()
            .setCustomId('safari_customize_terms')
            .setLabel('‚Üê Safari Settings')
            .setStyle(2) // Secondary
            .setEmoji('‚öôÔ∏è');
          
          const toggleRow = new ActionRowBuilder().addComponents(toggleButton);
          const configRow = new ActionRowBuilder().addComponents(channelButton, logTypesButton, testButton);
          const backRow = new ActionRowBuilder().addComponents(backButton);
          
          // Create status display
          let statusText = `## ü™µ CastBot Logs\n\n`;
          statusText += `-# Logs activity from Idol Hunts, Challenges and Safari features ‚Äî currency, items, stores, movement and more.\n\n`;
          statusText += `**Status:** ${logSettings.enabled ? 'üü¢ Enabled' : 'üî¥ Disabled'}\n`;
          statusText += `**Log Channel:** ${logSettings.logChannelId ? `<#${logSettings.logChannelId}>` : 'Not Set'}\n\n`;
          
          if (logSettings.enabled && logSettings.logChannelId) {
            statusText += `**Active Log Types:**\n`;
            const logTypeNames = {
              whispers: 'ü§´ Whispers',
              itemPickups: 'üß∞ Item Pickups',
              currencyChanges: 'ü™ô Currency Changes',
              storeTransactions: 'üõí Store Purchases',
              buttonActions: 'üéØ Safari Actions',
              mapMovement: 'üó∫Ô∏è Map Movement',
              attacks: '‚öîÔ∏è Attack Queue',
              customActions: '‚å®Ô∏è Custom Actions'
            };
            
            for (const [type, enabled] of Object.entries(logSettings.logTypes || {})) {
              if (enabled) {
                statusText += `‚Ä¢ ${logTypeNames[type] || type}\n`;
              }
            }
          }
          
          // Create Components V2 container
          const containerComponents = [
            {
              type: 10, // Text Display
              content: statusText
            },
            { type: 14 }, // Separator
            toggleRow.toJSON(),
            { type: 14 }, // Separator
            configRow.toJSON(),
            { type: 14 }, // Separator
            backRow.toJSON()
          ];
          
          const container = {
            type: 17, // Container
            accent_color: 0x9B59B6, // Purple accent
            components: containerComponents
          };
          
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2
            components: [container]
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_config_group_')) {
      // Handle field group button clicks - Currency, Events, Rounds
      try {
        const guildId = req.body.guild_id;
        const member = req.body.member;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to customize Safari terms.')) return;
        
        // Extract group key from custom_id (safari_config_group_currency -> currency)
        const groupKey = custom_id.replace('safari_config_group_', '');
        
        console.log(`‚öôÔ∏è DEBUG: Opening field group modal for ${groupKey}`);
        
        // Get current custom terms
        const { getCustomTerms } = await import('./safariManager.js');
        const currentTerms = await getCustomTerms(guildId);
        
        // Create field group modal
        const { createFieldGroupModal } = await import('./safariConfigUI.js');
        const modal = await createFieldGroupModal(groupKey, currentTerms);
        
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal.toJSON()
        });
        
      } catch (error) {
        console.error('Error in safari_config_group handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error opening customization modal. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'stamina_location_config') {
      // Handle per-server stamina & location configuration button
      return ButtonHandlerFactory.create({
        id: 'stamina_location_config',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`‚ö° DEBUG: User ${context.userId} accessing stamina & location config for guild ${context.guildId}`);

          // Get current stamina configuration (per-server with .env fallback)
          const { getStaminaConfig } = await import('./safariManager.js');
          const currentConfig = await getStaminaConfig(context.guildId);

          // Create modern Components V2 modal with Label components (4 components - under 5 limit)
          const modal = {
            custom_id: 'stamina_location_config_modal',
            title: 'Stamina Settings',
            components: [
              // Instructions
              {
                type: 10, // Text Display
                content: '### Configure Stamina Settings\n\n' +
                         'These settings control stamina for this server.\n' +
                         'Configure starting location in Rounds & Location.'
              },

              // Label 1: Starting Stamina
              {
                type: 18, // Label
                label: 'Starting Stamina',
                description: 'Initial stamina for new players (0-99)',
                component: {
                  type: 4, // Text Input
                  custom_id: 'starting_stamina',
                  style: 1, // Short
                  min_length: 1,
                  max_length: 2,
                  placeholder: currentConfig.startingStamina.toString(),
                  value: currentConfig.startingStamina.toString(),
                  required: true
                }
              },

              // Label 2: Max Stamina
              {
                type: 18, // Label
                label: 'Max Stamina',
                description: 'Maximum stamina capacity (1-99)',
                component: {
                  type: 4, // Text Input
                  custom_id: 'max_stamina',
                  style: 1, // Short
                  min_length: 1,
                  max_length: 2,
                  placeholder: currentConfig.maxStamina.toString(),
                  value: currentConfig.maxStamina.toString(),
                  required: true
                }
              },

              // Label 3: Regeneration Minutes
              {
                type: 18, // Label
                label: 'Regeneration Time (minutes)',
                description: 'Time to regenerate 1 stamina (1-1440)',
                component: {
                  type: 4, // Text Input
                  custom_id: 'regen_minutes',
                  style: 1, // Short
                  min_length: 1,
                  max_length: 4,
                  placeholder: currentConfig.regenerationMinutes.toString(),
                  value: currentConfig.regenerationMinutes.toString(),
                  required: true
                }
              }
            ]
          };

          return {
            type: InteractionResponseType.MODAL,
            data: modal
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_player_menu_config') {
      // Handle Player Menu configuration button
      return ButtonHandlerFactory.create({
        id: 'safari_player_menu_config',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üïπÔ∏è DEBUG: User ${context.userId} configuring player menu for guild ${context.guildId}`);

          // Load current safari configuration
          const { loadSafariContent, MAX_GLOBAL_STORES } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const safariConfig = safariData[context.guildId]?.safariConfig || {};

          // Determine current settings (default to true/always - 'always' is most user-friendly for new servers)
          const currentEnabled = safariConfig.enableGlobalCommands !== false;
          const currentInventoryMode = safariConfig.inventoryVisibilityMode || 'always';
          const currentShowCustomCastlists = safariConfig.showCustomCastlists !== false; // Default true (show all)
          const currentGlobalStoresMode = safariConfig.globalStoresVisibilityMode || 'always';

          // Build sorted store options for global stores select (global first, then non-global by lastModified)
          const currentGlobalStores = safariData[context.guildId]?.globalStores || [];
          const allStores = safariData[context.guildId]?.stores || {};
          const storeList = Object.values(allStores);
          const globalStoreObjects = currentGlobalStores
            .map(id => storeList.find(s => s.id === id))
            .filter(Boolean);
          const nonGlobalStoreObjects = storeList
            .filter(s => !currentGlobalStores.includes(s.id))
            .sort((a, b) => (b.metadata?.lastModified || b.metadata?.createdAt || 0) - (a.metadata?.lastModified || a.metadata?.createdAt || 0));
          const sortedStoreOptions = [...globalStoreObjects, ...nonGlobalStoreObjects]
            .slice(0, 25)
            .map(store => ({
              label: store.name,
              value: store.id,
              description: `${store.items?.length || 0} item(s)`,
              emoji: store.emoji ? { name: store.emoji } : undefined,
              default: currentGlobalStores.includes(store.id)
            }));

          // 5th modal component (global store select) ‚Äî only included if stores exist
          const globalStoreSelectComponent = sortedStoreOptions.length > 0 ? {
            type: 18, // Label (Components V2)
            label: 'üè™ Global Store Management',
            description: 'Select stores for all player menus. Max 5 Global Stores in player menus.',
            component: {
              type: 3, // String Select (Components V2)
              custom_id: 'global_stores_select_modal',
              placeholder: 'Select stores to show in player menus...',
              required: false,
              min_values: 0,
              max_values: Math.min(sortedStoreOptions.length, MAX_GLOBAL_STORES),
              options: sortedStoreOptions
            }
          } : null;

          // Create Components V2 modal with Label + String Select (following safari_store_stock pattern)
          const modal = {
            title: 'Player Menu Configuration',
            custom_id: 'safari_player_menu_config_modal',
            components: [
              {
                type: 18, // Label (Components V2)
                label: 'Show "Enter Command" button in player /menu?',
                description: 'Allow players to try commands from their /menu',
                component: {
                  type: 3, // String Select (Components V2)
                  custom_id: 'enable_global_commands',
                  placeholder: 'Choose setting...',
                  min_values: 1,
                  max_values: 1,
                  options: [
                    {
                      label: 'Yes - Show button',
                      value: 'true',
                      description: 'Players can use global commands from /menu',
                      default: currentEnabled === true
                    },
                    {
                      label: 'No - Hide button',
                      value: 'false',
                      description: 'Hide global command button from /menu',
                      default: currentEnabled === false
                    }
                  ]
                }
              },
              {
                type: 18, // Label (Components V2)
                label: 'Player Inventory Button',
                description: 'Choose when inventory button appears in /menu',
                component: {
                  type: 3, // String Select (Components V2)
                  custom_id: 'inventory_visibility_mode',
                  placeholder: 'Choose visibility mode...',
                  min_values: 1,
                  max_values: 1,
                  options: [
                    {
                      label: 'Always Show',
                      value: 'always',
                      description: 'Show inventory button to all users in /menu',
                      default: currentInventoryMode === 'always'
                    },
                    {
                      label: 'After Initialization Only',
                      value: 'initialized_only',
                      description: 'Show as soon as player joins Safari',
                      default: currentInventoryMode === 'initialized_only'
                    },
                    {
                      label: 'After 1st Initialize + 1st Round',
                      value: 'standard',
                      description: 'Show after player initialized AND Safari Rounds started',
                      default: currentInventoryMode === 'standard'
                    },
                    {
                      label: 'Never Show',
                      value: 'never',
                      description: 'Hide, only visible via shop interface',
                      default: currentInventoryMode === 'never'
                    }
                  ]
                }
              },
              {
                type: 18, // Label (Components V2)
                label: 'Show Custom Castlists in Player Menu?',
                description: 'Control which castlists appear in player /menu',
                component: {
                  type: 3, // String Select (Components V2)
                  custom_id: 'show_custom_castlists',
                  placeholder: 'Choose visibility setting...',
                  min_values: 1,
                  max_values: 1,
                  options: [
                    {
                      label: 'Show All Castlists',
                      value: 'true',
                      description: 'Display default + custom castlists',
                      default: currentShowCustomCastlists === true
                    },
                    {
                      label: 'Show Default Only',
                      value: 'false',
                      description: 'Hide custom castlists from player menu',
                      default: currentShowCustomCastlists === false
                    }
                  ]
                }
              },
              {
                type: 18, // Label (Components V2)
                label: 'Global Stores Button',
                description: 'Choose when store buttons appear in /menu',
                component: {
                  type: 3, // String Select (Components V2)
                  custom_id: 'global_stores_visibility_mode',
                  placeholder: 'Choose visibility mode...',
                  min_values: 1,
                  max_values: 1,
                  options: [
                    {
                      label: 'Always Show',
                      value: 'always',
                      description: 'Show store buttons to all users in /menu',
                      default: currentGlobalStoresMode === 'always'
                    },
                    {
                      label: 'After Initialization Only',
                      value: 'initialized_only',
                      description: 'Show as soon as player joins Safari',
                      default: currentGlobalStoresMode === 'initialized_only'
                    },
                    {
                      label: 'After 1st Initialize + 1st Round',
                      value: 'standard',
                      description: 'Show after player initialized AND Safari Rounds started',
                      default: currentGlobalStoresMode === 'standard'
                    },
                    {
                      label: 'Never Show',
                      value: 'never',
                      description: 'Hide store buttons from player menu',
                      default: currentGlobalStoresMode === 'never'
                    }
                  ]
                }
              },
              ...(globalStoreSelectComponent ? [globalStoreSelectComponent] : [])
            ]
          };

          console.log(`üïπÔ∏è DEBUG: Sending modal response`);
          return {
            type: InteractionResponseType.MODAL,
            data: modal
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_log_toggle') {
      // Handle Safari Log enable/disable toggle
      return ButtonHandlerFactory.create({
        id: 'safari_log_toggle',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîß DEBUG: User ${context.userId} toggling Safari Log for guild ${context.guildId}`);
          
          // Load and toggle Safari log settings
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          
          // Initialize if missing
          if (!safariData[context.guildId]) {
            safariData[context.guildId] = {};
          }
          if (!safariData[context.guildId].safariLogSettings) {
            safariData[context.guildId].safariLogSettings = {
              enabled: false,
              logChannelId: null,
              productionRoleId: null,
              logTypes: {
                whispers: true,
                itemPickups: true,
                currencyChanges: true,
                storeTransactions: true,
                buttonActions: true,
                mapMovement: true,
                attacks: true,
                customActions: true
              }
            };
          }
          
          // Toggle the enabled state
          const wasEnabled = safariData[context.guildId].safariLogSettings.enabled;
          safariData[context.guildId].safariLogSettings.enabled = !wasEnabled;
          
          // Save the updated settings
          await saveSafariContent(safariData);
          
          console.log(`üìä DEBUG: Safari Log ${!wasEnabled ? 'enabled' : 'disabled'} for guild ${context.guildId}`);
          
          // Return to Safari Log configuration with updated state
          // Re-execute the safari_configure_log handler logic inline
          const { ButtonBuilder, ActionRowBuilder } = await import('discord.js');
          const updatedLogSettings = safariData[context.guildId].safariLogSettings;
          
          // Create enable/disable button
          const toggleButton = new ButtonBuilder()
            .setCustomId('safari_log_toggle')
            .setLabel(updatedLogSettings.enabled ? 'Disable Safari Log' : 'Enable Safari Log')
            .setStyle(updatedLogSettings.enabled ? 4 : 3) // Danger if enabled, Success if disabled
            .setEmoji(updatedLogSettings.enabled ? 'üî¥' : 'üü¢');
          
          // Create channel select button
          const channelButton = new ButtonBuilder()
            .setCustomId('safari_log_channel_select')
            .setLabel('Set Log Channel')
            .setStyle(2) // Secondary
            .setEmoji('üìù')
            .setDisabled(!updatedLogSettings.enabled);
          
          // Create log types configuration button
          const logTypesButton = new ButtonBuilder()
            .setCustomId('safari_log_types_config')
            .setLabel('Configure Log Types')
            .setStyle(2) // Secondary
            .setEmoji('‚öôÔ∏è')
            .setDisabled(!updatedLogSettings.enabled);
          
          // Create test message button
          const testButton = new ButtonBuilder()
            .setCustomId('safari_log_test')
            .setLabel('Send Test Message')
            .setStyle(2) // Secondary
            .setEmoji('üß™')
            .setDisabled(!updatedLogSettings.enabled || !updatedLogSettings.logChannelId);
          
          // Create back button
          const backButton = new ButtonBuilder()
            .setCustomId('safari_customize_terms')
            .setLabel('‚Üê Safari Settings')
            .setStyle(2) // Secondary
            .setEmoji('‚öôÔ∏è');
          
          const toggleRow = new ActionRowBuilder().addComponents(toggleButton);
          const configRow = new ActionRowBuilder().addComponents(channelButton, logTypesButton, testButton);
          const backRow = new ActionRowBuilder().addComponents(backButton);
          
          // Create status display
          let statusText = `## ü™µ CastBot Logs\n\n`;
          statusText += `-# Logs activity from Idol Hunts, Challenges and Safari features ‚Äî currency, items, stores, movement and more.\n\n`;
          statusText += `**Status:** ${updatedLogSettings.enabled ? 'üü¢ Enabled' : 'üî¥ Disabled'}\n`;
          statusText += `**Log Channel:** ${updatedLogSettings.logChannelId ? `<#${updatedLogSettings.logChannelId}>` : 'Not Set'}\n\n`;
          
          if (updatedLogSettings.enabled && updatedLogSettings.logChannelId) {
            statusText += `**Active Log Types:**\n`;
            const logTypeNames = {
              whispers: 'ü§´ Whispers',
              itemPickups: 'üß∞ Item Pickups',
              currencyChanges: 'ü™ô Currency Changes',
              storeTransactions: 'üõí Store Purchases',
              buttonActions: 'üéØ Safari Actions',
              mapMovement: 'üó∫Ô∏è Map Movement',
              attacks: '‚öîÔ∏è Attack Queue',
              customActions: '‚å®Ô∏è Custom Actions'
            };
            
            for (const [type, enabled] of Object.entries(updatedLogSettings.logTypes || {})) {
              if (enabled) {
                statusText += `‚Ä¢ ${logTypeNames[type] || type}\n`;
              }
            }
          }
          
          // Create Components V2 container
          const containerComponents = [
            {
              type: 10, // Text Display
              content: statusText
            },
            { type: 14 }, // Separator
            toggleRow.toJSON(),
            configRow.toJSON(),
            { type: 14 }, // Separator
            backRow.toJSON()
          ];
          
          const container = {
            type: 17, // Container
            components: containerComponents
          };
          
          return {
            components: [container],
            flags: (1 << 15) // IS_COMPONENTS_V2
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_log_channel_select') {
      // Handle Safari Log channel selection
      return ButtonHandlerFactory.create({
        id: 'safari_log_channel_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üìù DEBUG: User ${context.userId} selecting Safari Log channel for guild ${context.guildId}`);
          
          // Create Components V2 container with channel select
          const container = {
            type: 17, // Container
            components: [
              {
                type: 10, // Text Display
                content: '## üìù Select Safari Log Channel\n\nChoose a channel where all Safari interactions will be logged. This should be a private channel only accessible to staff.'
              },
              { type: 14 }, // Separator
              {
                type: 1, // Action Row
                components: [{
                  type: 8, // Channel Select (Components V2)
                  custom_id: 'safari_log_channel_set',
                  placeholder: 'Select a channel for Safari logs...',
                  channel_types: [0], // Text channels only
                  min_values: 1,
                  max_values: 1
                }]
              }
            ]
          };
          
          return {
            components: [container],
            flags: (1 << 15), // IS_COMPONENTS_V2
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_log_types_config') {
      // Handle Safari Log types configuration
      return ButtonHandlerFactory.create({
        id: 'safari_log_types_config',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`‚öôÔ∏è DEBUG: User ${context.userId} configuring Safari Log types for guild ${context.guildId}`);
          
          // Load current Safari log settings
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const logSettings = safariData[context.guildId]?.safariLogSettings || {};
          const logTypes = logSettings.logTypes || {
            whispers: true,
            itemPickups: true,
            currencyChanges: true,
            storeTransactions: true,
            buttonActions: true,
            mapMovement: true,
            attacks: true
          };
          
          const { StringSelectMenuBuilder, ActionRowBuilder } = await import('discord.js');
          
          // Create multi-select menu for log types
          const logTypeOptions = [
            { label: 'Whispers', value: 'whispers', emoji: 'ü§´', description: 'Log all player whispers with full content' },
            { label: 'Item Pickups', value: 'itemPickups', emoji: 'üß∞', description: 'Log when players pick up items' },
            { label: 'Currency Changes', value: 'currencyChanges', emoji: 'ü™ô', description: 'Log currency gains and losses' },
            { label: 'Store Purchases', value: 'storeTransactions', emoji: 'üõí', description: 'Log all store transactions' },
            { label: 'Safari Actions', value: 'buttonActions', emoji: 'üéØ', description: 'Log Safari button interactions' },
            { label: 'Map Movement', value: 'mapMovement', emoji: 'üó∫Ô∏è', description: 'Log player movement on the map' },
            { label: 'Attack Queue', value: 'attacks', emoji: '‚öîÔ∏è', description: 'Log attack queue activities' },
            { label: 'Custom Actions', value: 'customActions', emoji: '‚å®Ô∏è', description: 'Log custom buttons and player commands' }
          ];
          
          // Set which options are currently selected
          const selectedValues = Object.entries(logTypes)
            .filter(([_, enabled]) => enabled)
            .map(([type, _]) => type);
          
          const logTypeSelect = new StringSelectMenuBuilder()
            .setCustomId('safari_log_types_set')
            .setPlaceholder('Select log types to enable...')
            .setMinValues(0)
            .setMaxValues(logTypeOptions.length)
            .addOptions(logTypeOptions.map(opt => ({
              ...opt,
              default: selectedValues.includes(opt.value)
            })));
          
          const selectRow = new ActionRowBuilder().addComponents(logTypeSelect);
          
          // Create Components V2 container
          const container = {
            type: 17, // Container
            components: [
              {
                type: 10, // Text Display
                content: '## ‚öôÔ∏è Configure Safari Log Types\n\nSelect which types of interactions you want to log. Deselect any types you want to exclude from the logs.'
              },
              { type: 14 }, // Separator
              selectRow.toJSON()
            ]
          };
          
          return {
            components: [container],
            flags: (1 << 15), // IS_COMPONENTS_V2
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_log_test') {
      // Handle Safari Log test message
      return ButtonHandlerFactory.create({
        id: 'safari_log_test',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        deferred: true,
        handler: async (context) => {
          console.log(`üß™ DEBUG: User ${context.userId} sending Safari Log test message for guild ${context.guildId}`);
          
          try {
            // Load Safari log settings
            const { loadSafariContent } = await import('./safariManager.js');
            console.log(`üß™ DEBUG: Loading Safari content for guild ${context.guildId}`);
            const safariData = await loadSafariContent();
            const logSettings = safariData[context.guildId]?.safariLogSettings;
            console.log(`üß™ DEBUG: Log settings loaded:`, JSON.stringify(logSettings, null, 2));
            
            if (!logSettings?.enabled || !logSettings?.logChannelId) {
              console.log(`üß™ DEBUG: Safari Log not properly configured - enabled: ${logSettings?.enabled}, channelId: ${logSettings?.logChannelId}`);
              return {
                content: '‚ùå Safari Log is not properly configured. Please enable it and set a log channel first.',
                ephemeral: true
              };
            }
            
            // Send test message using analytics logger
            console.log(`üß™ DEBUG: Importing analytics logger`);
            const { logInteraction } = await import('./src/analytics/analyticsLogger.js');
            const testContent = {
              testMessage: true,
              timestamp: Date.now(),
              configuredBy: context.member?.displayName || context.username
            };
            console.log(`üß™ DEBUG: Test content created:`, testContent);
            
            console.log(`üß™ DEBUG: Calling logInteraction with SAFARI_TEST`);
            await logInteraction(
              context.userId,
              context.guildId,
              'SAFARI_TEST',
              'Safari Log Test Message',
              context.username,
              null,
              null,
              'safari-config',
              context.member?.displayName || context.username,
              testContent
            );
            console.log(`üß™ DEBUG: logInteraction completed successfully`);
            
            return {
              content: `‚úÖ Test message sent to <#${logSettings.logChannelId}>! Check the channel to verify the Safari Log is working correctly.`,
              ephemeral: true
            };
          } catch (error) {
            console.error(`üß™ ERROR: Safari Log test failed:`, error);
            console.error(`üß™ ERROR: Stack trace:`, error.stack);
            return {
              content: `‚ùå Safari Log test failed: ${error.message}`,
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    } else if (custom_id === 'safari_log_channel_set') {
      // Handle Safari Log channel selection from channel select menu
      return ButtonHandlerFactory.create({
        id: 'safari_log_channel_set',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const selectedChannelId = context.values[0];
          console.log(`üìù DEBUG: User ${context.userId} setting Safari Log channel to ${selectedChannelId} for guild ${context.guildId}`);
          
          // Load and update Safari log settings
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          
          // Initialize if missing
          if (!safariData[context.guildId]) {
            safariData[context.guildId] = {};
          }
          if (!safariData[context.guildId].safariLogSettings) {
            safariData[context.guildId].safariLogSettings = {
              enabled: false,
              logChannelId: null,
              productionRoleId: null,
              logTypes: {
                whispers: true,
                itemPickups: true,
                currencyChanges: true,
                storeTransactions: true,
                buttonActions: true,
                mapMovement: true,
                attacks: true,
                customActions: true
              }
            };
          }
          
          // Update the log channel
          safariData[context.guildId].safariLogSettings.logChannelId = selectedChannelId;
          
          // Save the updated settings
          await saveSafariContent(safariData);
          
          console.log(`üìä DEBUG: Safari Log channel set to ${selectedChannelId} for guild ${context.guildId}`);
          
          // Return to Safari Log configuration with updated state
          // Re-execute the safari_configure_log handler logic inline
          const { ButtonBuilder, ActionRowBuilder } = await import('discord.js');
          const updatedLogSettings = safariData[context.guildId].safariLogSettings;
          
          // Create enable/disable button
          const toggleButton = new ButtonBuilder()
            .setCustomId('safari_log_toggle')
            .setLabel(updatedLogSettings.enabled ? 'Disable Safari Log' : 'Enable Safari Log')
            .setStyle(updatedLogSettings.enabled ? 4 : 3) // Danger if enabled, Success if disabled
            .setEmoji(updatedLogSettings.enabled ? 'üî¥' : 'üü¢');
          
          // Create channel select button
          const channelButton = new ButtonBuilder()
            .setCustomId('safari_log_channel_select')
            .setLabel('Set Log Channel')
            .setStyle(2) // Secondary
            .setEmoji('üìù')
            .setDisabled(!updatedLogSettings.enabled);
          
          // Create log types configuration button
          const logTypesButton = new ButtonBuilder()
            .setCustomId('safari_log_types_config')
            .setLabel('Configure Log Types')
            .setStyle(2) // Secondary
            .setEmoji('‚öôÔ∏è')
            .setDisabled(!updatedLogSettings.enabled);
          
          // Create test message button
          const testButton = new ButtonBuilder()
            .setCustomId('safari_log_test')
            .setLabel('Send Test Message')
            .setStyle(2) // Secondary
            .setEmoji('üß™')
            .setDisabled(!updatedLogSettings.enabled || !updatedLogSettings.logChannelId);
          
          // Create back button
          const backButton = new ButtonBuilder()
            .setCustomId('safari_customize_terms')
            .setLabel('‚Üê Safari Settings')
            .setStyle(2) // Secondary
            .setEmoji('‚öôÔ∏è');
          
          const toggleRow = new ActionRowBuilder().addComponents(toggleButton);
          const configRow = new ActionRowBuilder().addComponents(channelButton, logTypesButton, testButton);
          const backRow = new ActionRowBuilder().addComponents(backButton);
          
          // Create status display
          let statusText = `## ü™µ CastBot Logs\n\n`;
          statusText += `-# Logs activity from Idol Hunts, Challenges and Safari features ‚Äî currency, items, stores, movement and more.\n\n`;
          statusText += `**Status:** ${updatedLogSettings.enabled ? 'üü¢ Enabled' : 'üî¥ Disabled'}\n`;
          statusText += `**Log Channel:** ${updatedLogSettings.logChannelId ? `<#${updatedLogSettings.logChannelId}>` : 'Not Set'}\n\n`;
          
          if (updatedLogSettings.enabled && updatedLogSettings.logChannelId) {
            statusText += `**Active Log Types:**\n`;
            const logTypeNames = {
              whispers: 'ü§´ Whispers',
              itemPickups: 'üß∞ Item Pickups',
              currencyChanges: 'ü™ô Currency Changes',
              storeTransactions: 'üõí Store Purchases',
              buttonActions: 'üéØ Safari Actions',
              mapMovement: 'üó∫Ô∏è Map Movement',
              attacks: '‚öîÔ∏è Attack Queue',
              customActions: '‚å®Ô∏è Custom Actions'
            };
            
            for (const [type, enabled] of Object.entries(updatedLogSettings.logTypes || {})) {
              if (enabled) {
                statusText += `‚Ä¢ ${logTypeNames[type] || type}\n`;
              }
            }
          }
          
          // Create Components V2 container
          const containerComponents = [
            {
              type: 10, // Text Display
              content: statusText
            },
            { type: 14 }, // Separator
            toggleRow.toJSON(),
            configRow.toJSON(),
            { type: 14 }, // Separator
            backRow.toJSON()
          ];
          
          const container = {
            type: 17, // Container
            components: containerComponents
          };
          
          return {
            components: [container],
            flags: (1 << 15) // IS_COMPONENTS_V2
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_log_types_set') {
      // Handle Safari Log types selection from multi-select menu
      return ButtonHandlerFactory.create({
        id: 'safari_log_types_set',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const selectedTypes = context.values || [];
          console.log(`‚öôÔ∏è DEBUG: User ${context.userId} setting Safari Log types for guild ${context.guildId}`, selectedTypes);
          
          // Load and update Safari log settings
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          
          // Initialize if missing
          if (!safariData[context.guildId]) {
            safariData[context.guildId] = {};
          }
          if (!safariData[context.guildId].safariLogSettings) {
            safariData[context.guildId].safariLogSettings = {
              enabled: false,
              logChannelId: null,
              productionRoleId: null,
              logTypes: {
                whispers: true,
                itemPickups: true,
                currencyChanges: true,
                storeTransactions: true,
                buttonActions: true,
                mapMovement: true,
                attacks: true,
                customActions: true
              }
            };
          }
          
          // Update log types based on selection
          const allTypes = ['whispers', 'itemPickups', 'currencyChanges', 'storeTransactions', 'buttonActions', 'mapMovement', 'attacks', 'customActions'];
          for (const type of allTypes) {
            safariData[context.guildId].safariLogSettings.logTypes[type] = selectedTypes.includes(type);
          }
          
          // Save the updated settings
          await saveSafariContent(safariData);
          
          console.log(`üìä DEBUG: Safari Log types updated for guild ${context.guildId}`);
          
          // Return to Safari Log configuration with updated state
          // Re-execute the safari_configure_log handler logic inline
          const { ButtonBuilder, ActionRowBuilder } = await import('discord.js');
          const updatedLogSettings = safariData[context.guildId].safariLogSettings;
          
          // Create enable/disable button
          const toggleButton = new ButtonBuilder()
            .setCustomId('safari_log_toggle')
            .setLabel(updatedLogSettings.enabled ? 'Disable Safari Log' : 'Enable Safari Log')
            .setStyle(updatedLogSettings.enabled ? 4 : 3) // Danger if enabled, Success if disabled
            .setEmoji(updatedLogSettings.enabled ? 'üî¥' : 'üü¢');
          
          // Create channel select button
          const channelButton = new ButtonBuilder()
            .setCustomId('safari_log_channel_select')
            .setLabel('Set Log Channel')
            .setStyle(2) // Secondary
            .setEmoji('üìù')
            .setDisabled(!updatedLogSettings.enabled);
          
          // Create log types configuration button
          const logTypesButton = new ButtonBuilder()
            .setCustomId('safari_log_types_config')
            .setLabel('Configure Log Types')
            .setStyle(2) // Secondary
            .setEmoji('‚öôÔ∏è')
            .setDisabled(!updatedLogSettings.enabled);
          
          // Create test message button
          const testButton = new ButtonBuilder()
            .setCustomId('safari_log_test')
            .setLabel('Send Test Message')
            .setStyle(2) // Secondary
            .setEmoji('üß™')
            .setDisabled(!updatedLogSettings.enabled || !updatedLogSettings.logChannelId);
          
          // Create back button
          const backButton = new ButtonBuilder()
            .setCustomId('safari_customize_terms')
            .setLabel('‚Üê Safari Settings')
            .setStyle(2) // Secondary
            .setEmoji('‚öôÔ∏è');
          
          const toggleRow = new ActionRowBuilder().addComponents(toggleButton);
          const configRow = new ActionRowBuilder().addComponents(channelButton, logTypesButton, testButton);
          const backRow = new ActionRowBuilder().addComponents(backButton);
          
          // Create status display
          let statusText = `## ü™µ CastBot Logs\n\n`;
          statusText += `-# Logs activity from Idol Hunts, Challenges and Safari features ‚Äî currency, items, stores, movement and more.\n\n`;
          statusText += `**Status:** ${updatedLogSettings.enabled ? 'üü¢ Enabled' : 'üî¥ Disabled'}\n`;
          statusText += `**Log Channel:** ${updatedLogSettings.logChannelId ? `<#${updatedLogSettings.logChannelId}>` : 'Not Set'}\n\n`;
          
          if (updatedLogSettings.enabled && updatedLogSettings.logChannelId) {
            statusText += `**Active Log Types:**\n`;
            const logTypeNames = {
              whispers: 'ü§´ Whispers',
              itemPickups: 'üß∞ Item Pickups',
              currencyChanges: 'ü™ô Currency Changes',
              storeTransactions: 'üõí Store Purchases',
              buttonActions: 'üéØ Safari Actions',
              mapMovement: 'üó∫Ô∏è Map Movement',
              attacks: '‚öîÔ∏è Attack Queue',
              customActions: '‚å®Ô∏è Custom Actions'
            };
            
            for (const [type, enabled] of Object.entries(updatedLogSettings.logTypes || {})) {
              if (enabled) {
                statusText += `‚Ä¢ ${logTypeNames[type] || type}\n`;
              }
            }
          }
          
          // Create Components V2 container
          const containerComponents = [
            {
              type: 10, // Text Display
              content: statusText
            },
            { type: 14 }, // Separator
            toggleRow.toJSON(),
            configRow.toJSON(),
            { type: 14 }, // Separator
            backRow.toJSON()
          ];
          
          const container = {
            type: 17, // Container
            components: containerComponents
          };
          
          return {
            components: [container],
            flags: (1 << 15) // IS_COMPONENTS_V2
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_config_reset_defaults') {
      // Handle reset to defaults button
      return ButtonHandlerFactory.create({
        id: 'safari_config_reset_defaults',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`‚öôÔ∏è DEBUG: Showing reset confirmation interface`);

          // Create reset confirmation interface
          const { createResetConfirmationUI } = await import('./safariConfigUI.js');
          const confirmationData = createResetConfirmationUI();

          return confirmationData;
        }
      })(req, res, client);
    } else if (custom_id === 'safari_config_confirm_reset') {
      // Handle confirmed reset to defaults
      try {
        const guildId = req.body.guild_id;
        const member = req.body.member;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to reset Safari settings.')) return;
        
        console.log(`‚öôÔ∏è DEBUG: Resetting Safari settings to defaults for guild ${guildId}`);
        
        // Reset to defaults using existing function
        const { resetCustomTerms } = await import('./safariManager.js');
        const success = await resetCustomTerms(guildId);
        
        if (!success) {
          throw new Error('Failed to reset custom terms');
        }
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚úÖ **Safari Settings Reset!**\n\nAll customizations have been reset to default values:\n‚Ä¢ Currency: ü™ô Dollars\n‚Ä¢ Inventory: Inventory\n‚Ä¢ Events: ‚òÄÔ∏è Clear Skies / ‚òÑÔ∏è Meteor Strike\n‚Ä¢ Round harvest probabilities: 75%, 50%, 25%',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in safari_config_confirm_reset:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error resetting Safari settings. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_export_data') {
      // Handle Safari data export
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const token = req.body.token;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to export Safari data.')) return;
        
        console.log(`üì§ DEBUG: Exporting Safari data for guild ${guildId}`);
        
        // Defer the response immediately
        res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
        // Export Safari data
        const { exportSafariData } = await import('./safariImportExport.js');
        const exportJson = await exportSafariData(guildId);
        
        console.log(`üì§ DEBUG: Export data length: ${exportJson.length} characters`);
        
        // Create the export file attachment
        const { AttachmentBuilder } = await import('discord.js');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `safari-export-${guildId}-${timestamp}.json`;
        
        const attachment = new AttachmentBuilder(Buffer.from(exportJson, 'utf8'), {
          name: filename,
          description: 'Safari configuration export'
        });
        
        // Use Discord API directly to send the follow-up with file
        const applicationId = req.body.application_id;
        const followUpUrl = `https://discord.com/api/v10/webhooks/${applicationId}/${token}`;
        
        // Create FormData with the file
        const FormData = (await import('form-data')).default;
        const form = new FormData();
        
        form.append('payload_json', JSON.stringify({
          content: 'üì§ **Safari Data Export Complete**\n\nYour Safari configuration has been exported. Download the attached JSON file to save your configuration.',
          flags: InteractionResponseFlags.EPHEMERAL
        }));
        
        form.append('files[0]', Buffer.from(exportJson, 'utf8'), {
          filename: filename,
          contentType: 'application/json'
        });
        
        // Send the follow-up message with the file
        await fetch(followUpUrl, {
          method: 'POST',
          headers: form.getHeaders(),
          body: form
        });
        
        return;
        
      } catch (error) {
        console.error('Error in safari_export_data:', error);
        
        // If we haven't sent a response yet, send error response
        if (!res.headersSent) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error exporting Safari data. Please try again.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
      }
    } else if (custom_id === 'playerdata_export_all') {
      // Handle Export All PlayerData (entire playerData.json file with all guilds)
      try {
        const userId = req.body.member.user.id;
        const token = req.body.token;

        // Security check - only allow specific Discord ID
        if (userId !== '391415444084490240') {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Access denied. This feature is restricted.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        console.log(`üì§ DEBUG: Exporting ALL playerData (full file)`);

        // Defer the response immediately
        res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });

        // Load entire playerData
        const { loadPlayerData } = await import('./storage.js');
        const allPlayerData = await loadPlayerData();

        // Calculate stats for the message
        const guildCount = Object.keys(allPlayerData).filter(k => k !== '/* Server ID */' && k !== 'environmentConfig').length;

        // Export raw playerData (no metadata wrapper - for direct file replacement)
        const exportJson = JSON.stringify(allPlayerData, null, 2);
        console.log(`üì§ DEBUG: Full playerData export length: ${exportJson.length} characters`);

        // Create the export file attachment
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `playerdata-FULL-export-${timestamp}.json`;

        // Use Discord API directly to send the follow-up with file
        const applicationId = req.body.application_id;
        const followUpUrl = `https://discord.com/api/v10/webhooks/${applicationId}/${token}`;

        // Create FormData with the file
        const FormData = (await import('form-data')).default;
        const form = new FormData();

        form.append('payload_json', JSON.stringify({
          content: `‚úÖ **Full playerData Export Complete**\n\n` +
                  `**All Guilds:** ${guildCount} servers\n` +
                  `**Export Size:** ${(exportJson.length / 1024).toFixed(1)} KB\n` +
                  `**Export Date:** ${new Date().toLocaleString()}\n\n` +
                  `‚ö†Ô∏è This file contains ALL server data from playerData.json\n` +
                  `üíæ Can be used as direct replacement for playerData.json`,
          flags: InteractionResponseFlags.EPHEMERAL
        }));

        form.append('files[0]', Buffer.from(exportJson, 'utf8'), {
          filename: filename,
          contentType: 'application/json'
        });

        // Send the follow-up message with the file
        await fetch(followUpUrl, {
          method: 'POST',
          headers: form.getHeaders(),
          body: form
        });

        console.log(`‚úÖ Full playerData export sent successfully`);
        return;

      } catch (error) {
        console.error('Error in playerdata_export_all:', error);

        // If we haven't sent a response yet, send error response
        if (!res.headersSent) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error exporting full playerData. Please try again.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
      }
    } else if (custom_id === 'safaricontent_export_all') {
      // Handle Export All safariContent (entire safariContent.json file with all guilds)
      try {
        const userId = req.body.member.user.id;
        const token = req.body.token;

        if (userId !== '391415444084490240') {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Access denied. This feature is restricted.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        console.log(`üì§ DEBUG: Exporting ALL safariContent (full file)`);

        res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
          data: { flags: InteractionResponseFlags.EPHEMERAL }
        });

        const { loadSafariContent } = await import('./safariManager.js');
        const allSafariContent = await loadSafariContent();

        const guildCount = Object.keys(allSafariContent).filter(k => k !== '/* Server ID */').length;

        const exportJson = JSON.stringify(allSafariContent, null, 2);
        console.log(`üì§ DEBUG: Full safariContent export length: ${exportJson.length} characters`);

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `safariContent-FULL-export-${timestamp}.json`;

        const applicationId = req.body.application_id;
        const followUpUrl = `https://discord.com/api/v10/webhooks/${applicationId}/${token}`;

        const FormData = (await import('form-data')).default;
        const form = new FormData();

        form.append('payload_json', JSON.stringify({
          content: `‚úÖ **Full safariContent Export Complete**\n\n` +
                  `**All Guilds:** ${guildCount} servers\n` +
                  `**Export Size:** ${(exportJson.length / 1024).toFixed(1)} KB\n` +
                  `**Export Date:** ${new Date().toLocaleString()}\n\n` +
                  `‚ö†Ô∏è This file contains ALL server data from safariContent.json\n` +
                  `üíæ Can be used as direct replacement for safariContent.json`,
          flags: InteractionResponseFlags.EPHEMERAL
        }));

        form.append('files[0]', Buffer.from(exportJson, 'utf8'), {
          filename: filename,
          contentType: 'application/json'
        });

        await fetch(followUpUrl, {
          method: 'POST',
          headers: form.getHeaders(),
          body: form
        });

        console.log(`‚úÖ Full safariContent export sent successfully`);
        return;

      } catch (error) {
        console.error('Error in safaricontent_export_all:', error);

        if (!res.headersSent) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error exporting full safariContent. Please try again.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
      }
    } else if (custom_id === 'playerdata_export') {
      // Handle PlayerData export (similar to Safari export but for playerData.json)
      try {
        const guildId = req.body.guild_id;
        const token = req.body.token;
        const userId = req.body.member.user.id;

        // Security check - only allow specific Discord ID (same as analytics_admin)
        if (userId !== '391415444084490240') {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Access denied. This feature is restricted.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        console.log(`üì§ DEBUG: Exporting PlayerData for guild ${guildId}`);

        // Defer the response immediately
        res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });

        // Load and export playerData for this guild
        const { loadPlayerData } = await import('./storage.js');
        const allPlayerData = await loadPlayerData();
        const guildData = allPlayerData[guildId];

        if (!guildData) {
          // Send follow-up message via webhook
          const applicationId = req.body.application_id;
          const webhookUrl = `https://discord.com/api/v10/webhooks/${applicationId}/${token}/messages/@original`;

          await fetch(webhookUrl, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bot ${client.token}`
            },
            body: JSON.stringify({
              content: '‚ùå No PlayerData found for this server.',
              flags: InteractionResponseFlags.EPHEMERAL
            })
          });
          return;
        }

        // Prepare the export JSON
        const exportData = {
          exportVersion: '1.0',
          exportDate: new Date().toISOString(),
          guildId: guildId,
          guildName: guildData.serverName || 'Unknown',
          dataType: 'playerData',
          data: guildData
        };

        const exportJson = JSON.stringify(exportData, null, 2);
        console.log(`üì§ DEBUG: PlayerData export length: ${exportJson.length} characters`);

        // Create the export file attachment
        const { AttachmentBuilder } = await import('discord.js');
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        const filename = `playerdata-export-${guildId}-${timestamp}.json`;

        const attachment = new AttachmentBuilder(Buffer.from(exportJson), {
          name: filename,
          description: `PlayerData export for ${guildData.serverName || guildId}`
        });

        // Use Discord API directly to send the follow-up with file
        const applicationId = req.body.application_id;
        const followUpUrl = `https://discord.com/api/v10/webhooks/${applicationId}/${token}`;

        // Create FormData with the file (using form-data package like Safari)
        const FormData = (await import('form-data')).default;
        const form = new FormData();

        form.append('payload_json', JSON.stringify({
          content: `‚úÖ **playerData Export Complete**\n\n**Server:** ${guildData.serverName || 'Unknown'}\n**Guild ID:** ${guildId}\n**Export Size:** ${(exportJson.length / 1024).toFixed(1)} KB\n**Players:** ${Object.keys(guildData.players || {}).length}\n\nThis file contains all playerData.json entries for this server.`,
          flags: InteractionResponseFlags.EPHEMERAL
        }));

        form.append('files[0]', Buffer.from(exportJson, 'utf8'), {
          filename: filename,
          contentType: 'application/json'
        });

        // Send the follow-up message with the file
        await fetch(followUpUrl, {
          method: 'POST',
          headers: form.getHeaders(),
          body: form
        });

        console.log(`‚úÖ PlayerData export sent successfully for guild ${guildId}`);
        return;

      } catch (error) {
        console.error('Error in playerdata_export:', error);

        // If we haven't sent a response yet, send error response
        if (!res.headersSent) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error exporting PlayerData. Please try again.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
      }
    } else if (custom_id === 'playerdata_import') {
      // Handle playerdata import with file upload (similar to Safari import)
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const channelId = req.body.channel_id;
        const userId = member.user.id;

        // Security check - only allow specific Discord ID (same as analytics_admin)
        if (userId !== '391415444084490240') {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Access denied. This feature is restricted.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        console.log(`üì• DEBUG: Starting file-based playerdata import for guild ${guildId}`);

        // Send instructions and set up message collector
        res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `üì• **playerData Import - File Upload**\n\n` +
                    `Please upload your playerData export JSON file now.\n` +
                    `Simply drag and drop the file into this channel or use the attachment button.\n\n` +
                    `‚ö†Ô∏è **WARNING:** This will REPLACE all current playerData for this server!\n\n` +
                    `‚è±Ô∏è Waiting for your file upload... (60 second timeout)`,
            components: [{
              type: 1,
              components: [{
                type: 2,
                style: 4,
                label: 'Cancel Import',
                custom_id: 'playerdata_import_cancel',
                emoji: { name: '‚ùå' }
              }]
            }],
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });

        // Set up message collector to wait for file upload
        const channel = await client.channels.fetch(channelId);
        const filter = m => m.author.id === userId && m.attachments.size > 0;

        const collector = channel.createMessageCollector({
          filter,
          time: 60000, // 60 second timeout
          max: 1 // Only collect one message
        });

        collector.on('collect', async (message) => {
          try {
            console.log(`üì• DEBUG: File upload detected from user ${userId}`);

            // Get the first attachment
            const attachment = message.attachments.first();

            // Validate it's a JSON file
            if (!attachment.name.endsWith('.json')) {
              await message.reply({
                content: '‚ùå Please upload a JSON file (`.json` extension required).',
                ephemeral: true
              });
              return;
            }

            // Fetch the file content
            const response = await fetch(attachment.url);
            const jsonContent = await response.text();

            console.log(`üì• DEBUG: Downloaded file ${attachment.name}, size: ${jsonContent.length} characters`);

            // Parse and validate the JSON
            let importData;
            try {
              importData = JSON.parse(jsonContent);
            } catch (parseError) {
              await message.reply({
                content: '‚ùå Invalid JSON format. Please check your file.',
                ephemeral: true
              });
              return;
            }

            // Check if it's a playerData export
            if (importData.dataType !== 'playerData' || !importData.data) {
              await message.reply({
                content: '‚ùå This doesn\'t appear to be a playerData export file.',
                ephemeral: true
              });
              return;
            }

            // Import the playerdata
            const { loadPlayerData, savePlayerData } = await import('./storage.js');
            const allPlayerData = await loadPlayerData();

            // Replace the guild data
            const oldDataSize = allPlayerData[guildId] ?
              Object.keys(allPlayerData[guildId].players || {}).length : 0;

            allPlayerData[guildId] = importData.data;
            await savePlayerData(allPlayerData);

            const newDataSize = Object.keys(importData.data.players || {}).length;

            console.log(`‚úÖ DEBUG: playerdata import completed for guild ${guildId}`);

            // Send success message
            await message.reply({
              content: `‚úÖ **playerData Import Successful!**\n\n` +
                      `**Server:** ${importData.guildName || 'Unknown'}\n` +
                      `**Guild ID:** ${importData.guildId}\n` +
                      `**Import Date:** ${new Date(importData.exportDate).toLocaleDateString()}\n` +
                      `**Players:** ${oldDataSize} ‚Üí ${newDataSize}\n\n` +
                      `All playerData has been successfully imported!`,
              ephemeral: true
            });

            // Delete the uploaded file message for privacy
            try {
              await message.delete();
            } catch (err) {
              console.log('Could not delete import file message:', err.message);
            }

          } catch (error) {
            console.error('Error processing playerdata import file:', error);
            await message.reply({
              content: `‚ùå **Import Failed**\n\nError: ${error.message}\n\nPlease check your JSON file format and try again.`,
              ephemeral: true
            });
          }
        });

        collector.on('end', (collected, reason) => {
          if (reason === 'time' && collected.size === 0) {
            // Edit the original message to show timeout
            const token = req.body.token;
            const editUrl = `https://discord.com/api/v10/webhooks/${req.body.application_id}/${token}/messages/@original`;

            fetch(editUrl, {
              method: 'PATCH',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bot ${client.token}`
              },
              body: JSON.stringify({
                content: '‚è±Ô∏è **Import Timed Out**\n\nNo file was uploaded within 60 seconds.',
                components: []
              })
            }).catch(console.error);
          }
        });

        return;

      } catch (error) {
        console.error('Error in playerdata_import:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error starting import process. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'playerdata_import_cancel') {
      // Handle playerData import cancellation
      return res.send({
        type: InteractionResponseType.UPDATE_MESSAGE,
        data: {
          content: '‚ùå **Import Cancelled**\n\nplayerData import has been cancelled.',
          components: []
        }
      });
    } else if (custom_id === 'safari_import_data') {
      // Handle Safari data import with file upload
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const channelId = req.body.channel_id;
        const userId = member.user.id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to import Safari data.')) return;
        
        console.log(`üì• DEBUG: Starting file-based Safari import for guild ${guildId}`);
        
        // Send instructions and set up message collector
        res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `üì• **Safari Data Import - File Upload**\n\n` +
                    `Please upload your Safari export JSON file now.\n` +
                    `Simply drag and drop the file into this channel or use the attachment button.\n\n` +
                    `‚è±Ô∏è Waiting for your file upload... (60 second timeout)`,
            components: [{
              type: 1,
              components: [{
                type: 2,
                style: 4,
                label: 'Cancel Import',
                custom_id: 'safari_import_cancel',
                emoji: { name: '‚ùå' }
              }]
            }],
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
        // Set up message collector to wait for file upload
        const channel = await client.channels.fetch(channelId);
        const filter = m => m.author.id === userId && m.attachments.size > 0;
        
        const collector = channel.createMessageCollector({ 
          filter, 
          time: 60000, // 60 second timeout
          max: 1 // Only collect one message
        });
        
        collector.on('collect', async (message) => {
          try {
            console.log(`üì• DEBUG: File upload detected from user ${userId}`);
            
            // Get the first attachment
            const attachment = message.attachments.first();
            
            // Validate it's a JSON file
            if (!attachment.name.endsWith('.json')) {
              await message.reply({
                content: '‚ùå Please upload a JSON file (`.json` extension required).',
                ephemeral: true
              });
              return;
            }
            
            // Fetch the file content
            const response = await fetch(attachment.url);
            const jsonContent = await response.text();
            
            console.log(`üì• DEBUG: Downloaded file ${attachment.name}, size: ${jsonContent.length} characters`);
            
            // Import the Safari data
            const { importSafariData, formatImportSummary } = await import('./safariImportExport.js');
            const summary = await importSafariData(guildId, jsonContent, { userId, client });
            
            console.log(`‚úÖ DEBUG: Safari import completed for guild ${guildId}:`, summary);
            
            // Send success message
            await message.reply({
              content: `‚úÖ **Safari Data Import Successful!**\n\n${formatImportSummary(summary)}`,
              ephemeral: true
            });
            
            // Delete the uploaded file message for privacy
            try {
              await message.delete();
            } catch (err) {
              console.log('Could not delete import file message:', err.message);
            }
            
          } catch (error) {
            console.error('Error processing Safari import file:', error);
            await message.reply({
              content: `‚ùå **Import Failed**\n\nError: ${error.message}\n\nPlease check your JSON file format and try again.`,
              ephemeral: true
            });
          }
        });
        
        collector.on('end', (collected, reason) => {
          if (reason === 'time' && collected.size === 0) {
            // Edit the original message to show timeout
            const token = req.body.token;
            const editUrl = `https://discord.com/api/v10/webhooks/${req.body.application_id}/${token}/messages/@original`;
            
            fetch(editUrl, {
              method: 'PATCH',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                content: '‚è±Ô∏è **Import Timed Out**\n\nNo file was uploaded within 60 seconds. Please try again.',
                components: []
              })
            }).catch(err => console.error('Error updating timeout message:', err));
          }
        });
        
        return;
        
      } catch (error) {
        console.error('Error in safari_import_data:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error starting import process. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_import_cancel') {
      // Handle import cancellation
      return res.send({
        type: InteractionResponseType.UPDATE_MESSAGE,
        data: {
          content: '‚ùå Safari import cancelled.',
          components: []
        }
      });
    } else if (custom_id === 'safari_schedule_results') {
      // Handle Safari scheduling interface
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const channelId = req.body.channel_id;

        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to schedule Safari results.')) return;

        console.log(`üìÖ DEBUG: Opening Safari scheduling modal for guild ${guildId}, channel ${channelId}`);

        // Get current scheduled tasks for display
        const scheduledTasks = scheduler.getJobs({ action: 'process_round_results' });

        // Build modal components using Label (type 18) + Text Display (type 10)
        const modalComponents = [];

        // Text Display: show current scheduled tasks
        if (scheduledTasks.length > 0) {
          const taskLines = scheduledTasks.slice(0, 3).map((t, i) =>
            `**${i + 1}.** ${scheduler.calculateRemainingTime(t.executeAt)} remaining`
          ).join('\n');
          modalComponents.push({
            type: 10,
            content: `### Scheduled Tasks\n${taskLines}`
          });
        } else {
          modalComponents.push({
            type: 10,
            content: '### No tasks scheduled\nSet hours/minutes below to schedule round results.'
          });
        }

        // Label + TextInput: Hours
        modalComponents.push({
          type: 18,
          label: 'Hours from now',
          description: '0-168 hours (leave empty to skip)',
          component: {
            type: 4,
            custom_id: 'schedule_hours',
            style: 1,
            placeholder: '4',
            max_length: 3,
            required: false
          }
        });

        // Label + TextInput: Minutes
        modalComponents.push({
          type: 18,
          label: 'Minutes from now',
          description: '0-59 minutes (leave empty to skip)',
          component: {
            type: 4,
            custom_id: 'schedule_minutes',
            style: 1,
            placeholder: '30',
            max_length: 3,
            required: false
          }
        });

        // Label + String Select: Cancel tasks (only if tasks exist)
        if (scheduledTasks.length > 0) {
          modalComponents.push({
            type: 18,
            label: 'Cancel scheduled tasks',
            description: 'Select tasks to cancel (optional)',
            component: {
              type: 3,
              custom_id: 'cancel_tasks',
              placeholder: 'Select tasks to cancel...',
              required: false,
              min_values: 0,
              max_values: Math.min(scheduledTasks.length, 3),
              options: scheduledTasks.slice(0, 3).map((t, i) => ({
                label: `Task ${i + 1}: ${scheduler.calculateRemainingTime(t.executeAt)}`,
                value: t.id,
                description: t.description || 'Safari Round Results',
                emoji: { name: 'üóëÔ∏è' }
              }))
            }
          });
        }

        return res.send({
          type: InteractionResponseType.MODAL,
          data: {
            custom_id: `safari_schedule_modal_${channelId}`,
            title: 'Schedule Round Results',
            components: modalComponents
          }
        });

      } catch (error) {
        console.error('Error in safari_schedule_results:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error opening scheduling interface. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_clear_corrupted_attacks') {
      // Handle clearing corrupted attack queue entries
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to clear corrupted attacks.')) return;
        
        console.log(`üîß DEBUG: Clearing corrupted attacks for guild ${guildId}`);
        
        // Clear corrupted attacks
        const { clearCorruptedAttacks } = await import('./safariManager.js');
        const summary = await clearCorruptedAttacks(guildId);
        
        // Log the action
        await logInteraction(req.body, 'safari_clear_corrupted_attacks', { 
          guildId,
          summary 
        });
        
        // Create success response
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | 64, // IS_COMPONENTS_V2 + EPHEMERAL
            components: [{
              type: 17, // Container
              accent_color: 0x2ecc71, // Green for success
              components: [
                {
                  type: 10, // Text Display
                  content: `# üîß Attack Queue Cleanup Complete\n\n**üìä Summary:**\n‚Ä¢ **Total attacks scanned:** ${summary.totalAttacks}\n‚Ä¢ **üóëÔ∏è Corrupted removed:** ${summary.corruptedRemoved}\n‚Ä¢ **‚úÖ Valid remaining:** ${summary.validRemaining}\n\n${summary.corruptedRemoved > 0 ? 'Corrupted attack data has been cleaned up!' : 'No corrupted attacks found - your attack queues are clean!'}`
                }
              ]
            }]
          }
        });
        
      } catch (error) {
        console.error('Error in safari_clear_corrupted_attacks:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error clearing corrupted attacks. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_manage_items') {
      // Streamlined: Go directly to Item Management section (entity management UI) (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_manage_items',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        deferred: true,  // Prevent 3-second timeout for large data files
        handler: async (context) => {
          console.log(`üì¶ DEBUG: Item management UI opened for guild ${context.guildId}`);

          // Create entity management UI
          const uiResponse = await createEntityManagementUI({
            entityType: 'item',
            guildId: context.guildId,
            selectedId: null,
            activeFieldGroup: null,
            searchTerm: '',
            mode: 'edit'
          });

          return {
            ...uiResponse,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_store_create') {
      // MVP2: Create new store interface
      console.log('üè™ DEBUG: safari_store_create handler called');
      try {
        const member = req.body.member;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to create stores.')) return;
        
        console.log(`üè™ DEBUG: Create new store clicked`);
        
        // Use shared modal creation utility
        const { createStoreModal } = await import('./safariManager.js');
        const modal = createStoreModal('safari_store_modal', 'Create New Store');

        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal
        });
        
      } catch (error) {
        console.error('Error in safari_store_create:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error creating store interface.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    // safari_store_manage_existing handler removed - functionality replaced by safari_store_manage_items
    } else if (custom_id === 'safari_store_manage_items') {
      // MVP2 Sprint 1: Manage store items (add/remove items from stores)
      MenuBuilder.trackLegacyMenu('safari_store_manage_items', 'Safari store items management');
      return ButtonHandlerFactory.create({
        id: 'safari_store_manage_items',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        ephemeral: true,
        handler: async (context) => {
          console.log(`üì¶ DEBUG: Opening store items management interface`);

          const { createStoreSelectionUI } = await import('./storeSelector.js');
          return await createStoreSelectionUI({
            guildId: context.guildId,
            action: 'manage_items'
          });
        }
      })(req, res, client);
    } else if (custom_id === 'safari_store_items_select') {
      // Handle store selection for items management - Using new multi-select UI
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const data = req.body.data;
        const selectedStoreId = data.values[0];

        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to manage store items.')) return;

        console.log(`üì¶ DEBUG: Managing items for store ${selectedStoreId}`);

        // Handle "Create New Store" selection
        if (selectedStoreId === 'create_new_store') {
          console.log(`üè™ DEBUG: Create new store selected from dropdown`);

          // Use shared modal creation utility
          const { createStoreModal } = await import('./safariManager.js');
          const modal = createStoreModal('safari_store_modal_redirect', 'Create New Store');

          return res.send({
            type: InteractionResponseType.MODAL,
            data: modal
          });
        }

        // Handle "Search Stores" selection
        if (selectedStoreId === 'search_stores') {
          console.log(`üîç DEBUG: Search stores selected from dropdown`);

          // Load stores to get count for modal title
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const stores = safariData[guildId]?.stores || {};
          const storeCount = Object.keys(stores).length;

          // Show the search modal
          const modal = new ModalBuilder()
            .setCustomId('safari_store_search_modal')
            .setTitle(`Search ${storeCount} Stores`);

          const searchInput = new TextInputBuilder()
            .setCustomId('search_term')
            .setLabel('Search by name or description')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)  // Allow empty search to show all
            .setMaxLength(100)
            .setPlaceholder('Enter store name or description...');

          const searchRow = new ActionRowBuilder().addComponents(searchInput);
          modal.addComponents(searchRow);

          return res.send({
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          });
        }

        // Handle "No results" selection (from search)
        if (selectedStoreId === 'no_results') {
          console.log(`‚ùå DEBUG: No results option selected`);
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå No stores found. Try searching again with different terms or create a new store.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Import Safari manager functions
        const { loadSafariContent } = await import('./safariManager.js');
        const { createStoreItemManagementUI } = await import('./entityManagementUI.js');

        const safariData = await loadSafariContent();
        const store = safariData[guildId]?.stores?.[selectedStoreId];
        
        if (!store) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Initialize store.items if it doesn't exist
        if (!store.items) {
          store.items = [];
        }
        
        // Create the new multi-select UI
        const uiResponse = await createStoreItemManagementUI({
          storeId: selectedStoreId,
          store: store,
          guildId: guildId,
          searchTerm: ''
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: uiResponse
        });
        
      } catch (error) {
        console.error('Error in safari_store_items_select:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error loading store items.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('store_items_multiselect_')) {
      // Handle multi-select store item changes
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const data = req.body.data;
        const selectedValues = data.values || [];
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to manage store items.')) return;
        
        // Extract store ID from custom_id
        const storeId = custom_id.replace('store_items_multiselect_', '');
        
        console.log(`üì¶ DEBUG: Multi-select update for store ${storeId} - ${selectedValues.length} items selected`);
        
        // Handle search selection separately
        if (selectedValues.includes('search_entities')) {
          // Check if store is at item limit ‚Äî block search if so
          const { loadSafariContent: loadSafariForCheck } = await import('./safariManager.js');
          const { SAFARI_LIMITS: limits } = await import('./config/safariLimits.js');
          const checkData = await loadSafariForCheck();
          const checkStore = checkData[guildId]?.stores?.[storeId];
          const checkCount = (checkStore?.items || []).length;
          if (checkCount >= limits.MAX_ITEMS_PER_STORE) {
            const { createStoreItemManagementUI } = await import('./entityManagementUI.js');
            const uiResponse = await createStoreItemManagementUI({
              storeId, store: checkStore, guildId, searchTerm: ''
            });
            return res.send({ type: InteractionResponseType.UPDATE_MESSAGE, data: uiResponse });
          }

          // Show search modal
          const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = await import('discord.js');
          
          const modal = new ModalBuilder()
            .setCustomId(`store_item_search_modal_${storeId}`)
            .setTitle('Search Items');
          
          const searchInput = new TextInputBuilder()
            .setCustomId('search_term')
            .setLabel('Search Term')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('Enter item name to search...')
            .setRequired(true)
            .setMaxLength(50);
          
          modal.addComponents(new ActionRowBuilder().addComponents(searchInput));
          
          return res.send({
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          });
        }
        
        // Handle clear search selection
        if (selectedValues.includes('clear_search')) {
          // Clear search and show all items
          const { loadSafariContent } = await import('./safariManager.js');
          const { createStoreItemManagementUI } = await import('./entityManagementUI.js');
          
          const safariData = await loadSafariContent();
          const store = safariData[guildId]?.stores?.[storeId];
          
          if (!store) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Store not found.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          // Create UI without search term (shows all items)
          const uiResponse = await createStoreItemManagementUI({
            storeId: storeId,
            store: store,
            guildId: guildId,
            searchTerm: '' // Clear search
          });
          
          return res.send({
            type: InteractionResponseType.UPDATE_MESSAGE,
            data: uiResponse
          });
        }
        
        // Import required functions
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const { createStoreItemManagementUI } = await import('./entityManagementUI.js');
        
        const safariData = await loadSafariContent();
        const store = safariData[guildId]?.stores?.[storeId];
        
        if (!store) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Calculate changes
        const currentItems = store.items || [];
        const currentItemIds = new Set(currentItems.map(item => item.itemId || item));
        const newItemIds = new Set(selectedValues);
        
        // Items to add (in new selection but not in current)
        const itemsToAdd = selectedValues.filter(id => !currentItemIds.has(id));

        // Items to remove (in current but not in new selection)
        const itemsToRemove = currentItems
          .map(item => item.itemId || item)
          .filter(id => !newItemIds.has(id));

        // Enforce per-store item limit
        const { SAFARI_LIMITS } = await import('./config/safariLimits.js');
        const projectedCount = currentItems.length + itemsToAdd.length - itemsToRemove.length;
        if (projectedCount > SAFARI_LIMITS.MAX_ITEMS_PER_STORE) {
          const uiResponse = await createStoreItemManagementUI({
            storeId: storeId,
            store: store,
            guildId: guildId,
            searchTerm: ''
          });
          return res.send({
            type: InteractionResponseType.UPDATE_MESSAGE,
            data: uiResponse
          });
        }

        console.log(`üì¶ DEBUG: Adding ${itemsToAdd.length} items, removing ${itemsToRemove.length} items`);
        
        // Update store items
        const updatedItems = [];
        
        // Keep existing items that weren't removed
        currentItems.forEach(storeItem => {
          const itemId = storeItem.itemId || storeItem;
          if (newItemIds.has(itemId)) {
            updatedItems.push(storeItem);
          }
        });
        
        // Add new items with metadata
        itemsToAdd.forEach(itemId => {
          const item = safariData[guildId]?.items?.[itemId];
          if (item) {
            updatedItems.push({
              itemId: itemId,
              price: item.basePrice || 0,
              addedAt: Date.now()
            });
          }
        });
        
        // Update store
        store.items = updatedItems;
        store.metadata = { ...(store.metadata || {}), lastModified: Date.now() };
        await saveSafariContent(safariData);
        
        console.log(`‚úÖ DEBUG: Store ${storeId} updated - now has ${updatedItems.length} items`);
        
        // Refresh UI
        const uiResponse = await createStoreItemManagementUI({
          storeId: storeId,
          store: store,
          guildId: guildId,
          searchTerm: ''
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: uiResponse
        });
        
      } catch (error) {
        console.error('Error in store_items_multiselect handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating store items.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_store_select_add_to_location_')) {
      // Handle store selection for map location (EXISTING HANDLER)
      return ButtonHandlerFactory.create({
        id: 'safari_store_select_add_to_location',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const { handleStoreToggle } = await import('./storeSelector.js');
          return await handleStoreToggle(context, client);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_store_add_item_')) {
      // Add item to store
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to manage store items.')) return;
        
        // Parse custom_id: safari_store_add_item_${storeId}::${itemId}
        // Using :: delimiter to handle IDs with underscores
        const prefix = 'safari_store_add_item_';
        const afterPrefix = custom_id.substring(prefix.length);
        const delimiterIndex = afterPrefix.indexOf('::');
        if (delimiterIndex === -1) {
          throw new Error('Invalid custom_id format');
        }
        const storeId = afterPrefix.substring(0, delimiterIndex);
        const itemId = afterPrefix.substring(delimiterIndex + 2);
        
        console.log(`‚ûï DEBUG: Adding item ${itemId} to store ${storeId}`);
        
        // Import Safari manager functions
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        
        const store = safariData[guildId]?.stores?.[storeId];
        const item = safariData[guildId]?.items?.[itemId];
        
        if (!store || !item) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store or item not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Initialize store.items if needed
        if (!store.items) {
          store.items = [];
        }
        
        // Check if item already in store
        const existingItem = store.items.find(storeItem => 
          (storeItem.itemId || storeItem) === itemId
        );
        
        if (existingItem) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Item is already in this store.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Add item to store (using base price initially)
        store.items.push({
          itemId: itemId,
          price: item.basePrice || 0,
          addedAt: Date.now()
        });
        
        // Save updated data
        await saveSafariContent(safariData);
        
        console.log(`‚úÖ DEBUG: Successfully added ${itemId} to store ${storeId}`);
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚úÖ **Item Added!**\n\n**${item.emoji || 'üì¶'} ${item.name}** has been added to **${store.emoji || 'üè™'} ${store.name}** for **üí∞ ${item.basePrice || 0} coins**.`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error adding item to store:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error adding item to store.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_store_remove_item_')) {
      // Remove item from store
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to manage store items.')) return;
        
        // Parse custom_id: safari_store_remove_item_${storeId}::${itemId}
        // Using :: delimiter to handle IDs with underscores
        const prefix = 'safari_store_remove_item_';
        const afterPrefix = custom_id.substring(prefix.length);
        const delimiterIndex = afterPrefix.indexOf('::');
        if (delimiterIndex === -1) {
          throw new Error('Invalid custom_id format');
        }
        const storeId = afterPrefix.substring(0, delimiterIndex);
        const itemId = afterPrefix.substring(delimiterIndex + 2);
        
        console.log(`üóëÔ∏è DEBUG: Removing item ${itemId} from store ${storeId}`);
        
        // Import Safari manager functions
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        
        const store = safariData[guildId]?.stores?.[storeId];
        const item = safariData[guildId]?.items?.[itemId];
        
        if (!store || !item) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store or item not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Remove item from store
        const originalLength = store.items?.length || 0;
        store.items = (store.items || []).filter(storeItem => 
          (storeItem.itemId || storeItem) !== itemId
        );
        
        if (store.items.length === originalLength) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Item was not found in this store.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Save updated data
        await saveSafariContent(safariData);
        
        console.log(`‚úÖ DEBUG: Successfully removed ${itemId} from store ${storeId}`);
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚úÖ **Item Removed!**\n\n**${item.emoji || 'üì¶'} ${item.name}** has been removed from **${store.emoji || 'üè™'} ${store.name}**.`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error removing item from store:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error removing item from store.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_store_stock_')) {
      // Item Quantity - show modal with string select for stock management
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to manage stock.')) return;
        
        // Parse storeId from custom_id
        const storeId = custom_id.replace('safari_store_stock_', '');
        console.log(`üì¶ DEBUG: Managing stock for store ${storeId}`);
        
        // Import Safari manager functions
        const { loadSafariContent, getItemStock } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const store = safariData[guildId]?.stores?.[storeId];
        
        if (!store) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Get all items in the store with their current stock
        const storeItems = store.items || [];
        const guildItems = safariData[guildId]?.items || {};
        
        // Build options for the string select with current stock info
        const options = [];
        for (const storeItem of storeItems) {
          const itemId = storeItem.itemId || storeItem;
          const item = guildItems[itemId];
          if (item) {
            const currentStock = await getItemStock(guildId, storeId, itemId);
            let stockDisplay;
            if (currentStock === -1 || currentStock === null || currentStock === undefined) {
              stockDisplay = 'Unlimited';
            } else {
              stockDisplay = `${currentStock}`;
            }
            
            // Build label with proper emoji handling and truncation
            const itemEmoji = (item.emoji && item.emoji.trim()) ? item.emoji : 'üì¶';
            const itemName = item.name || 'Unknown Item';
            const stockLabel = ` (Stock: ${stockDisplay})`;
            
            // Build full label
            let fullLabel = `${itemEmoji} ${itemName}${stockLabel}`;
            
            // If too long, truncate the item name part
            if (fullLabel.length > 100) {
              const maxItemLength = 100 - itemEmoji.length - stockLabel.length - 4; // -4 for space and "..."
              const truncatedName = itemName.substring(0, Math.max(maxItemLength, 1)) + '...';
              fullLabel = `${itemEmoji} ${truncatedName}${stockLabel}`;
            }
            
            options.push({
              label: fullLabel.substring(0, 100), // Final safety truncation
              value: itemId,
              description: `Current stock: ${stockDisplay}`.substring(0, 100) // Also limit description
            });
          }
        }
        
        if (options.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå This store has no items to manage stock for.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`üì¶ DEBUG: About to show modal with ${options.length} options`);
        console.log(`üì¶ DEBUG: First option:`, JSON.stringify(options[0], null, 2));
        
        // Ensure title fits Discord's 45 character limit
        let modalTitle = `Stock: ${store.name}`;
        if (modalTitle.length > 45) {
          modalTitle = `Stock: ${store.name.substring(0, 37)}...`; // 37 + 8 for "Stock: " + "..." = 45
        }
        
        console.log(`üì¶ DEBUG: Modal title: "${modalTitle}" (length: ${modalTitle.length})`);
        
        // Create modal with new Components V2 Label pattern for string select
        const modal = {
          title: modalTitle,
          custom_id: `safari_store_stock_modal_${storeId}`,
          components: [
            // String Select wrapped in Label (type 18)
            {
              type: 18, // Label
              label: 'Select Item to Update Stock',
              component: {
                type: 3, // String Select
                custom_id: 'item_select',
                placeholder: 'Choose an item...',
                min_values: 1,
                max_values: 1,
                options: options.slice(0, 25) // Discord limit of 25 options
              }
            },
            // Text Input wrapped in Label (type 18)
            {
              type: 18, // Label
              label: 'Enter new item qty (-1 for unlimited)',
              description: 'Enter item stock level for that store',
              component: {
                type: 4, // Text Input
                custom_id: 'stock_quantity',
                style: 1, // Short
                placeholder: 'Enter item stock level for that store',
                required: true,
                min_length: 1,
                max_length: 10
              }
            }
          ]
        };
        
        console.log(`üì¶ DEBUG: Sending modal response`);
        console.log(`üì¶ DEBUG: Modal structure:`, JSON.stringify(modal, null, 2));
        
        try {
          return res.send({
            type: InteractionResponseType.MODAL,
            data: modal
          });
        } catch (sendError) {
          console.error('Error sending modal response:', sendError);
          throw sendError;
        }
      } catch (error) {
        console.error('Error showing stock management modal:', error);
        console.error('Error stack:', error.stack);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error opening stock management.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_store_edit_')) {
      // Edit Store - show modal with pre-populated store details
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to edit stores.')) return;
        
        // Parse storeId from custom_id
        const storeId = custom_id.replace('safari_store_edit_', '');
        console.log(`‚úèÔ∏è DEBUG: Editing store ${storeId}`);
        
        const { loadSafariContent, createStoreModal } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const store = safariData[guildId]?.stores?.[storeId];

        if (!store) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        const modalData = createStoreModal(`safari_store_edit_modal_${storeId}`, 'Edit Store Details', store);
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modalData
        });

      } catch (error) {
        console.error('Error in safari_store_edit:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error opening store edit interface.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_store_open_')) {
      // Open Store - post store button to channel
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to post store buttons.')) return;
        
        // Parse storeId from custom_id
        const storeId = custom_id.replace('safari_store_open_', '');
        console.log(`üè™ DEBUG: Opening store posting interface for store ${storeId}`);
        
        // Import Safari manager functions
        const { loadSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const store = safariData[guildId]?.stores?.[storeId];
        
        if (!store) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Create channel posting interface
        const containerComponents = [
          {
            type: 10, // Text Display
            content: `## üè™ Open Store\n\n**${store.emoji || 'üè™'} ${store.name}**`
          },
          {
            type: 10, // Text Display
            content: `Select the channel to post your store button to - be sure to write up any context in the channel before posting the button.`
          },
          {
            type: 14 // Separator
          },
          {
            type: 1, // Action Row
            components: [{
              type: 8, // Channel Select
              custom_id: `safari_store_post_channel_${storeId}`,
              placeholder: 'Select channel to post store button...',
              channel_types: [0, 5] // Text and Announcement channels
            }]
          },
          {
            type: 14 // Separator
          },
          {
            type: 1, // Action Row
            components: [{
              type: 2, // Button
              custom_id: `safari_store_items_select`,
              label: '‚¨Ö Back to Store Management',
              style: 2
            }]
          }
        ];
        
        const container = {
          type: 17, // Container
          accent_color: store.settings?.accentColor || 0x3498db,
          components: containerComponents
        };
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            flags: (1 << 15), // IS_COMPONENTS_V2
            components: [container]
          }
        });
        
      } catch (error) {
        console.error('Error in safari_store_open handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error opening store posting interface.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_all_server_items_')) {
      return ButtonHandlerFactory.create({
        id: 'safari_all_server_items',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const { guildId, client, customId } = context;

          // Extract store ID from custom_id pattern: safari_all_server_items_${guildId}_${storeId}
          const prefix = `safari_all_server_items_${guildId}_`;
          const storeId = customId.replace(prefix, '');

          // Check if this was called from store selector (no store ID) vs specific store management
          const isFromStoreSelector = storeId === '' || storeId === guildId || storeId.startsWith('safari_all_server_items_');

          console.log(`üìÑ DEBUG: Showing all server items for guild ${guildId}, store context: ${storeId}`);

          // Import Safari manager functions
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const allItems = safariData[guildId]?.items || {};
          const store = safariData[guildId]?.stores?.[storeId];

          // Get guild name for display
          const guild = await client.guilds.fetch(guildId);
          const serverName = guild.name;

          // Build items list
          let itemsList = '';
          const itemEntries = Object.entries(allItems);

          if (itemEntries.length === 0) {
            itemsList = '*No items found on this server.*';
          } else {
            // Sort items alphabetically
            itemEntries.sort(([, a], [, b]) => (a.name || '').localeCompare(b.name || ''));

            let charCount = 0;
            let itemCount = 0;
            let truncated = false;

            for (const [itemId, item] of itemEntries) {
              const emoji = item.emoji || 'üì¶';
              const name = item.name || 'Unnamed Item';
              const price = item.basePrice || 0;
              const line = `${emoji} ${name} - üí∞ ${price} coins\n`;

              // Check if adding this line would exceed 3500 characters
              if (charCount + line.length > 3500) {
                const remaining = itemEntries.length - itemCount;
                if (remaining > 0) {
                  itemsList += `... and ${remaining} more items`;
                  truncated = true;
                }
                break;
              }

              itemsList += line;
              charCount += line.length;
              itemCount++;
            }
          }

          // Create back button that returns to specific store management
          console.log(`üìÑ DEBUG: Store lookup - storeId: "${storeId}", isFromStoreSelector: ${isFromStoreSelector}, store found: ${!!store}, store name: ${store?.name}`);

          const backButton = isFromStoreSelector ? {
            type: 2, // Button
            custom_id: 'safari_store_manage_items', // Return to store selector
            label: '‚Üê Store Management',
            style: 2,
            emoji: { name: 'üè™' }
          } : store ? {
            type: 2, // Button
            custom_id: `safari_store_items_select_back_${storeId}`,
            label: `‚Üê ${store.name || 'Store Management'}`,
            style: 2,
            emoji: { name: 'üè™' }
          } : {
            type: 2, // Button
            custom_id: 'safari_store_manage_items', // Fallback to store selector
            label: '‚Üê Store Management',
            style: 2,
            emoji: { name: 'üè™' }
          };

          // Create ephemeral response
          const components = [{
            type: 17, // Container
            accent_color: 0x5865f2,
            components: [
              {
                type: 10, // Text Display
                content: `# üì¶ All ${serverName} Items`
              },
              { type: 14 }, // Separator (requested divider)
              {
                type: 10, // Text Display
                content: itemsList
              },
              { type: 14 }, // Separator
              {
                type: 1, // Action Row
                components: [backButton]
              }
            ]
          }];

          return {
            flags: (1 << 15) | (1 << 6), // IS_COMPONENTS_V2 + EPHEMERAL
            components: components
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_store_items_select_back_')) {
      // Handle back button from "All Items" view - return to specific store management
      return ButtonHandlerFactory.create({
        id: 'safari_store_items_select_back',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const { guildId, customId } = context;

          // Extract store ID from custom_id
          const storeId = customId.replace('safari_store_items_select_back_', '');

          console.log(`üì¶ DEBUG: Returning to store management for store ${storeId}`);

          // Load store data
          const { loadSafariContent } = await import('./safariManager.js');
          const { createStoreItemManagementUI } = await import('./entityManagementUI.js');
          const safariData = await loadSafariContent();
          const store = safariData[guildId]?.stores?.[storeId];

          if (!store) {
            return {
              content: '‚ùå Store not found.',
              flags: (1 << 6) // EPHEMERAL
            };
          }

          // Initialize store.items if it doesn't exist
          if (!store.items) {
            store.items = [];
          }

          // Create the store management UI
          const uiResponse = await createStoreItemManagementUI({
            storeId: storeId,
            store: store,
            guildId: guildId,
            searchTerm: ''
          });

          return uiResponse;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_store_delete_')) {
      // Handle store delete button - show confirmation dialog
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to delete stores.')) return;
        
        // Parse storeId from custom_id
        const storeId = custom_id.replace('safari_store_delete_', '');
        console.log(`üóëÔ∏è DEBUG: Showing delete confirmation for store ${storeId}`);
        
        // Import Safari manager functions
        const { loadSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const store = safariData[guildId]?.stores?.[storeId];
        
        if (!store) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Create delete confirmation interface
        const containerComponents = [
          {
            type: 10, // Text Display
            content: `## ‚ö†Ô∏è Delete Store Confirmation\n\n**${store.emoji || 'üè™'} ${store.name}**`
          },
          {
            type: 10, // Text Display
            content: `‚ö†Ô∏è **WARNING**: This will permanently delete the store and all its data:\n\n‚Ä¢ Store configuration and settings\n‚Ä¢ All items stocked in the store\n‚Ä¢ Store metadata and statistics\n\n**This action cannot be undone!**`
          },
          {
            type: 14 // Separator
          },
          {
            type: 1, // Action Row
            components: [
              {
                type: 2, // Button
                custom_id: `safari_store_items_select`,
                label: '‚¨Ö Cancel',
                style: 2
              },
              {
                type: 2, // Button
                custom_id: `safari_confirm_delete_store_${storeId}`,
                label: 'Delete Store',
                style: 4, // Red/Destructive style
                emoji: { name: 'üóëÔ∏è' }
              }
            ]
          }
        ];
        
        const container = {
          type: 17, // Container
          accent_color: 0xe74c3c, // Red accent for danger
          components: containerComponents
        };
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            flags: (1 << 15), // IS_COMPONENTS_V2
            components: [container]
          }
        });
        
      } catch (error) {
        console.error('Error in safari_store_delete handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error loading delete confirmation.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_confirm_delete_store_')) {
      // Handle confirmed store deletion
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to delete stores.')) return;
        
        // Parse storeId from custom_id
        const storeId = custom_id.replace('safari_confirm_delete_store_', '');
        console.log(`üóëÔ∏è DEBUG: Confirming delete for store ${storeId} by user ${userId}`);
        
        // Import Safari manager functions
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        
        if (!safariData[guildId]?.stores?.[storeId]) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const storeName = safariData[guildId].stores[storeId].name;
        
        // Delete the store - completely remove it from safariContent.json
        delete safariData[guildId].stores[storeId];
        
        // Save updated data
        await saveSafariContent(safariData);
        
        console.log(`üóëÔ∏è DEBUG: Deleted store ${storeId} (${storeName}) completely`);
        
        // Return to store management with success message
        const containerComponents = [
          {
            type: 10, // Text Display
            content: `## ‚úÖ Store Deleted Successfully\n\n**${storeName}** has been permanently deleted from the system.`
          },
          {
            type: 14 // Separator
          },
          {
            type: 1, // Action Row
            components: [{
              type: 2, // Button
              custom_id: 'prod_safari_menu',
              label: '‚¨Ö Back to Safari',
              style: 2
            }]
          }
        ];
        
        const container = {
          type: 17, // Container
          accent_color: 0x27ae60, // Green accent for success
          components: containerComponents
        };
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            flags: (1 << 15), // IS_COMPONENTS_V2
            components: [container]
          }
        });
        
      } catch (error) {
        console.error('Error confirming store deletion:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error deleting store. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_store_post_channel_')) {
      // Handle channel selection for posting store button
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const data = req.body.data;
        const selectedChannelId = data.values[0];
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to post store buttons.')) return;
        
        // Parse storeId from custom_id
        const storeId = custom_id.replace('safari_store_post_channel_', '');
        console.log(`üì§ DEBUG: Posting store ${storeId} button to channel ${selectedChannelId}`);
        
        // Import Safari manager functions
        const { loadSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const store = safariData[guildId]?.stores?.[storeId];
        
        if (!store) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Build store card to post to channel (Components V2)
        const { getCustomTerms } = await import('./safariManager.js');
        const customTerms = await getCustomTerms(guildId);
        const itemCount = (store.items || []).length;
        const storeCard = {
          type: 17, // Container
          accent_color: store.settings?.accentColor || 0x3498db,
          components: [
            {
              type: 10, // Text Display
              content: `## ${store.emoji || 'üè™'} ${store.name}\n\n${store.settings?.storeownerText || 'Welcome to the store!'}\n\n> üì¶ **${itemCount}** items available`
            },
            { type: 14 }, // Separator
            {
              type: 1, // Action Row
              components: [{
                type: 2, // Button
                custom_id: `safari_store_browse_${guildId}_${storeId}`,
                label: `Browse ${store.name}`.slice(0, 80),
                style: 1,
                emoji: store.emoji ? (parseTextEmoji(store.emoji)?.emoji || { name: 'üè™' }) : { name: 'üè™' }
              }]
            }
          ]
        };

        // Post store card to selected channel via REST API (Components V2 requires raw API, not Discord.js)
        try {
          await DiscordRequest(`channels/${selectedChannelId}/messages`, {
            method: 'POST',
            body: {
              flags: (1 << 15), // IS_COMPONENTS_V2
              components: [storeCard]
            }
          });

          return res.send({
            type: InteractionResponseType.UPDATE_MESSAGE,
            data: {
              components: [{
                type: 17, // Container
                accent_color: 0x00ff00, // Green
                components: [{
                  type: 10, // Text Display
                  content: `## ‚úÖ Store Button Posted!\n\n**${store.emoji || 'üè™'} ${store.name}** has been posted to <#${selectedChannelId}>.`
                }, {
                  type: 14 // Separator
                }, {
                  type: 1, // Action Row
                  components: [{
                    type: 2, // Button
                    custom_id: 'safari_store_manage_items',
                    label: '‚Üê Store Management',
                    style: 2
                  }]
                }]
              }]
            }
          });
        } catch (postError) {
          console.error('Error posting store button to channel:', postError);
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error posting button to channel. Make sure the bot has permission to send messages in that channel.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
      } catch (error) {
        console.error('Error in safari_store_post_channel handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error posting store button.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_button_manage_existing') {
      // Edit existing button interface following store/item pattern
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to edit buttons.')) return;
        
        console.log(`‚úèÔ∏è DEBUG: Edit existing button clicked for guild ${guildId}`);
        
        // Import Safari manager functions
        const { loadSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const buttons = safariData[guildId]?.buttons || {};
        
        if (Object.keys(buttons).length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå **No buttons to edit**\n\nCreate your first custom button before you can edit existing ones.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Create button selection dropdown
        const buttonOptions = Object.entries(buttons).slice(0, 25).map(([buttonId, button]) => ({
          label: `${button.emoji || 'üîò'} ${button.label}`.slice(0, 100),
          value: buttonId,
          description: `${button.actions?.length || 0} action${(button.actions?.length || 0) !== 1 ? 's' : ''} | Used ${button.metadata?.usageCount || 0} times`.slice(0, 100)
        }));
        
        const buttonSelect = new StringSelectMenuBuilder()
          .setCustomId('safari_button_edit_select')
          .setPlaceholder('Choose a button to edit...')
          .setMinValues(1)
          .setMaxValues(1)
          .addOptions(buttonOptions);
        
        const selectRow = new ActionRowBuilder().addComponents(buttonSelect);
        
        // Create back button
        const backButton = new ButtonBuilder()
          .setCustomId('safari_manage_safari_buttons')
          .setLabel('‚¨Ö Back to Button Management')
          .setStyle(ButtonStyle.Secondary);
        
        const backRow = new ActionRowBuilder().addComponents(backButton);
        
        // Create response with Components V2
        const containerComponents = [
          {
            type: 10, // Text Display component
            content: `## ‚úèÔ∏è Edit Existing Button\n\nSelect a button to edit from the dropdown below:`
          },
          selectRow.toJSON(), // Button selection dropdown
          {
            type: 14 // Separator
          },
          backRow.toJSON() // Back button
        ];
        
        const container = {
          type: 17, // Container component
          accent_color: 0xf39c12, // Orange accent color for editing
          components: containerComponents
        };
        
        const userId = req.body.member?.user?.id || req.body.user?.id;
        console.log(`‚úÖ SUCCESS: safari_button_manage_existing completed for user ${userId}`);
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15), // IS_COMPONENTS_V2 flag
            components: [container]
          }
        });
        
      } catch (error) {
        console.error('Error in safari_button_manage_existing:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error loading button editor.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_button_edit_select') {
      // Handle button selection for editing
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const data = req.body.data;
        const selectedButtonId = data.values[0];
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to edit buttons.')) return;
        
        console.log(`‚úèÔ∏è DEBUG: Selected button ${selectedButtonId} for editing`);
        
        // Import Safari manager functions and universal edit framework
        const { getCustomButton } = await import('./safariManager.js');
        const { EditInterfaceBuilder, EDIT_TYPES } = await import('./editFramework.js');
        
        const button = await getCustomButton(guildId, selectedButtonId);
        
        if (!button) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Button not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log('üéõÔ∏è DEBUG: Creating edit interface for button:', selectedButtonId);
        
        // Create universal edit interface for buttons
        const editBuilder = new EditInterfaceBuilder(EDIT_TYPES.BUTTON);
        const editInterface = editBuilder.createEditInterface(button, selectedButtonId);
        
        // Add back button
        editInterface.components[0].components.push({
          type: 1, // Action Row
          components: [{
            type: 2, // Button
            custom_id: 'safari_button_manage_existing',
            label: '‚¨Ö Back to Button List',
            style: 2,
            emoji: { name: 'üîô' }
          }]
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: editInterface
        });
        
      } catch (error) {
        console.error('Error in safari_button_edit_select:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error loading button details.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    // ===================================================================
    // EDIT FRAMEWORK HANDLERS - Phase 1A: Action Management
    // ===================================================================
    } else if (custom_id.startsWith('safari_action_move_up_')) {
      // Handle moving action up
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to reorder actions.')) return;
        
        // Parse custom_id: safari_action_move_up_buttonId_actionIndex
        const parts = custom_id.split('_');
        const buttonId = parts.slice(4, -1).join('_');
        const actionIndex = parseInt(parts[parts.length - 1]);
        
        console.log(`‚¨ÜÔ∏è DEBUG: Moving action ${actionIndex} up for button ${buttonId}`);
        
        if (actionIndex <= 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action is already at the top.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Import action management functions
        const { reorderButtonAction } = await import('./safariManager.js');
        const success = await reorderButtonAction(guildId, buttonId, actionIndex, actionIndex - 1);
        
        if (!success) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Failed to reorder action.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Refresh the edit interface
        const { getCustomButton } = await import('./safariManager.js');
        const { EditInterfaceBuilder, EDIT_TYPES } = await import('./editFramework.js');
        
        const button = await getCustomButton(guildId, buttonId);
        const editBuilder = new EditInterfaceBuilder(EDIT_TYPES.BUTTON);
        const editInterface = editBuilder.createEditInterface(button, buttonId);
        
        // Add back button
        editInterface.components[0].components.push({
          type: 1, // Action Row
          components: [{
            type: 2, // Button
            custom_id: 'safari_button_manage_existing',
            label: '‚¨Ö Back to Button List',
            style: 2,
            emoji: { name: 'üîô' }
          }]
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: editInterface
        });
        
      } catch (error) {
        console.error('Error moving action up:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error reordering action.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_action_move_down_')) {
      // Handle moving action down
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to reorder actions.')) return;
        
        // Parse custom_id: safari_action_move_down_buttonId_actionIndex
        const parts = custom_id.split('_');
        const buttonId = parts.slice(4, -1).join('_');
        const actionIndex = parseInt(parts[parts.length - 1]);
        
        console.log(`‚¨áÔ∏è DEBUG: Moving action ${actionIndex} down for button ${buttonId}`);
        
        // Get button to check if it's the last action
        const { getCustomButton } = await import('./safariManager.js');
        const button = await getCustomButton(guildId, buttonId);
        
        if (actionIndex >= button.actions.length - 1) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action is already at the bottom.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Import action management functions
        const { reorderButtonAction } = await import('./safariManager.js');
        const success = await reorderButtonAction(guildId, buttonId, actionIndex, actionIndex + 1);
        
        if (!success) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Failed to reorder action.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Refresh the edit interface
        const { EditInterfaceBuilder, EDIT_TYPES } = await import('./editFramework.js');
        
        const updatedButton = await getCustomButton(guildId, buttonId);
        const editBuilder = new EditInterfaceBuilder(EDIT_TYPES.BUTTON);
        const editInterface = editBuilder.createEditInterface(updatedButton, buttonId);
        
        // Add back button
        editInterface.components[0].components.push({
          type: 1, // Action Row
          components: [{
            type: 2, // Button
            custom_id: 'safari_button_manage_existing',
            label: '‚¨Ö Back to Button List',
            style: 2,
            emoji: { name: 'üîô' }
          }]
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: editInterface
        });
        
      } catch (error) {
        console.error('Error moving action down:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error reordering action.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_edit_properties_')) {
      // Button property editing using universal framework
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to edit properties.')) return;
        
        const buttonId = custom_id.replace('safari_edit_properties_', '');
        console.log(`üìù DEBUG: Edit properties clicked for button ${buttonId}`);
        
        // Import functions
        const { getCustomButton } = await import('./safariManager.js');
        const { PropertiesEditor, EDIT_TYPES } = await import('./editFramework.js');
        
        const button = await getCustomButton(guildId, buttonId);
        
        if (!button) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Button not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Create properties edit modal
        const propertiesEditor = new PropertiesEditor(EDIT_TYPES.BUTTON);
        const modal = await propertiesEditor.createPropertiesModal(button, buttonId);
        
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal.toJSON()
        });
        
      } catch (error) {
        console.error('Error in safari_button_edit_properties:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error loading property editor.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_action_edit_')) {
      // Handle editing individual actions
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to edit actions.')) return;
        
        // Parse custom_id: safari_action_edit_buttonId_actionIndex
        const parts = custom_id.split('_');
        const buttonId = parts.slice(3, -1).join('_');
        const actionIndex = parseInt(parts[parts.length - 1]);
        
        console.log(`‚úèÔ∏è DEBUG: Editing action ${actionIndex} for button ${buttonId}`);
        
        // Get current action data
        const { getCustomButton } = await import('./safariManager.js');
        const button = await getCustomButton(guildId, buttonId);
        
        if (!button || !button.actions || actionIndex >= button.actions.length) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const action = button.actions[actionIndex];
        
        // Create edit modal based on action type (reuse existing modal system)
        const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = await import('discord.js');
        
        const modal = new ModalBuilder()
          .setCustomId(`safari_edit_action_modal_${buttonId}_${actionIndex}_${action.type}`)
          .setTitle(`Edit ${action.type.replace('_', ' ')} Action`);
        
        const components = [];
        
        // Create fields based on action type
        if (action.type === 'display_text') {
          const titleInput = new TextInputBuilder()
            .setCustomId('action_title')
            .setLabel('Title (optional)')
            .setStyle(TextInputStyle.Short)
            .setMaxLength(100)
            .setRequired(false)
            .setValue(action.config.title || '');
          
          const contentInput = new TextInputBuilder()
            .setCustomId('action_content')
            .setLabel('Content')
            .setStyle(TextInputStyle.Paragraph)
            .setMaxLength(2000)
            .setRequired(true)
            .setValue(action.config.content || '');
          
          const colorInput = new TextInputBuilder()
            .setCustomId('action_color')
            .setLabel('Accent Color (optional)')
            .setPlaceholder('e.g., #3498db or 3447003')
            .setStyle(TextInputStyle.Short)
            .setRequired(false)
            .setMaxLength(10)
            .setValue(action.config.accentColor ? `#${action.config.accentColor.toString(16).padStart(6, '0')}` : '');
          
          components.push(
            new ActionRowBuilder().addComponents(titleInput),
            new ActionRowBuilder().addComponents(contentInput),
            new ActionRowBuilder().addComponents(colorInput)
          );
          
        } else if (action.type === 'update_currency') {
          const amountInput = new TextInputBuilder()
            .setCustomId('currency_amount')
            .setLabel('Currency Amount')
            .setStyle(TextInputStyle.Short)
            .setMaxLength(10)
            .setRequired(true)
            .setValue(String(action.config.amount || 0));
          
          const messageInput = new TextInputBuilder()
            .setCustomId('currency_message')
            .setLabel('Message (optional)')
            .setStyle(TextInputStyle.Short)
            .setMaxLength(200)
            .setRequired(false)
            .setValue(action.config.message || '');
          
          components.push(
            new ActionRowBuilder().addComponents(amountInput),
            new ActionRowBuilder().addComponents(messageInput)
          );
          
        } else {
          // For other action types, show a simple edit interface
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `üöß **Edit ${action.type} Action**\n\nEditing for this action type is not yet implemented. Please delete and recreate the action.`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        modal.addComponents(components);
        
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal.toJSON()
        });
        
      } catch (error) {
        console.error('Error editing action:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error loading action editor.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_action_delete_')) {
      // Handle deleting individual actions
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to delete actions.')) return;
        
        // Parse custom_id: safari_action_delete_buttonId_actionIndex
        const parts = custom_id.split('_');
        const buttonId = parts.slice(3, -1).join('_');
        const actionIndex = parseInt(parts[parts.length - 1]);
        
        console.log(`üóëÔ∏è DEBUG: Deleting action ${actionIndex} for button ${buttonId}`);
        
        // Delete the action
        const { deleteButtonAction } = await import('./safariManager.js');
        const success = await deleteButtonAction(guildId, buttonId, actionIndex);
        
        if (!success) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Failed to delete action.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Refresh the edit interface
        const { getCustomButton } = await import('./safariManager.js');
        const { EditInterfaceBuilder, EDIT_TYPES } = await import('./editFramework.js');
        
        const button = await getCustomButton(guildId, buttonId);
        const editBuilder = new EditInterfaceBuilder(EDIT_TYPES.BUTTON);
        const editInterface = editBuilder.createEditInterface(button, buttonId);
        
        // Add back button
        editInterface.components[0].components.push({
          type: 1, // Action Row
          components: [{
            type: 2, // Button
            custom_id: 'safari_button_manage_existing',
            label: '‚¨Ö Back to Button List',
            style: 2,
            emoji: { name: 'üîô' }
          }]
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: editInterface
        });
        
      } catch (error) {
        console.error('Error deleting action:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error deleting action.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_button_edit_actions_')) {
      // Button action management placeholder (Coming Soon)
      try {
        const buttonId = custom_id.replace('safari_button_edit_actions_', '');
        console.log(`‚öôÔ∏è DEBUG: Manage actions clicked for button ${buttonId}`);
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'üöß **Manage Actions - Coming Soon!**\n\nAdvanced action management will be available in a future update.\n\nFor now, you can create a new button and configure actions during creation.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in safari_button_edit_actions:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error loading action manager.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_test_button_')) {
      // Button test functionality using universal framework
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to test buttons.')) return;
        
        const buttonId = custom_id.replace('safari_test_button_', '');
        console.log(`üß™ DEBUG: Test button clicked for button ${buttonId}`);
        
        // Import functions 
        const { getCustomButton, executeButtonActions } = await import('./safariManager.js');
        
        const button = await getCustomButton(guildId, buttonId);
        
        if (!button) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Button not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Execute button actions as a test
        const userId = req.body.member?.user?.id || req.body.user?.id;
        const result = await executeButtonActions(guildId, buttonId, userId, req.body, client);
        
        // Add test indicator to the result
        const testResult = {
          ...result,
          content: `üß™ **TEST MODE**\n\n${result.content || ''}\n\n*This was a test execution. No permanent changes were made.*`
        };
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            ...testResult,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in safari_test_button:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error testing button.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_delete_button_')) {
      // Button deletion using universal framework
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to delete buttons.')) return;
        
        const buttonId = custom_id.replace('safari_delete_button_', '');
        console.log(`üóëÔ∏è DEBUG: Delete button clicked for button ${buttonId}`);
        
        // Import functions
        const { getCustomButton } = await import('./safariManager.js');
        const { DeleteConfirmation, EDIT_TYPES } = await import('./editFramework.js');
        
        const button = await getCustomButton(guildId, buttonId);
        
        if (!button) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Button not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Create delete confirmation interface
        const deleteConfirmation = new DeleteConfirmation(EDIT_TYPES.BUTTON);
        const confirmationInterface = deleteConfirmation.createDeleteConfirmation(button, buttonId);
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: confirmationInterface
        });
        
      } catch (error) {
        console.error('Error in safari_button_delete:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error loading delete interface.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_confirm_delete_button_')) {
      // Handle button delete confirmation
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to delete buttons.')) return;
        
        const buttonId = custom_id.replace('safari_confirm_delete_button_', '');
        console.log(`üóëÔ∏è DEBUG: Confirming delete for button ${buttonId} by user ${userId}`);
        
        // Import functions
        const { deleteCustomButton, getCustomButton } = await import('./safariManager.js');
        
        // Get button name for confirmation message
        const button = await getCustomButton(guildId, buttonId);
        const buttonName = button?.label || 'Unknown Button';
        
        // Delete the button
        const success = await deleteCustomButton(guildId, buttonId);
        
        if (!success) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Failed to delete button.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`‚úÖ SUCCESS: Button ${buttonName} (${buttonId}) deleted successfully`);
        
        // Return to button management interface
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            content: `‚úÖ Button **${buttonName}** has been deleted successfully.`,
            components: [{
              type: 1, // Action Row
              components: [{
                type: 2, // Button
                custom_id: 'safari_button_manage_existing',
                label: '‚¨Ö Back to Button Management',
                style: 2,
                emoji: { name: 'üîô' }
              }]
            }],
            flags: (1 << 15) // IS_COMPONENTS_V2
          }
        });
        
      } catch (error) {
        console.error('Error in safari_confirm_delete_button:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error deleting button.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_currency_view_all') {
      // Handle View All Currency Balances (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_currency_view_all',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        ephemeral: true,
        handler: async (context) => {
          console.log('üë• DEBUG: View All Currency Balances clicked');
          
          const playerData = await loadPlayerData();
          const guildPlayers = playerData[context.guildId]?.players || {};
          const playersWithCurrency = Object.entries(guildPlayers)
            .filter(([userId, player]) => player.safari?.currency !== undefined)
            .sort(([, a], [, b]) => (b.safari?.currency || 0) - (a.safari?.currency || 0));
          
          let contentText = '## üë• All Currency Balances\n\n';

          if (playersWithCurrency.length === 0) {
            contentText += '*No players have currency yet.*\n\nPlayers will appear here once they interact with Safari buttons that grant currency.';
          } else {
            contentText += `**Total Players:** ${playersWithCurrency.length}\n\n`;
            playersWithCurrency.forEach(([userId, player], index) => {
              const rank = index + 1;
              const currency = player.safari?.currency || 0;
              const lastInteraction = player.safari?.lastInteraction
                ? new Date(player.safari.lastInteraction).toLocaleDateString()
                : 'Unknown';
              contentText += `**${rank}.** <@${userId}>\n`;
              contentText += `‚îî Balance: **${currency} coins** | Last active: ${lastInteraction}\n\n`;
            });
          }

          // Return Components V2 format for proper ephemeral support
          return {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17, // Container
              accent_color: 0xf1c40f, // Gold color
              components: [
                {
                  type: 10, // Text Display
                  content: contentText
                }
              ]
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_currency_set_player') {
      // Handle Set Player Currency - show user select and modal (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_currency_set_player',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log('üí∞ DEBUG: Set Player Currency clicked');
          
          // Create user selection dropdown
          const userSelect = new UserSelectMenuBuilder()
            .setCustomId('safari_currency_select_user')
            .setPlaceholder('Choose a player to set currency for...')
            .setMinValues(1)
            .setMaxValues(1);
          
          const userSelectRow = new ActionRowBuilder().addComponents(userSelect);
          
          // Create cancel button
          const cancelButton = new ButtonBuilder()
            .setCustomId('safari_manage_currency')
            .setLabel('‚¨Ö Back')
            .setStyle(ButtonStyle.Secondary);
          
          const cancelRow = new ActionRowBuilder().addComponents(cancelButton);
          
          // Create response with Components V2
          const containerComponents = [
            {
              type: 10, // Text Display component
              content: `## üí∞ Set Player Currency\n\nSelect a player to modify their currency balance:`
            },
            userSelectRow.toJSON(), // User selection dropdown
            {
              type: 14 // Separator
            },
            cancelRow.toJSON() // Back button
          ];
          
          const container = {
            type: 17, // Container component
            accent_color: 0xf1c40f, // Gold accent color
            components: containerComponents
          };
          
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2 flag
            components: [container]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_currency_reset_all') {
      // Handle Reset All Currency - confirmation dialog (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_currency_reset_all',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log('üóëÔ∏è DEBUG: Reset All Currency clicked');
          
          const playerData = await loadPlayerData();
          const guildPlayers = playerData[context.guildId]?.players || {};
          const playersWithCurrency = Object.entries(guildPlayers)
            .filter(([userId, player]) => player.safari?.currency !== undefined);
          
          if (playersWithCurrency.length === 0) {
            return {
              content: '‚ùå **No currency to reset**\n\nNo players have currency balances to reset.',
              ephemeral: true
            };
          }
          
          // Create confirmation buttons
          const confirmButton = new ButtonBuilder()
            .setCustomId('safari_currency_reset_confirm')
            .setLabel('Yes, Reset All Currency')
            .setStyle(ButtonStyle.Danger)
            .setEmoji('üóëÔ∏è');
          
          const cancelButton = new ButtonBuilder()
            .setCustomId('safari_manage_currency')
            .setLabel('Cancel')
            .setStyle(ButtonStyle.Secondary)
            .setEmoji('‚ùå');
          
          const confirmRow = new ActionRowBuilder().addComponents(confirmButton, cancelButton);
          
          const totalCurrency = playersWithCurrency.reduce((sum, [, player]) => sum + (player.safari?.currency || 0), 0);
          
          // Create response with Components V2
          const containerComponents = [
            {
              type: 10, // Text Display component
              content: `## üóëÔ∏è Reset All Currency\n\n‚ö†Ô∏è **Warning: This action cannot be undone!**`
            },
            {
              type: 10, // Text Display component
              content: `> **Players affected:** ${playersWithCurrency.length}\n> **Total currency to be reset:** ${totalCurrency} coins`
            },
            {
              type: 10, // Text Display component
              content: `**Are you sure you want to reset all player currency to 0?**`
            },
            {
              type: 14 // Separator
            },
            confirmRow.toJSON() // Confirmation buttons
          ];
          
          const container = {
            type: 17, // Container component
            accent_color: 0xe74c3c, // Red accent color for warning
            components: containerComponents
          };
          
          return {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + Ephemeral
            components: [container]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_view_player_inventory') {
      // Handle View Player Inventory - show user select for inventory viewing (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_view_player_inventory',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log('üëÄ DEBUG: View Player Inventory clicked');
          
          // Create user selection dropdown
          const userSelect = new UserSelectMenuBuilder()
            .setCustomId('safari_inventory_user_select')
            .setPlaceholder('Choose a player to view their inventory...')
            .setMinValues(1)
            .setMaxValues(1);
          
          const userSelectRow = new ActionRowBuilder().addComponents(userSelect);
          
          // Create cancel button (back to safari menu)
          const cancelButton = new ButtonBuilder()
            .setCustomId('prod_safari_menu')
            .setLabel('‚¨Ö Back to Safari')
            .setStyle(ButtonStyle.Secondary);
          
          const cancelRow = new ActionRowBuilder().addComponents(cancelButton);
          
          // Create response with Components V2
          const containerComponents = [
            {
              type: 10, // Text Display component
              content: `## üëÄ View Player Inventory\n\nSelect a player to view their complete inventory:`
            },
            userSelectRow.toJSON(), // User selection dropdown
            {
              type: 14 // Separator
            },
            cancelRow.toJSON() // Back button
          ];
          
          const container = {
            type: 17, // Container component
            accent_color: 0x9b59b6, // Purple accent color for viewing
            components: containerComponents
          };
          
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2 flag
            components: [container]
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_item_player_qty_')) {
      // Handle Player Qty button click - show user select for item quantity management (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_item_player_qty',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const itemId = context.customId.replace('safari_item_player_qty_', '');
          
          console.log(`üì¶ DEBUG: Player Qty clicked for item ${itemId}`);
          
          // Load item data to get item name
          const { loadEntity } = await import('./entityManager.js');
          const item = await loadEntity(context.guildId, 'item', itemId);
          console.log(`üì¶ DEBUG: loadEntity result for item ${itemId}:`, item);
          const itemName = item?.name || 'Unknown Item';
          
          console.log(`üì¶ DEBUG: About to create user selection dropdown`);
          
          // Create user selection dropdown
          const userSelect = new UserSelectMenuBuilder()
            .setCustomId(`safari_item_qty_user_select_${context.guildId}_${itemId}`)
            .setPlaceholder(`Choose a player to manage their ${itemName} balance...`)
            .setMinValues(1)
            .setMaxValues(1);
          
          const userSelectRow = new ActionRowBuilder().addComponents(userSelect);
          
          console.log(`üì¶ DEBUG: User select created, about to create cancel button`);
          
          // Create cancel button (back to entity management)
          const cancelButton = new ButtonBuilder()
            .setCustomId(`entity_edit_mode_item_${itemId}`)
            .setLabel('‚¨Ö Back')
            .setStyle(ButtonStyle.Secondary);
          
          const cancelRow = new ActionRowBuilder().addComponents(cancelButton);
          
          console.log(`üì¶ DEBUG: Cancel button created, about to build response`);
          
          // Create response with Components V2
          const containerComponents = [
            {
              type: 10, // Text Display component
              content: `## üì¶ Manage Player Items\n\nSelect a player to manage how many **${itemName}** they have:`
            },
            userSelectRow.toJSON(), // User selection dropdown
            {
              type: 14 // Separator
            },
            cancelRow.toJSON() // Back button
          ];
          
          // Get entity accent color or default to blue
          const accentColor = item?.accentColor || 0x3498db;
          
          const container = {
            type: 17, // Container component
            accent_color: accentColor,
            components: containerComponents
          };
          
          console.log(`üì¶ DEBUG: About to send response`);
          
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2 flag
            components: [container],
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_action_type_select_')) {
      // Handle string select for action types
      return ButtonHandlerFactory.create({
        id: 'safari_action_type_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true, // Dismiss previous entity when showing new interface
        handler: async (context) => {
          console.log(`üîç START: safari_action_type_select - user ${context.userId}`);
          
          // Extract button ID and action type
          const buttonId = context.customId.replace('safari_action_type_select_', '');
          const actionType = req.body.data.values[0];
          
          console.log(`Selected action type: ${actionType} for button: ${buttonId}`);
          
          // Load safari content
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          
          // Custom actions are stored under guild > buttons
          const buttons = safariData[context.guildId]?.buttons || {};
          const button = buttons[buttonId];
          
          if (!button) {
            console.error(`Button not found: ${buttonId} in guild ${context.guildId}`);
            console.log('Available buttons:', Object.keys(buttons).slice(0, 10));
            return {
              content: '‚ùå Custom action not found.',
              ephemeral: true
            };
          }
          
          // Handle give_item and give_currency differently - show select interface instead of modal
          if (actionType === 'give_item') {
            // Load items
            const items = safariData[context.guildId]?.items || {};
            const itemCount = Object.keys(items).length;
            
            if (itemCount === 0) {
              return {
                content: '‚ùå No items available. Create items first using Safari menu.',
                ephemeral: true
              };
            }
            
            // Create item options array
            const itemOptions = [];
            
            // Add search option if more than 10 items
            if (itemCount > 10) {
              itemOptions.push({
                label: 'üîç Search: "Type to search..."',
                value: 'search_entities',
                description: 'Click to search items'
              });
            }
            
            // Add item options (limited to remaining slots after search option)
            const maxItems = itemCount > 10 ? 24 : 25; // Leave room for search option
            Object.entries(items).slice(0, maxItems).forEach(([itemId, item]) => {
              const { cleanText, emoji } = parseTextEmoji(`${item.emoji || ''} ${item.name}`, 'üì¶');
              const safeCleanText = cleanText || `${item.emoji || 'üì¶'} ${item.name || 'Unnamed Item'}`;
              itemOptions.push({
                label: safeCleanText.substring(0, 100),
                value: itemId,
                description: item.description?.substring(0, 100),
                emoji: emoji
              });
            });
            
            console.log(`‚úÖ SUCCESS: safari_action_type_select - showing item selection for give_item`);
            
            return {
              components: [{
                type: 17, // Container
                components: [
                  {
                    type: 10, // Text Display
                    content: `## Item`
                  },
                  { type: 14 }, // Separator
                  {
                    type: 1, // Action Row
                    components: [{
                      type: 3, // String Select
                      custom_id: `safari_give_item_select_${buttonId}`,
                      placeholder: `Select item to give...`,
                      options: itemOptions
                    }]
                  }
                ]
              }],
              flags: (1 << 15), // IS_COMPONENTS_V2
              ephemeral: true
            };
          } else if (actionType === 'give_currency') {
            // Show currency configuration directly (no item selection needed)
            const { getCustomTerms } = await import('./safariManager.js');
            const customTerms = await getCustomTerms(context.guildId);
            
            console.log(`‚úÖ SUCCESS: safari_action_type_select - showing currency config`);
            
            // Create a temporary action config to show the configuration UI
            const tempActionIndex = button.actions?.length || 0;
            
            return await showGiveCurrencyConfig(context.guildId, buttonId, tempActionIndex, customTerms);
          } else if (actionType === 'follow_up_button') {
            // Get existing buttons to show in dropdown
            const { loadSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const buttons = safariData[context.guildId]?.buttons || {};
            
            // Filter out current button and sort chronologically (most recent first)
            const availableButtons = Object.entries(buttons)
              .filter(([id, btn]) => id !== buttonId)
              .sort((a, b) => {
                const aLastModified = a[1].metadata?.lastModified || 0;
                const bLastModified = b[1].metadata?.lastModified || 0;
                return bLastModified - aLastModified; // Descending order (newest first)
              })
              .slice(0, 25); // Discord limit
            
            if (availableButtons.length === 0) {
              return {
                content: '‚ùå **No other buttons available**\n\nYou need to create at least one other button before adding follow-up actions. Create another button first, then come back to add the follow-up.',
                ephemeral: true
              };
            }
            
            // Create options for button selection
            const buttonOptions = [];
            
            // Add search option if many buttons
            if (availableButtons.length > 10) {
              buttonOptions.push({
                label: 'üîç Search Actions',
                value: 'search_follow_up_actions',
                description: 'Search through available actions',
                emoji: { name: 'üîç' }
              });
            }
            
            // Add available buttons (limited to leave room for search)
            const buttonLimit = availableButtons.length > 10 ? 24 : 25;
            availableButtons.slice(0, buttonLimit).forEach(([id, btn]) => {
              buttonOptions.push({
                label: (btn.name || btn.label || id).substring(0, 100),
                value: id,
                description: (`ID: ${id}` + (btn.actions?.length ? ` ‚Ä¢ ${btn.actions.length} actions` : '')).substring(0, 100),
                emoji: { name: 'üîó' }
              });
            });
            
            console.log(`‚úÖ SUCCESS: safari_action_type_select - showing button selection for follow_up_button`);
            
            return {
              components: [{
                type: 17, // Container
                accent_color: 0x8B5CF6, // Purple accent for follow-up actions
                components: [
                  {
                    type: 10, // Text Display
                    content: `# Select Follow-up Action for ${button.name || 'Custom Action'}\n\nChoose which action should be triggered after this action completes.`
                  },
                  { type: 14 }, // Separator
                  {
                    type: 1, // Action Row
                    components: [{
                      type: 3, // String Select
                      custom_id: `safari_follow_up_select_${buttonId}`,
                      placeholder: 'Select action to chain to...',
                      options: buttonOptions
                    }]
                  }
                ]
              }],
              flags: (1 << 15), // IS_COMPONENTS_V2
              ephemeral: true
            };
          } else if (actionType === 'give_role') {
            console.log(`‚úÖ SUCCESS: safari_action_type_select - showing role selection for give_role`);
            
            // Create role select menu for give_role
            const { RoleSelectMenuBuilder, ActionRowBuilder } = await import('discord.js');
            
            const roleSelect = new RoleSelectMenuBuilder()
              .setCustomId(`safari_give_role_select_${buttonId}`)
              .setPlaceholder('Select a role to give')
              .setMinValues(1)
              .setMaxValues(1);
            
            const row = new ActionRowBuilder()
              .addComponents(roleSelect);
            
            return {
              components: [{
                type: 17, // Container
                accent_color: 0x10B981, // Green accent for give role
                components: [
                  {
                    type: 10, // Text Display
                    content: `# Select Role to Give\n\nChoose which role to give to users when they click this button (and meet the conditions).`
                  },
                  { type: 14 }, // Separator
                  row.toJSON()
                ]
              }],
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
              ephemeral: true
            };
            
          } else if (actionType === 'remove_role') {
            console.log(`‚úÖ SUCCESS: safari_action_type_select - showing role selection for remove_role`);
            
            // Create role select menu for remove_role
            const { RoleSelectMenuBuilder, ActionRowBuilder } = await import('discord.js');
            
            const roleSelect = new RoleSelectMenuBuilder()
              .setCustomId(`safari_remove_role_select_${buttonId}`)
              .setPlaceholder('Select a role to remove')
              .setMinValues(1)
              .setMaxValues(1);
            
            const row = new ActionRowBuilder()
              .addComponents(roleSelect);
            
            return {
              components: [{
                type: 17, // Container
                accent_color: 0xEF4444, // Red accent for remove role
                components: [
                  {
                    type: 10, // Text Display
                    content: `# Select Role to Remove\n\nChoose which role to remove from users when they click this button (and meet the conditions).`
                  },
                  { type: 14 }, // Separator
                  row.toJSON()
                ]
              }],
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
              ephemeral: true
            };
          }
          
          // For display_text, show new entity interface
          if (actionType === 'display_text') {
            // Determine the action index for new action
            const { loadSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const currentButton = safariData[context.guildId]?.buttons?.[buttonId];
            const actionIndex = currentButton?.actions?.length || 0;

            console.log(`‚úÖ SUCCESS: safari_action_type_select - showing display_text entity for ${buttonId}[${actionIndex}]`);
            const { showDisplayTextConfig } = await import('./customActionUI.js');
            return await showDisplayTextConfig(context.guildId, buttonId, actionIndex);

          // For calculate_results, show new entity interface
          } else if (actionType === 'calculate_results') {
            // Load safari content to create the action
            const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const currentButton = safariData[context.guildId]?.buttons?.[buttonId];

            if (!currentButton) {
              return {
                content: '‚ùå Button not found.',
                ephemeral: true
              };
            }

            const actionIndex = currentButton?.actions?.length || 0;

            // Create the action immediately with default values (eager save pattern)
            if (!currentButton.actions) {
              currentButton.actions = [];
            }

            // Only create if it doesn't already exist
            if (!currentButton.actions[actionIndex]) {
              currentButton.actions[actionIndex] = {
                type: 'calculate_results',
                order: actionIndex,
                config: {
                  scope: 'all_players'
                },
                executeOn: 'true'
              };

              // Save immediately
              await saveSafariContent(safariData);
              console.log(`üíæ SAVED: safari_action_type_select - created calculate_results action with defaults for ${buttonId}[${actionIndex}]`);
            }

            console.log(`‚úÖ SUCCESS: safari_action_type_select - showing calculate_results entity for ${buttonId}[${actionIndex}]`);
            const { showCalculateResultsConfig } = await import('./customActionUI.js');
            return await showCalculateResultsConfig(context.guildId, buttonId, actionIndex);

          // For calculate_attack, show new entity interface
          } else if (actionType === 'calculate_attack') {
            // Load safari content to create the action
            const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const currentButton = safariData[context.guildId]?.buttons?.[buttonId];

            if (!currentButton) {
              return {
                content: '‚ùå Button not found.',
                ephemeral: true
              };
            }

            const actionIndex = currentButton?.actions?.length || 0;

            // Create the action immediately with default values (eager save pattern)
            if (!currentButton.actions) {
              currentButton.actions = [];
            }

            // Only create if it doesn't already exist
            if (!currentButton.actions[actionIndex]) {
              currentButton.actions[actionIndex] = {
                type: 'calculate_attack',
                order: actionIndex,
                config: {
                  playerScope: 'all_players',
                  displayMode: 'silent'
                },
                executeOn: 'true'
              };

              // Save immediately
              await saveSafariContent(safariData);
              console.log(`üíæ SAVED: safari_action_type_select - created calculate_attack action with defaults for ${buttonId}[${actionIndex}]`);
            }

            console.log(`‚úÖ SUCCESS: safari_action_type_select - showing calculate_attack entity for ${buttonId}[${actionIndex}]`);
            const { showCalculateAttackConfig } = await import('./customActionUI.js');
            return await showCalculateAttackConfig(context.guildId, buttonId, actionIndex);

          // For modify_attribute, show new entity interface
          } else if (actionType === 'modify_attribute') {
            // Load safari content to create the action
            const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const currentButton = safariData[context.guildId]?.buttons?.[buttonId];

            if (!currentButton) {
              return {
                content: '‚ùå Button not found.',
                ephemeral: true
              };
            }

            const actionIndex = currentButton?.actions?.length || 0;

            // Create the action immediately with default values (eager save pattern)
            if (!currentButton.actions) {
              currentButton.actions = [];
            }

            // Only create if it doesn't already exist
            if (!currentButton.actions[actionIndex]) {
              currentButton.actions[actionIndex] = {
                type: 'modify_attribute',
                order: actionIndex,
                config: {
                  attributeId: '',
                  operation: 'add',
                  amount: 0,
                  displayMode: 'silent'
                },
                executeOn: 'true'
              };

              // Save immediately
              await saveSafariContent(safariData);
              console.log(`üíæ SAVED: safari_action_type_select - created modify_attribute action with defaults for ${buttonId}[${actionIndex}]`);
            }

            console.log(`‚úÖ SUCCESS: safari_action_type_select - showing modify_attribute entity for ${buttonId}[${actionIndex}]`);
            const { showModifyAttributeConfig } = await import('./customActionUI.js');
            return await showModifyAttributeConfig(context.guildId, buttonId, actionIndex);

          // For update_currency, delegate to safari_add_action handler
          } else if (actionType === 'update_currency') {
            // Simulate the safari_add_action custom_id and call its handler
            const simulatedCustomId = `safari_add_action_${buttonId}_${actionType}`;
            req.body.data.custom_id = simulatedCustomId;
            
            // Find and execute the safari_add_action handler
            const addActionHandler = client._events.interactionCreate?.find(h => 
              h.toString().includes('safari_add_action_')
            );
            
            // Actually, let's just return the response that would trigger the correct handler
            // The front-end will re-submit with the correct custom_id
            console.log(`‚úÖ SUCCESS: safari_action_type_select - delegating to safari_add_action for ${actionType}`);
            
            // Close the current interaction and trigger the add action handler
            // by simulating a button click on the add action button
            const virtualButton = {
              custom_id: `safari_add_action_${buttonId}_${actionType}`,
              type: 2
            };
            
            // Create the modal for update_currency
            const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = await import('discord.js');
            
            if (actionType === 'update_currency') {
              const modal = new ModalBuilder()
                .setCustomId(`safari_action_modal_${buttonId}_update_currency`)
                .setTitle('Add Currency Change Action');

              const amountInput = new TextInputBuilder()
                .setCustomId('action_amount')
                .setLabel('Currency Amount')
                .setPlaceholder('e.g., 100 or -50 (positive adds, negative subtracts)')
                .setStyle(TextInputStyle.Short)
                .setRequired(true)
                .setMaxLength(10);

              const messageInput = new TextInputBuilder()
                .setCustomId('action_message')
                .setLabel('Message to Player')
                .setPlaceholder('e.g., "You found a treasure chest!"')
                .setStyle(TextInputStyle.Paragraph)
                .setRequired(true)
                .setMaxLength(200);

              modal.addComponents(
                new ActionRowBuilder().addComponents(amountInput),
                new ActionRowBuilder().addComponents(messageInput)
              );
              
              console.log(`‚úÖ SUCCESS: safari_action_type_select - showing update_currency modal`);
              return {
                type: InteractionResponseType.MODAL,
                data: modal.toJSON()
              };
            }
          } else if (actionType === 'calculate_results') {
            // Calculate Results action - simple action with no configuration needed
            console.log(`‚úÖ SUCCESS: safari_action_type_select - adding calculate_results action`);

            // Load safari content to add the action
            const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();

            // Ensure button exists
            if (!safariData[context.guildId]?.buttons?.[buttonId]) {
              return {
                content: '‚ùå Button not found.',
                ephemeral: true
              };
            }

            // Create the calculate_results action
            const newAction = {
              type: 'calculate_results',
              executeOn: 'true',
              order: button.actions?.length || 0
            };

            // Add action to button
            if (!button.actions) button.actions = [];
            button.actions.push(newAction);

            // Save changes
            await saveSafariContent(safariData);

            // Show updated Custom Action editor
            const { createCustomActionEditorUI } = await import('./customActionUI.js');
            return await createCustomActionEditorUI({ guildId: context.guildId, actionId: buttonId });
          }

          // Should not reach here for display_text or update_currency
          console.error(`Unknown action type: ${actionType}`);
          return {
            content: '‚ùå Unknown action type.',
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_give_item_select_')) {
      // Handle item selection for give_item action
      return ButtonHandlerFactory.create({
        id: 'safari_give_item_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const buttonId = context.customId.replace('safari_give_item_select_', '');
          const itemId = context.values?.[0];
          
          if (!itemId) {
            return {
              content: '‚ùå No item selected.',
              ephemeral: true
            };
          }
          
          // Handle search option - Show search modal
          if (itemId === 'search_entities') {
            console.log(`üîç SEARCH: safari_give_item_select - showing all items for ${buttonId}`);
            
            // Load all items
            const { loadSafariContent } = await import('./safariManager.js');
            const { parseTextEmoji } = await import('./utils/emojiUtils.js');
            const safariData = await loadSafariContent();
            const allItems = safariData[context.guildId]?.items || {};
            
            // Create options for ALL items (Discord's built-in search will handle filtering)
            const itemOptions = Object.entries(allItems).map(([itemId, item]) => {
              // Simple, safe label creation
              const label = item.name || 'Unnamed Item';
              const emoji = item.emoji || 'üì¶';
              
              return {
                label: label.substring(0, 100),
                value: itemId,
                description: item.description?.substring(0, 100) || 'No description',
                emoji: { name: 'üì¶' } // Use consistent fallback emoji to avoid parsing issues
              };
            });
            
            // Sort alphabetically
            itemOptions.sort((a, b) => a.label.localeCompare(b.label));
            
            // Limit to Discord's 25 option limit
            const limitedOptions = itemOptions.slice(0, 25);
            
            console.log(`‚úÖ SUCCESS: safari_give_item_select - showing ${limitedOptions.length} items (Discord search enabled)`);
            
            // Show search modal (following map item search pattern)
            const { ModalBuilder, TextInputBuilder, ActionRowBuilder } = await import('discord.js');
            
            const modal = new ModalBuilder()
              .setCustomId(`safari_item_search_modal_${buttonId}`)
              .setTitle('Search Items');
              
            const searchInput = new TextInputBuilder()
              .setCustomId('search_term')
              .setLabel('Search for items...')
              .setStyle(1) // Short
              .setPlaceholder('Enter item name')
              .setRequired(true);
              
            modal.addComponents(new ActionRowBuilder().addComponents(searchInput));
            
            console.log(`‚úÖ SUCCESS: safari_give_item_select - showing search modal`);
            return {
              type: InteractionResponseType.MODAL,
              data: modal.toJSON()
            };
          }
          
          // Handle no results - gracefully ignore with no response
          if (itemId === 'no_results') {
            console.log(`‚ÑπÔ∏è INFO: safari_give_item_select - user selected no_results, ignoring gracefully`);
            // Return empty response to prevent "This interaction failed"
            return {
              type: InteractionResponseType.UPDATE_MESSAGE,
              data: {
                components: [] // Keep the existing message but remove components to indicate nothing happened
              }
            };
          }
          
          console.log(`üéÅ START: safari_give_item_select - button ${buttonId}, item ${itemId}`);
          
          // Load safari data to get item details
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const item = safariData[context.guildId]?.items?.[itemId];
          
          if (!item) {
            return {
              content: '‚ùå Item not found.',
              ephemeral: true
            };
          }
          
          // Show configuration UI for the item drop
          const tempActionIndex = safariData[context.guildId]?.buttons?.[buttonId]?.actions?.length || 0;
          
          console.log(`‚úÖ SUCCESS: safari_give_item_select - showing config for ${item.name}`);
          
          return await showGiveItemConfig(context.guildId, buttonId, itemId, item, tempActionIndex);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_follow_up_select_')) {
      // Handle follow-up button selection for follow_up_button action
      return ButtonHandlerFactory.create({
        id: 'safari_follow_up_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdWithoutPrefix = context.customId.replace('safari_follow_up_select_', '');
          let buttonId, actionIndex;
          
          // Load safari data to check if this is edit mode by checking button existence
          const { loadSafariContent, saveSafariContent, getCustomButton } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const buttons = safariData[context.guildId]?.buttons || {};
          
          // Check if this is edit mode: safari_follow_up_select_${actionId}_${actionIndex}
          // vs new mode: safari_follow_up_select_${buttonId}
          const parts = customIdWithoutPrefix.split('_');
          const lastPart = parts[parts.length - 1];
          
          // If last part is a number AND the remaining parts form a valid button ID, it's edit mode
          if (!isNaN(parseInt(lastPart))) {
            const possibleButtonId = parts.slice(0, -1).join('_');
            if (buttons[possibleButtonId]) {
              // Edit case: safari_follow_up_select_${actionId}_${actionIndex}
              actionIndex = parseInt(lastPart);
              buttonId = possibleButtonId;
              console.log(`üîó EDIT MODE: safari_follow_up_select - editing action ${actionIndex} for button ${buttonId}`);
            } else {
              // New case where button ID happens to end with a number
              buttonId = customIdWithoutPrefix;
              console.log(`üîó NEW MODE: safari_follow_up_select - adding new action for button ${buttonId} (ends with number)`);
            }
          } else {
            // New case: safari_follow_up_select_${buttonId}
            buttonId = customIdWithoutPrefix;
            console.log(`üîó NEW MODE: safari_follow_up_select - adding new action for button ${buttonId}`);
          }
          
          const followUpButtonId = context.values?.[0];
          
          if (!followUpButtonId) {
            return {
              content: '‚ùå No follow-up action selected.',
              ephemeral: true
            };
          }
          
          // Handle back to all selection
          if (followUpButtonId === 'back_to_all_follow_up') {
            // Reload the follow-up selection UI
            const { loadSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const button = safariData[context.guildId]?.buttons?.[buttonId];
            
            if (!button) {
              return {
                content: '‚ùå Button not found.',
                ephemeral: true
              };
            }
            
            // Get all available buttons (excluding current)
            const allButtons = safariData[context.guildId]?.buttons || {};
            const availableButtons = Object.entries(allButtons)
              .filter(([id]) => id !== buttonId)
              .sort((a, b) => {
                const aLastModified = a[1].metadata?.lastModified || 0;
                const bLastModified = b[1].metadata?.lastModified || 0;
                return bLastModified - aLastModified;
              })
              .slice(0, 25);
            
            // Recreate the button options
            const buttonOptions = [];
            
            if (availableButtons.length > 10) {
              buttonOptions.push({
                label: 'üîç Search Actions',
                value: 'search_follow_up_actions',
                description: 'Search through available actions',
                emoji: { name: 'üîç' }
              });
            }
            
            const buttonLimit = availableButtons.length > 10 ? 24 : 25;
            availableButtons.slice(0, buttonLimit).forEach(([id, btn]) => {
              buttonOptions.push({
                label: (btn.name || btn.label || id).substring(0, 100),
                value: id,
                description: (`ID: ${id}` + (btn.actions?.length ? ` ‚Ä¢ ${btn.actions.length} actions` : '')).substring(0, 100),
                emoji: { name: 'üîó' }
              });
            });
            
            return {
              components: [{
                type: 17, // Container
                accent_color: 0x8B5CF6,
                components: [
                  {
                    type: 10, // Text Display
                    content: `# Select Follow-up Action for ${button.name || 'Custom Action'}\n\nChoose which action should be triggered after this action completes.`
                  },
                  { type: 14 }, // Separator
                  {
                    type: 1, // Action Row
                    components: [{
                      type: 3, // String Select
                      custom_id: actionIndex !== undefined ? 
                        `safari_follow_up_select_${buttonId}_${actionIndex}` : 
                        `safari_follow_up_select_${buttonId}`,
                      placeholder: 'Select action to chain to...',
                      options: buttonOptions
                    }]
                  }
                ]
              }],
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
              ephemeral: true
            };
          }
          
          // Handle search selection
          if (followUpButtonId === 'search_follow_up_actions') {
            // Use existing custom_action_search_modal pattern with follow-up context
            const modalCustomId = actionIndex !== undefined ? 
              `custom_action_search_modal_followup_${buttonId}_${actionIndex}` : 
              `custom_action_search_modal_followup_${buttonId}`;
            
            return {
              type: InteractionResponseType.MODAL,
              data: {
                title: 'Search Follow-up Actions',
                custom_id: modalCustomId,
                components: [{
                  type: 1, // ActionRow
                  components: [{
                    type: 4, // Text Input
                    custom_id: 'search_term',
                    label: 'Search Term',
                    style: 1, // Short
                    placeholder: 'Enter action name or description...',
                    required: true,
                    max_length: 50
                  }]
                }]
              }
            };
          }
          
          console.log(`üîó START: safari_follow_up_select - button ${buttonId}, follow-up ${followUpButtonId}, actionIndex: ${actionIndex}`);
          
          // Validate target button exists (reuse already loaded data)
          const targetButton = await getCustomButton(context.guildId, followUpButtonId);
          
          if (!targetButton) {
            return {
              content: '‚ùå Target follow-up action not found.',
              ephemeral: true
            };
          }
          
          // Get current button to determine action index for new actions
          const currentButton = safariData[context.guildId]?.buttons?.[buttonId];
          if (!currentButton) {
            return {
              content: '‚ùå Current button not found.',
              ephemeral: true
            };
          }
          
          // For new actions, determine the action index
          if (actionIndex === undefined) {
            actionIndex = currentButton.actions?.length || 0;
          }
          
          console.log(`‚úÖ SUCCESS: safari_follow_up_select - showing config for follow-up ${followUpButtonId} on ${buttonId}[${actionIndex}]`);
          
          // Show the follow-up configuration UI instead of immediately adding
          return await showFollowUpConfig(context.guildId, buttonId, followUpButtonId, actionIndex);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_followup_execute_on_')) {
      // Handle executeOn change for follow_up_button
      return ButtonHandlerFactory.create({
        id: 'safari_followup_execute_on',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          // Get the selected value from the dropdown
          const executeOnValue = context.values[0]; // 'true' or 'false' from dropdown selection
          
          // Parse the custom_id: safari_followup_execute_on_buttonId_targetButtonId_actionIndex
          // More robust parsing to handle button IDs with underscores
          const fullString = context.customId.replace('safari_followup_execute_on_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const remainingString = fullString.substring(0, lastUnderscoreIndex);
          
          // Find targetButtonId by checking which part exists in buttons
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const buttons = safariData[context.guildId]?.buttons || {};
          
          let buttonId, targetButtonId;
          
          // Try different split points to find valid targetButtonId
          const parts = remainingString.split('_');
          for (let i = 1; i < parts.length; i++) {
            const possibleButtonId = parts.slice(0, i).join('_');
            const possibleTargetButtonId = parts.slice(i).join('_');
            if (buttons[possibleTargetButtonId]) {
              buttonId = possibleButtonId;
              targetButtonId = possibleTargetButtonId;
              break;
            }
          }
          
          if (!targetButtonId) {
            console.error(`‚ùå Could not parse target button ID from custom_id: ${context.customId}`);
            return {
              content: '‚ùå Error parsing follow-up configuration.',
              ephemeral: true
            };
          }
          
          console.log(`üéØ EXECUTE ON: safari_followup_execute_on - setting to ${executeOnValue} for ${buttonId}[${actionIndex}] follow-up ${targetButtonId}`);
          
          // Update state
          const stateKey = `${context.guildId}_${buttonId}_followup_${actionIndex}`;
          const state = dropConfigState.get(stateKey) || { targetButtonId: targetButtonId, executeOn: 'true' };
          state.executeOn = executeOnValue;
          dropConfigState.set(stateKey, state);
          
          // Return updated configuration UI
          return await showFollowUpConfig(context.guildId, buttonId, targetButtonId, actionIndex);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_followup_save_')) {
      // Handle save for follow_up_button
      return ButtonHandlerFactory.create({
        id: 'safari_followup_save',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true, // Dismiss config panel and show Custom Action Editor
        handler: async (context) => {
          // Parse the custom_id: safari_followup_save_buttonId_targetButtonId_actionIndex
          // More robust parsing to handle button IDs with underscores
          const fullString = context.customId.replace('safari_followup_save_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const remainingString = fullString.substring(0, lastUnderscoreIndex);
          
          // Find targetButtonId by checking which part exists in buttons
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const buttons = safariData[context.guildId]?.buttons || {};
          
          let buttonId, targetButtonId;
          
          // Try different split points to find valid targetButtonId
          const parts = remainingString.split('_');
          for (let i = 1; i < parts.length; i++) {
            const possibleButtonId = parts.slice(0, i).join('_');
            const possibleTargetButtonId = parts.slice(i).join('_');
            if (buttons[possibleTargetButtonId]) {
              buttonId = possibleButtonId;
              targetButtonId = possibleTargetButtonId;
              break;
            }
          }
          
          if (!targetButtonId) {
            console.error(`‚ùå Could not parse target button ID from custom_id: ${context.customId}`);
            return {
              content: '‚ùå Error parsing follow-up configuration.',
              ephemeral: true
            };
          }
          
          console.log(`‚úÖ SAVE: safari_followup_save - saving follow-up ${targetButtonId} for ${buttonId}[${actionIndex}]`);
          
          // Get state
          const stateKey = `${context.guildId}_${buttonId}_followup_${actionIndex}`;
          const state = dropConfigState.get(stateKey) || { targetButtonId: targetButtonId, executeOn: 'true' };
          
          // Get button (safariData already loaded above)
          const button = safariData[context.guildId]?.buttons?.[buttonId];
          
          if (!button) {
            return {
              content: '‚ùå Button not found.',
              ephemeral: true
            };
          }
          
          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }
          
          // Create the follow-up action
          const action = {
            type: 'follow_up_button',
            order: actionIndex,
            config: {
              buttonId: state.targetButtonId
            },
            executeOn: state.executeOn || 'true'  // Default to 'true' for backwards compatibility
          };
          
          // Add or update the action
          if (actionIndex < button.actions.length) {
            // Edit mode: Replace existing action
            console.log(`‚úèÔ∏è Updating existing action at index ${actionIndex}`);
            button.actions[actionIndex] = action;
          } else {
            // Create mode: Add new action
            console.log(`‚ûï Adding new action at index ${actionIndex}`);
            button.actions.push(action);
          }
          
          // Update metadata
          if (!button.metadata) {
            button.metadata = {
              createdAt: Date.now(),
              lastModified: Date.now(),
              usageCount: 0
            };
          } else {
            button.metadata.lastModified = Date.now();
          }
          
          // Save safari data
          await saveSafariContent(safariData);
          
          // Update anchor messages for all coordinates using this action
          try {
            const { queueActionCoordinateUpdates } = await import('./anchorMessageManager.js');
            await queueActionCoordinateUpdates(context.guildId, buttonId, 'followup_action_saved');
          } catch (error) {
            console.error('Error queueing anchor updates:', error);
          }
          
          console.log(`‚úÖ Added follow_up_button action to button ${buttonId}`);
          
          // Clean up state
          dropConfigState.delete(stateKey);
          
          // Return to custom action editor
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          return await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId: buttonId
          });
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_give_role_select_')) {
      // Handle role selection for give_role action
      return ButtonHandlerFactory.create({
        id: 'safari_give_role_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_give_role_select - user ${context.userId}`);
          
          const buttonId = context.customId.replace('safari_give_role_select_', '');
          const roleId = context.values?.[0];
          
          if (!roleId) {
            return {
              content: '‚ùå No role selected.',
              ephemeral: true
            };
          }
          
          console.log(`üëë Selected role ${roleId} for give_role action on button ${buttonId}`);
          
          // Load safari data
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];
          
          if (!button) {
            return {
              content: '‚ùå Button not found.',
              ephemeral: true
            };
          }
          
          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }
          
          // Create the give_role action
          const actionIndex = button.actions.length;
          const action = {
            type: 'give_role',
            order: actionIndex,
            config: {
              roleId: roleId
            },
            executeOn: 'true' // Default to execute on conditions met
          };
          
          // Add the action
          button.actions.push(action);
          
          // Update metadata
          if (!button.metadata) {
            button.metadata = {
              createdAt: Date.now(),
              lastModified: Date.now(),
              usageCount: 0
            };
          } else {
            button.metadata.lastModified = Date.now();
          }
          
          // Save safari data
          await saveSafariContent(safariData);
          
          console.log(`‚úÖ SUCCESS: safari_give_role_select - added give_role action to button ${buttonId}`);
          
          // Return to custom action editor
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          return await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId: buttonId
          });
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_remove_role_select_')) {
      // Handle role selection for remove_role action
      return ButtonHandlerFactory.create({
        id: 'safari_remove_role_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_remove_role_select - user ${context.userId}`);
          
          const buttonId = context.customId.replace('safari_remove_role_select_', '');
          const roleId = context.values?.[0];
          
          if (!roleId) {
            return {
              content: '‚ùå No role selected.',
              ephemeral: true
            };
          }
          
          console.log(`üö´ Selected role ${roleId} for remove_role action on button ${buttonId}`);
          
          // Load safari data
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];
          
          if (!button) {
            return {
              content: '‚ùå Button not found.',
              ephemeral: true
            };
          }
          
          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }
          
          // Create the remove_role action
          const actionIndex = button.actions.length;
          const action = {
            type: 'remove_role',
            order: actionIndex,
            config: {
              roleId: roleId
            },
            executeOn: 'true' // Default to execute on conditions met
          };
          
          // Add the action
          button.actions.push(action);
          
          // Update metadata
          if (!button.metadata) {
            button.metadata = {
              createdAt: Date.now(),
              lastModified: Date.now(),
              usageCount: 0
            };
          } else {
            button.metadata.lastModified = Date.now();
          }
          
          // Save safari data
          await saveSafariContent(safariData);
          
          console.log(`‚úÖ SUCCESS: safari_remove_role_select - added remove_role action to button ${buttonId}`);
          
          // Return to custom action editor
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          return await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId: buttonId
          });
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_item_limit_')) {
      // Handle item drop usage limit change
      return ButtonHandlerFactory.create({
        id: 'safari_item_limit',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          // Parse the custom_id: safari_item_limit_buttonId_itemId_actionIndex
          const fullString = context.customId.replace('safari_item_limit_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const beforeActionIndex = fullString.substring(0, lastUnderscoreIndex);
          
          // Find itemId by checking which part exists in items
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const items = safariData[context.guildId]?.items || {};
          
          let buttonId, itemId, item;
          
          // Try different split points to find valid itemId
          const parts = beforeActionIndex.split('_');
          for (let i = 1; i < parts.length; i++) {
            const possibleItemId = parts.slice(i).join('_');
            if (items[possibleItemId]) {
              itemId = possibleItemId;
              buttonId = parts.slice(0, i).join('_');
              item = items[possibleItemId];
              break;
            }
          }
          
          if (!item) {
            return {
              content: '‚ùå Item not found.',
              ephemeral: true
            };
          }
          
          const limitType = context.values[0];
          console.log(`üéØ LIMIT: safari_item_limit - ${limitType} for ${buttonId}[${actionIndex}]`);
          
          // Store in temporary state (preserve existing defaults if present)
          const stateKey = `${context.guildId}_${buttonId}_${itemId}_${actionIndex}`;
          const state = dropConfigState.get(stateKey) || {
            limit: 'once_per_player',
            style: '2',
            quantity: 1,
            executeOn: 'true'
          };
          state.limit = limitType;
          dropConfigState.set(stateKey, state);
          
          // Return updated configuration UI
          return await showGiveItemConfig(context.guildId, buttonId, itemId, item, actionIndex);
        }
      })(req, res, client);
    // NOTE: safari_item_style_* handler removed - button style is set at parent Custom Action level
    // via custom_action_button_style_* handler. Sub-actions don't have their own buttons.
    } else if (custom_id.startsWith('safari_item_operation_')) {
      // Handle item operation type change (give vs remove)
      return ButtonHandlerFactory.create({
        id: 'safari_item_operation',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          // Parse the custom_id: safari_item_operation_buttonId_itemId_actionIndex
          const fullString = context.customId.replace('safari_item_operation_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const beforeActionIndex = fullString.substring(0, lastUnderscoreIndex);

          // Find itemId by checking which part exists in items
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const items = safariData[context.guildId]?.items || {};

          let buttonId, itemId, item;

          // Try different split points to find valid itemId
          const parts = beforeActionIndex.split('_');
          for (let i = 1; i < parts.length; i++) {
            const possibleItemId = parts.slice(i).join('_');
            if (items[possibleItemId]) {
              itemId = possibleItemId;
              buttonId = parts.slice(0, i).join('_');
              item = items[possibleItemId];
              break;
            }
          }

          if (!item) {
            return {
              content: '‚ùå Item not found.',
              ephemeral: true
            };
          }

          const operationType = context.values[0]; // 'give' or 'remove'
          console.log(`üéØ OPERATION: safari_item_operation - ${operationType} for ${buttonId}[${actionIndex}]`);

          // Store in temporary state (preserve existing defaults if present)
          const stateKey = `${context.guildId}_${buttonId}_${itemId}_${actionIndex}`;
          const state = dropConfigState.get(stateKey) || {
            limit: 'once_per_player',
            style: '2',
            quantity: 1,
            operation: 'give',
            executeOn: 'true'
          };
          state.operation = operationType;
          dropConfigState.set(stateKey, state);

          // Return updated configuration UI
          return await showGiveItemConfig(context.guildId, buttonId, itemId, item, actionIndex);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_item_quantity_')) {
      // Handle item quantity change
      return ButtonHandlerFactory.create({
        id: 'safari_item_quantity',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          // Parse the custom_id: safari_item_quantity_buttonId_itemId_actionIndex
          const fullString = context.customId.replace('safari_item_quantity_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const beforeActionIndex = fullString.substring(0, lastUnderscoreIndex);
          
          // Find itemId by checking which part exists in items
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const items = safariData[context.guildId]?.items || {};
          
          let buttonId, itemId, item;
          
          // Try different split points to find valid itemId
          const parts = beforeActionIndex.split('_');
          for (let i = 1; i < parts.length; i++) {
            const possibleItemId = parts.slice(i).join('_');
            if (items[possibleItemId]) {
              itemId = possibleItemId;
              buttonId = parts.slice(0, i).join('_');
              item = items[possibleItemId];
              break;
            }
          }
          
          if (!item) {
            return {
              content: '‚ùå Item not found.',
              ephemeral: true
            };
          }
          
          const quantity = parseInt(context.values[0]);
          console.log(`üì¶ QUANTITY: safari_item_quantity - ${quantity} for ${buttonId}[${actionIndex}]`);
          
          // Store in temporary state (preserve existing defaults if present)
          const stateKey = `${context.guildId}_${buttonId}_${itemId}_${actionIndex}`;
          const state = dropConfigState.get(stateKey) || {
            limit: 'once_per_player',
            style: '2',
            quantity: 1,
            executeOn: 'true'
          };
          state.quantity = quantity;
          dropConfigState.set(stateKey, state);
          
          // Return updated configuration UI
          return await showGiveItemConfig(context.guildId, buttonId, itemId, item, actionIndex);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_item_reset_')) {
      // Handle reset claims for give_item
      return ButtonHandlerFactory.create({
        id: 'safari_item_reset',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          // Parse the custom_id: safari_item_reset_buttonId_itemId_actionIndex
          const fullString = context.customId.replace('safari_item_reset_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const beforeActionIndex = fullString.substring(0, lastUnderscoreIndex);
          
          // Find itemId by checking which part exists in items
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const items = safariData[context.guildId]?.items || {};
          
          let buttonId, itemId, item;
          
          // Try different split points to find valid itemId
          const parts = beforeActionIndex.split('_');
          for (let i = 1; i < parts.length; i++) {
            const possibleItemId = parts.slice(i).join('_');
            if (items[possibleItemId]) {
              itemId = possibleItemId;
              buttonId = parts.slice(0, i).join('_');
              item = items[possibleItemId];
              break;
            }
          }
          
          if (!item) {
            return {
              content: '‚ùå Item not found.',
              ephemeral: true
            };
          }
          
          console.log(`üîÑ RESET: safari_item_reset - resetting claims for ${buttonId}[${actionIndex}]`);
          
          // Find and reset the specific action's claims
          const button = safariData[context.guildId]?.buttons?.[buttonId];
          if (button && button.actions && button.actions[actionIndex]) {
            const action = button.actions[actionIndex];
            if (action.type === 'give_item' && action.config?.limit) {
              console.log(`üîÑ BEFORE RESET: ${action.config.limit.type}, claimedBy:`, action.config.limit.claimedBy);
              
              // Clear claims based on limit type
              if (action.config.limit.type === 'once_per_player') {
                action.config.limit.claimedBy = [];
              } else if (action.config.limit.type === 'once_globally') {
                // For once_globally, remove claimedBy property entirely - no arrays!
                delete action.config.limit.claimedBy;
              }
              
              console.log(`üîÑ AFTER RESET: ${action.config.limit.type}, claimedBy:`, action.config.limit.claimedBy);
              
              await saveSafariContent(safariData);
              console.log(`‚úÖ Claims reset for give_item action ${buttonId}[${actionIndex}]`);
            } else {
              console.log(`‚ùå Could not find give_item action to reset: ${buttonId}[${actionIndex}]`);
            }
          } else {
            console.log(`‚ùå Could not find button to reset: ${buttonId}`);
          }
          
          // Return updated configuration UI
          return await showGiveItemConfig(context.guildId, buttonId, itemId, item, actionIndex);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_item_save_')) {
      // Handle save and finish for give_item
      return ButtonHandlerFactory.create({
        id: 'safari_item_save',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          // Parse the custom_id: safari_item_save_buttonId_itemId_actionIndex
          const fullString = context.customId.replace('safari_item_save_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const beforeActionIndex = fullString.substring(0, lastUnderscoreIndex);
          
          // Find itemId by checking which part exists in items
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const items = safariData[context.guildId]?.items || {};
          
          let buttonId, itemId, item;
          
          // Try different split points to find valid itemId
          const parts = beforeActionIndex.split('_');
          for (let i = 1; i < parts.length; i++) {
            const possibleItemId = parts.slice(i).join('_');
            if (items[possibleItemId]) {
              itemId = possibleItemId;
              buttonId = parts.slice(0, i).join('_');
              item = items[possibleItemId];
              break;
            }
          }
          
          // Log will be updated after we get state
          // console.log(`‚úÖ SAVE: safari_item_save - saving give_item for ${buttonId}`);
          
          const button = safariData[context.guildId]?.buttons?.[buttonId];
          
          if (!button || !item) {
            return {
              content: '‚ùå Button or item not found.',
              ephemeral: true
            };
          }
          
          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }
          
          // Get state from temporary storage (use defaults if not found)
          const stateKey = `${context.guildId}_${buttonId}_${itemId}_${actionIndex}`;
          const state = dropConfigState.get(stateKey) || {
            limit: 'once_per_player',
            style: '2',
            quantity: 1,
            operation: 'give',
            executeOn: 'true'
          };
          
          // Handle quantity 0 - don't add the action
          if (state.quantity === 0) {
            console.log(`üóëÔ∏è Not adding give_item action due to quantity 0`);
            
            // Clean up state
            dropConfigState.delete(stateKey);
            
            // Return to custom action editor
            const { createCustomActionEditorUI } = await import('./customActionUI.js');
            return await createCustomActionEditorUI({
              guildId: context.guildId,
              actionId: buttonId
            });
          }
          
          // Create the give_item action with state values (with defaults)
          const action = {
            type: 'give_item',
            order: actionIndex,
            config: {
              itemId: itemId,
              quantity: state.quantity || 1,  // Default to 1 if not set
              operation: state.operation || 'give',  // Default to 'give' for backwards compatibility
              limit: {
                type: state.limit || 'unlimited',  // Default to unlimited
                claimedBy: (state.limit || 'unlimited') === 'unlimited' ? undefined : []
              }
            },
            executeOn: state.executeOn || 'true'  // Default to 'true' for backwards compatibility
          };

          // NOTE: Button style is set at parent Custom Action level, not per sub-action

          // Add or update the action
          if (actionIndex < button.actions.length) {
            // Edit mode: Replace existing action
            console.log(`‚úèÔ∏è Updating existing action at index ${actionIndex}`);
            button.actions[actionIndex] = action;
          } else {
            // Create mode: Add new action
            console.log(`‚ûï Adding new action at index ${actionIndex}`);
            button.actions.push(action);
          }
          
          // Update metadata
          if (!button.metadata) {
            button.metadata = {
              createdAt: Date.now(),
              lastModified: Date.now(),
              usageCount: 0
            };
          } else {
            button.metadata.lastModified = Date.now();
          }
          
          // Save safari data
          await saveSafariContent(safariData);
          
          // Update anchor messages for all coordinates using this action
          try {
            const { queueActionCoordinateUpdates } = await import('./anchorMessageManager.js');
            await queueActionCoordinateUpdates(context.guildId, buttonId, 'item_action_saved');
          } catch (error) {
            console.error('Error queueing anchor updates:', error);
          }
          
          console.log(`‚úÖ Added give_item action (operation: ${state.operation || 'give'}) to button ${buttonId}`);
          
          // Clean up state
          dropConfigState.delete(stateKey);
          
          // Return to custom action editor (make it ephemeral)
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          const editorUI = await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId: buttonId
          });
          
          // Ensure the response is ephemeral
          return {
            ...editorUI,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_currency_amount_')) {
      // Handle currency amount button (shows modal)
      return ButtonHandlerFactory.create({
        id: 'safari_currency_amount',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          // More robust parsing to handle button IDs with underscores
          const fullString = context.customId.replace('safari_currency_amount_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const buttonId = fullString.substring(0, lastUnderscoreIndex);
          
          console.log(`üí∞ AMOUNT: safari_currency_amount - showing modal for ${buttonId}[${actionIndex}]`);
          
          // Show modal for amount input
          const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = await import('discord.js');
          const modal = new ModalBuilder()
            .setCustomId(`safari_currency_modal_${buttonId}_${actionIndex}`)
            .setTitle('Set Currency Amount');
          
          const amountInput = new TextInputBuilder()
            .setCustomId('amount')
            .setLabel('Amount to give (negative values subtract)')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('100 or -55 to subtract')
            .setRequired(true)
            .setMinLength(1)
            .setMaxLength(10);
          
          modal.addComponents(new ActionRowBuilder().addComponents(amountInput));
          
          return res.send({
            type: InteractionResponseType.MODAL,
            data: modal
          });
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_currency_limit_')) {
      // Handle currency usage limit change
      return ButtonHandlerFactory.create({
        id: 'safari_currency_limit',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          // More robust parsing to handle button IDs with underscores
          const fullString = context.customId.replace('safari_currency_limit_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const buttonId = fullString.substring(0, lastUnderscoreIndex);
          const limitType = context.values[0];
          
          console.log(`üéØ LIMIT: safari_currency_limit - ${limitType} for ${buttonId}[${actionIndex}]`);
          
          // Store in temporary state
          const stateKey = `${context.guildId}_${buttonId}_currency_${actionIndex}`;
          const state = dropConfigState.get(stateKey) || { limit: null, style: null, amount: null, executeOn: 'true' };
          state.limit = limitType;
          dropConfigState.set(stateKey, state);
          
          // Update temporary state
          const { getCustomTerms } = await import('./safariManager.js');
          const customTerms = await getCustomTerms(context.guildId);
          
          // Return updated configuration UI
          return await showGiveCurrencyConfig(context.guildId, buttonId, actionIndex, customTerms);
        }
      })(req, res, client);
    // NOTE: safari_currency_style_* handler removed - button style is set at parent Custom Action level
    // via custom_action_button_style_* handler. Sub-actions don't have their own buttons.
    } else if (custom_id.startsWith('safari_currency_reset_') && custom_id !== 'safari_currency_reset_confirm') {
      // Handle reset claims for give_currency (not the confirm button for resetting all currency)
      return ButtonHandlerFactory.create({
        id: 'safari_currency_reset',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          // More robust parsing to handle button IDs with underscores
          const fullString = context.customId.replace('safari_currency_reset_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const buttonId = fullString.substring(0, lastUnderscoreIndex);
          
          console.log(`üîÑ RESET: safari_currency_reset - resetting claims for ${buttonId}[${actionIndex}]`);
          
          // Load safari data and reset claims
          const { loadSafariContent, saveSafariContent, getCustomTerms } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];
          
          if (button && button.actions && button.actions[actionIndex]) {
            const action = button.actions[actionIndex];
            if (action.type === 'give_currency' && action.config?.limit) {
              // Clear claims
              if (action.config.limit.type === 'once_per_player') {
                action.config.limit.claimedBy = [];
              } else if (action.config.limit.type === 'once_globally') {
                action.config.limit.claimedBy = null;
              }
              
              await saveSafariContent(safariData);
              console.log(`‚úÖ Claims reset for give_currency action ${actionIndex}`);
            }
          }
          
          // Return updated configuration UI
          const customTerms = await getCustomTerms(context.guildId);
          return await showGiveCurrencyConfig(context.guildId, buttonId, actionIndex, customTerms);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_currency_save_')) {
      // Handle save and finish for give_currency
      return ButtonHandlerFactory.create({
        id: 'safari_currency_save',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        ephemeral: true,
        handler: async (context) => {
          // More robust parsing to handle button IDs with underscores
          const fullString = context.customId.replace('safari_currency_save_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const buttonId = fullString.substring(0, lastUnderscoreIndex);
          
          console.log(`‚úÖ SAVE: safari_currency_save - saving give_currency for ${buttonId}`);
          
          // Load safari data
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];
          
          if (!button) {
            return {
              content: '‚ùå Button not found.',
              ephemeral: true
            };
          }
          
          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }
          
          // Get state from temporary storage
          const stateKey = `${context.guildId}_${buttonId}_currency_${actionIndex}`;
          const state = dropConfigState.get(stateKey) || { limit: null, style: null, amount: null, executeOn: 'true' };
          
          // Handle amount 0 - don't add the action
          if (state.amount === 0) {
            console.log(`üóëÔ∏è Not adding give_currency action due to amount 0`);
            
            // Clean up state
            dropConfigState.delete(stateKey);
            
            // Return to custom action editor
            const { createCustomActionEditorUI } = await import('./customActionUI.js');
            return await createCustomActionEditorUI({
              guildId: context.guildId,
              actionId: buttonId
            });
          }
          
          // Create the give_currency action with state values (with defaults)
          const action = {
            type: 'give_currency',
            order: actionIndex,
            config: {
              amount: state.amount || 100,  // Default to 100 if not set
              limit: {
                type: state.limit || 'unlimited',  // Default to unlimited
                claimedBy: (state.limit || 'unlimited') === 'unlimited' ? undefined : []
              }
            },
            executeOn: state.executeOn || 'true'  // Default to 'true' for backwards compatibility
          };

          // NOTE: Button style is set at parent Custom Action level, not per sub-action

          // Add or update the action
          if (actionIndex < button.actions.length) {
            // Edit mode: Replace existing action
            console.log(`‚úèÔ∏è Updating existing action at index ${actionIndex}`);
            button.actions[actionIndex] = action;
          } else {
            // Create mode: Add new action
            console.log(`‚ûï Adding new action at index ${actionIndex}`);
            button.actions.push(action);
          }
          
          // Update metadata
          if (!button.metadata) {
            button.metadata = {
              createdAt: Date.now(),
              lastModified: Date.now(),
              usageCount: 0
            };
          } else {
            button.metadata.lastModified = Date.now();
          }
          
          // Save safari data
          await saveSafariContent(safariData);
          
          // Update anchor messages for all coordinates using this action
          try {
            const { queueActionCoordinateUpdates } = await import('./anchorMessageManager.js');
            await queueActionCoordinateUpdates(context.guildId, buttonId, 'currency_action_saved');
          } catch (error) {
            console.error('Error queueing anchor updates:', error);
          }
          
          console.log(`‚úÖ Added give_currency action to button ${buttonId}`);
          
          // Clean up state
          dropConfigState.delete(stateKey);
          
          // Return to custom action editor
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          return await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId: buttonId
          });
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_currency_execute_on_')) {
      // Handle executeOn change for give_currency
      return ButtonHandlerFactory.create({
        id: 'safari_currency_execute_on',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          // Get the selected value from the dropdown
          const executeOnValue = context.values[0]; // 'true' or 'false' from dropdown selection
          
          // Parse custom_id to get button ID and action index
          const fullString = context.customId.replace('safari_currency_execute_on_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const buttonId = fullString.substring(0, lastUnderscoreIndex);
          
          console.log(`üéØ EXECUTE ON: safari_currency_execute_on - setting to ${executeOnValue} for ${buttonId}[${actionIndex}]`);
          
          // Update state
          const stateKey = `${context.guildId}_${buttonId}_currency_${actionIndex}`;
          const state = dropConfigState.get(stateKey) || { limit: null, style: null, amount: null, executeOn: 'true' };
          state.executeOn = executeOnValue;
          dropConfigState.set(stateKey, state);
          
          // Return updated configuration UI
          const { getCustomTerms } = await import('./safariManager.js');
          const customTerms = await getCustomTerms(context.guildId);
          return await showGiveCurrencyConfig(context.guildId, buttonId, actionIndex, customTerms);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_item_execute_on_')) {
      // Handle executeOn change for give_item
      return ButtonHandlerFactory.create({
        id: 'safari_item_execute_on',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          // Get the selected value from the dropdown
          const executeOnValue = context.values[0]; // 'true' or 'false' from dropdown selection
          
          // Parse the custom_id: safari_item_execute_on_buttonId_itemId_actionIndex
          // More robust parsing to handle button IDs and item IDs with underscores
          const fullString = context.customId.replace('safari_item_execute_on_', '');
          const lastUnderscoreIndex = fullString.lastIndexOf('_');
          const actionIndex = parseInt(fullString.substring(lastUnderscoreIndex + 1));
          const remainingString = fullString.substring(0, lastUnderscoreIndex);
          
          // Find itemId by checking which part exists in items
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const items = safariData[context.guildId]?.items || {};
          
          let buttonId, itemId, item;
          
          // Try different split points to find valid itemId
          const parts = remainingString.split('_');
          for (let i = 1; i < parts.length; i++) {
            const possibleButtonId = parts.slice(0, i).join('_');
            const possibleItemId = parts.slice(i).join('_');
            if (items[possibleItemId]) {
              buttonId = possibleButtonId;
              itemId = possibleItemId;
              item = items[possibleItemId];
              break;
            }
          }
          
          if (!itemId || !item) {
            console.error(`‚ùå Could not parse item ID from custom_id: ${context.customId}`);
            return {
              content: '‚ùå Error parsing item configuration.',
              ephemeral: true
            };
          }
          
          console.log(`üéØ EXECUTE ON: safari_item_execute_on - setting to ${executeOnValue} for ${buttonId}[${actionIndex}] with item ${itemId}`);
          
          // Update state
          const stateKey = `${context.guildId}_${buttonId}_${itemId}_${actionIndex}`;
          const state = dropConfigState.get(stateKey) || { limit: null, style: null, quantity: null, executeOn: 'true' };
          state.executeOn = executeOnValue;
          dropConfigState.set(stateKey, state);
          
          // Return updated configuration UI
          return await showGiveItemConfig(context.guildId, buttonId, itemId, item, actionIndex);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_add_action_')) {
      // Handle adding actions to safari buttons (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_add_action',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_add_action - user ${context.userId}`);
          
          // Match against known action types that may contain underscores
          let actionType, buttonId;
          const customIdWithoutPrefix = context.customId.replace('safari_add_action_', '');
          
          if (context.customId.endsWith('_display_text')) {
            actionType = 'display_text';
            buttonId = customIdWithoutPrefix.substring(0, customIdWithoutPrefix.lastIndexOf('_display_text'));
          } else if (context.customId.endsWith('_update_currency')) {
            actionType = 'update_currency';
            buttonId = customIdWithoutPrefix.substring(0, customIdWithoutPrefix.lastIndexOf('_update_currency'));
          } else if (context.customId.endsWith('_follow_up')) {
            actionType = 'follow_up_button';
            buttonId = customIdWithoutPrefix.substring(0, customIdWithoutPrefix.lastIndexOf('_follow_up'));
          } else if (context.customId.endsWith('_conditional')) {
            actionType = 'conditional';
            buttonId = customIdWithoutPrefix.substring(0, customIdWithoutPrefix.lastIndexOf('_conditional'));
          } else {
            // Fallback to old method for any unknown action types
            const parts = context.customId.split('_');
            actionType = parts[parts.length - 1];
            buttonId = parts.slice(3, parts.length - 1).join('_');
          }
          
          // If actionType is numeric, it's likely the button ID suffix
          const fullButtonId = /^\d+$/.test(actionType) ? `${buttonId}_${actionType}` : buttonId;
          console.log(`üîß DEBUG: Adding ${actionType} action to button ${fullButtonId}`);
          
          // Show appropriate modal based on action type
          if (actionType === 'display_text') {
            const modal = new ModalBuilder()
              .setCustomId(`safari_action_modal_${fullButtonId}_display_text`)
              .setTitle('Add Text Display Action');

            const titleInput = new TextInputBuilder()
              .setCustomId('action_title')
              .setLabel('Title (optional)')
              .setPlaceholder('e.g., "Welcome to the Adventure!"')
              .setStyle(TextInputStyle.Short)
              .setRequired(false)
              .setMaxLength(100);

            const contentInput = new TextInputBuilder()
              .setCustomId('action_content')
              .setLabel('Content')
              .setPlaceholder('The text to display when the button is clicked...')
              .setStyle(TextInputStyle.Paragraph)
              .setRequired(true)
              .setMaxLength(2000);

            const colorInput = new TextInputBuilder()
              .setCustomId('action_color')
              .setLabel('Accent Color (optional)')
              .setPlaceholder('e.g., #3498db or 3447003')
              .setStyle(TextInputStyle.Short)
              .setRequired(false)
              .setMaxLength(10);

            const imageInput = new TextInputBuilder()
              .setCustomId('action_image')
              .setLabel('Image URL (Optional)')
              .setPlaceholder('Enter link of an image you have uploaded to Discord.')
              .setStyle(TextInputStyle.Short)
              .setRequired(false)
              .setMaxLength(500);

            const executeOnInput = new TextInputBuilder()
              .setCustomId('action_execute_on')
              .setLabel('Execute when conditions are (true/false)')
              .setPlaceholder('Type true to execute if all conditions are met, type false to execute if conditions are not met')
              .setStyle(TextInputStyle.Short)
              .setRequired(false)
              .setMaxLength(10)
              .setValue('true'); // Pre-populate with 'true'

            modal.addComponents(
              new ActionRowBuilder().addComponents(titleInput),
              new ActionRowBuilder().addComponents(contentInput),
              new ActionRowBuilder().addComponents(executeOnInput),
              new ActionRowBuilder().addComponents(colorInput),
              new ActionRowBuilder().addComponents(imageInput)
            );
            
            console.log(`‚úÖ SUCCESS: safari_add_action - showing display_text modal`);
            return {
              type: InteractionResponseType.MODAL,
              data: modal.toJSON()
            };
            
          } else if (actionType === 'update_currency') {
            const modal = new ModalBuilder()
              .setCustomId(`safari_action_modal_${fullButtonId}_update_currency`)
              .setTitle('Add Currency Change Action');

            const amountInput = new TextInputBuilder()
              .setCustomId('action_amount')
              .setLabel('Currency Amount')
              .setPlaceholder('e.g., 100 or -50 (positive adds, negative subtracts)')
              .setStyle(TextInputStyle.Short)
              .setRequired(true)
              .setMaxLength(10);

            const messageInput = new TextInputBuilder()
              .setCustomId('action_message')
              .setLabel('Message to Player')
              .setPlaceholder('e.g., "You found a treasure chest!"')
              .setStyle(TextInputStyle.Paragraph)
              .setRequired(true)
              .setMaxLength(200);

            modal.addComponents(
              new ActionRowBuilder().addComponents(amountInput),
              new ActionRowBuilder().addComponents(messageInput)
            );
            
            console.log(`‚úÖ SUCCESS: safari_add_action - showing update_currency modal`);
            return {
              type: InteractionResponseType.MODAL,
              data: modal.toJSON()
            };
          
          } else if (actionType === 'conditional') {
            const modal = new ModalBuilder()
              .setCustomId(`safari_action_modal_${fullButtonId}_conditional`)
              .setTitle('Add Conditional Action');

            const conditionTypeInput = new TextInputBuilder()
              .setCustomId('condition_type')
              .setLabel('Condition Type')
              .setPlaceholder('currency_gte, currency_lte, has_item, not_has_item')
              .setStyle(TextInputStyle.Short)
              .setRequired(true)
              .setMaxLength(20);

            const conditionValueInput = new TextInputBuilder()
              .setCustomId('condition_value')
              .setLabel('Condition Value')
              .setPlaceholder('e.g., "100" for currency, "item_id" for items')
              .setStyle(TextInputStyle.Short)
              .setRequired(true)
              .setMaxLength(50);

            const successActionInput = new TextInputBuilder()
              .setCustomId('success_action')
              .setLabel('Success Action Type')
              .setPlaceholder('display_text, update_currency, follow_up_button')
              .setStyle(TextInputStyle.Short)
              .setRequired(true)
              .setMaxLength(20);

            const failureActionInput = new TextInputBuilder()
              .setCustomId('failure_action')
              .setLabel('Failure Action Type (optional)')
              .setPlaceholder('display_text, update_currency, follow_up_button')
              .setStyle(TextInputStyle.Short)
              .setRequired(false)
              .setMaxLength(20);

            modal.addComponents(
              new ActionRowBuilder().addComponents(conditionTypeInput),
              new ActionRowBuilder().addComponents(conditionValueInput),
              new ActionRowBuilder().addComponents(successActionInput),
              new ActionRowBuilder().addComponents(failureActionInput)
            );
            
            console.log(`‚úÖ SUCCESS: safari_add_action - showing conditional modal`);
            return {
              type: InteractionResponseType.MODAL,
              data: modal.toJSON()
            };
          } else {
            // This might be a request to show the action menu for an existing button
            // Check if this is a numeric action ID (likely a mistake - show action menu instead)
            if (/^\d+$/.test(actionType)) {
              // Reconstruct the full button ID including the numeric suffix
              const fullButtonId = `${buttonId}_${actionType}`;
              console.log(`üîß DEBUG: Showing action menu for button "${fullButtonId}" (detected numeric suffix "${actionType}")`);
              
              // Get button info for better labeling
              const { loadSafariContent } = await import('./safariManager.js');
              const safariContent = await loadSafariContent();
              const buttonInfo = safariContent[context.guildId]?.buttons?.[fullButtonId];
              const buttonLabel = buttonInfo?.label || fullButtonId;
              
              // Show the action menu for this button
              const actionMenuComponents = [
                {
                  type: 1, // Action Row
                  components: [
                    {
                      type: 2, // Button
                      custom_id: `safari_add_action_${fullButtonId}_display_text`,
                      label: 'Show Text',
                      style: 2, // Secondary (grey)
                      emoji: { name: 'üìÑ' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `safari_add_action_${fullButtonId}_update_currency`,
                      label: 'Change Currency',
                      style: 2, // Secondary (grey)
                      emoji: { name: 'üí∞' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `safari_add_action_${fullButtonId}_follow_up`,
                      label: 'Show Follow-Up Action',
                      style: 2, // Secondary (grey)
                      emoji: { name: 'üîó' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `safari_add_action_${fullButtonId}_conditional`,
                      label: 'Add Conditional Action',
                      style: 2, // Secondary (grey)
                      emoji: { name: 'üîÄ' }
                    }
                  ]
                }
              ];

              console.log(`‚úÖ SUCCESS: safari_add_action - showing action menu`);
              return {
                flags: (1 << 15), // IS_COMPONENTS_V2
                components: [{
                  type: 17, // Container
                  components: [
                    {
                      type: 10, // Text Display
                      content: `## üéØ Add Actions to ${buttonLabel}\n\nChoose what happens when the **‚ö° Custom Action** is triggered.`
                    },
                    { type: 14 }, // Separator
                    ...actionMenuComponents
                  ]
                }],
                ephemeral: true
              };
            } else {
              // Unknown action type - send error response
              console.log(`‚ùå DEBUG: Unknown action type "${actionType}" for button "${buttonId}"`);
              return {
                flags: (1 << 15), // IS_COMPONENTS_V2
                components: [{
                  type: 17, // Container
                  components: [{
                    type: 10, // Text Display
                    content: `## ‚ùå Unknown action type: \`${actionType}\`\n\nSupported action types:\n‚Ä¢ \`display_text\` - Show text message\n‚Ä¢ \`update_currency\` - Change player currency\n‚Ä¢ \`follow_up_button\` - Chain to another button\n‚Ä¢ \`conditional\` - Conditional actions\n\nPlease use one of the supported action buttons.`
                  }]
                }],
                ephemeral: true
              };
            }
          }
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_finish_button_')) {
      return ButtonHandlerFactory.create({
        id: 'safari_finish_button',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        ephemeral: true,
        handler: async (context) => {
          const actionId = custom_id.replace('safari_finish_button_', '');
          console.log(`üîç START: safari_finish_button_${actionId} - user ${context.userId}`);

          // Load Safari data to get action details and find the coordinate
          const { loadSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const guildData = allSafariContent[context.guildId] || {};
          const action = guildData.buttons?.[actionId];

          if (!action) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }

          // Get the first coordinate assigned to this action (if any)
          const coordinate = action.coordinates?.[0];
          const activeMapId = guildData.maps?.active;

          // Check if we're in a Safari channel (coordinate's channel)
          let inSafariChannel = false;
          if (coordinate && activeMapId) {
            const coordinateChannelId = guildData.maps?.[activeMapId]?.coordinates?.[coordinate]?.channelId;
            inSafariChannel = coordinateChannelId && coordinateChannelId === context.channelId;
            console.log(`üìç DEBUG: Coordinate ${coordinate}, channel match: ${inSafariChannel} (current: ${context.channelId}, expected: ${coordinateChannelId})`);
          }

          if (!coordinate || !inSafariChannel) {
            // Orphan action OR not in safari channel - show global action editor
            const reason = !coordinate ? 'orphan action (no coordinates)' : 'not in Safari channel';
            console.log(`üåç DEBUG: ${reason} for ${actionId} - showing safari_action_editor`);

            const { createCustomActionSelectionUI } = await import('./customActionUI.js');
            const ui = await createCustomActionSelectionUI({
              guildId: context.guildId
              // No coordinate or mapId - triggers global mode
            });

            console.log(`‚úÖ SUCCESS: safari_finish_button_${actionId} - returned to global action editor`);
            return {
              ...ui,
              ephemeral: true
            };
          }

          console.log(`‚úÖ SUCCESS: safari_finish_button_${actionId} - navigating back to location ${coordinate}`);

          // Show the Map Location Manager for this coordinate
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            selectedId: coordinate,
            mode: 'edit'
          });

          return {
            ...ui,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_remove_action_')) {
      return ButtonHandlerFactory.create({
        id: 'safari_remove_action',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_remove_action - user ${context.userId}`);
          
          // Parse action ID and index from custom_id
          const parts = context.customId.replace('safari_remove_action_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const actionId = parts.slice(0, -1).join('_');
          
          console.log(`üóëÔ∏è Removing action ${actionIndex} from button ${actionId}`);
          
          // Load and update button
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const guildData = allSafariContent[context.guildId] || {};
          const button = guildData.buttons?.[actionId];
          
          if (!button) {
            console.log(`‚ùå FAILURE: safari_remove_action - button ${actionId} not found`);
            return {
              content: '‚ùå Button not found.',
              ephemeral: true
            };
          }
          
          // Remove action at index
          if (button.actions && button.actions[actionIndex] !== undefined) {
            button.actions.splice(actionIndex, 1);
            
            // Re-order remaining actions
            button.actions.forEach((action, idx) => {
              action.order = idx + 1;
            });
            
            await saveSafariContent(allSafariContent);
            console.log(`‚úÖ Safari content saved successfully`);
            
            // Update anchor messages for all coordinates using this action
            try {
              const { queueActionCoordinateUpdates } = await import('./anchorMessageManager.js');
              await queueActionCoordinateUpdates(context.guildId, actionId, 'action_removed');
            } catch (error) {
              console.error('Error queueing anchor updates:', error);
            }
          }
          
          // Return to Custom Action editor
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          const updatedUI = await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId
          });
          
          console.log(`‚úÖ SUCCESS: safari_remove_action - action ${actionIndex} removed from ${actionId}`);
          
          return updatedUI;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('safari_edit_action_')) {
      return ButtonHandlerFactory.create({
        id: 'safari_edit_action',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_edit_action - user ${context.userId}`);
          
          // Parse action ID and index from custom_id
          const parts = context.customId.replace('safari_edit_action_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const actionId = parts.slice(0, -1).join('_');
          
          console.log(`üìù Editing action ${actionIndex} from button ${actionId}`);
          console.log(`üîç DEBUG: custom_id="${context.customId}", parts=[${parts.join(', ')}], actionId="${actionId}", actionIndex=${actionIndex}`);
          
          // Load button and get action
          const { loadSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const guildData = allSafariContent[context.guildId] || {};
          console.log(`üîç DEBUG: Available buttons in guild: [${Object.keys(guildData.buttons || {}).join(', ')}]`);
          const button = guildData.buttons?.[actionId];
          
          if (!button) {
            console.log(`‚ùå FAILURE: safari_edit_action - button ${actionId} not found`);
            return {
              content: '‚ùå Button not found.',
              ephemeral: true
            };
          }
          
          const action = button.actions?.[actionIndex];
          if (!action) {
            console.log(`‚ùå FAILURE: safari_edit_action - action ${actionIndex} not found`);
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }
          
          // Pre-load the configuration state with existing values
          const stateKey = `${context.guildId}_${actionId}_${actionIndex}`;
          
          if (action.type === 'give_item') {
            // Pre-load item configuration state
            const itemStateKey = `${context.guildId}_${actionId}_${action.config?.itemId || action.itemId}_${actionIndex}`;
            dropConfigState.set(itemStateKey, {
              limit: action.config?.limit?.type || null,
              style: action.config?.style || null,
              quantity: action.config?.quantity || action.quantity || 1,
              operation: action.config?.operation || 'give',  // CRITICAL: Load existing operation
              executeOn: action.executeOn || 'true'
            });
            
            // Get item details and show config
            const itemId = action.config?.itemId || action.itemId;
            const item = guildData.items?.[itemId];
            
            console.log(`‚úÖ SUCCESS: safari_edit_action - showing item config for ${item?.name || itemId}`);
            return await showGiveItemConfig(context.guildId, actionId, itemId, item, actionIndex);
            
          } else if (action.type === 'give_currency') {
            // Pre-load currency configuration state
            const currencyStateKey = `${context.guildId}_${actionId}_currency_${actionIndex}`;
            dropConfigState.set(currencyStateKey, {
              limit: action.config?.limit?.type || null,
              style: action.config?.style || null,
              amount: action.config?.amount || action.amount || 0,
              executeOn: action.executeOn || 'true'
            });
            
            // Get custom terms and show config
            const { getCustomTerms } = await import('./safariManager.js');
            const customTerms = await getCustomTerms(context.guildId);
            
            console.log(`‚úÖ SUCCESS: safari_edit_action - showing currency config`);
            return await showGiveCurrencyConfig(context.guildId, actionId, actionIndex, customTerms);
            
          } else if (action.type === 'follow_up_button') {
            // Get the target button ID from existing action
            const targetButtonId = action.config?.buttonId || action.buttonId;
            
            if (!targetButtonId) {
              return {
                content: '‚ùå Follow-up action missing target button configuration.',
                ephemeral: true
              };
            }
            
            console.log(`‚úÖ SUCCESS: safari_edit_action - bypassing selection, going direct to config for follow-up ${targetButtonId}`);
            
            // Pre-load the existing action configuration into state
            const stateKey = `${context.guildId}_${actionId}_followup_${actionIndex}`;
            dropConfigState.set(stateKey, {
              targetButtonId: targetButtonId,
              executeOn: action.executeOn || 'true'
            });
            
            // Go directly to the configuration UI with pre-loaded values
            return await showFollowUpConfig(context.guildId, actionId, targetButtonId, actionIndex);
            
          } else if (action.type === 'display_text') {
            // Show display text configuration entity
            console.log(`‚úÖ SUCCESS: safari_edit_action - showing display_text config for ${actionId}[${actionIndex}]`);
            const { showDisplayTextConfig } = await import('./customActionUI.js');
            return await showDisplayTextConfig(context.guildId, actionId, actionIndex);
            
          } else if (action.type === 'calculate_results') {
            // Show calculate results configuration entity
            console.log(`‚úÖ SUCCESS: safari_edit_action - showing calculate_results config for ${actionId}[${actionIndex}]`);
            const { showCalculateResultsConfig } = await import('./customActionUI.js');
            return await showCalculateResultsConfig(context.guildId, actionId, actionIndex);

          } else if (action.type === 'calculate_attack') {
            // Show calculate attack configuration entity
            console.log(`‚úÖ SUCCESS: safari_edit_action - showing calculate_attack config for ${actionId}[${actionIndex}]`);
            const { showCalculateAttackConfig } = await import('./customActionUI.js');
            return await showCalculateAttackConfig(context.guildId, actionId, actionIndex);

          } else if (action.type === 'modify_attribute') {
            // Show modify attribute configuration entity
            console.log(`‚úÖ SUCCESS: safari_edit_action - showing modify_attribute config for ${actionId}[${actionIndex}]`);
            const { showModifyAttributeConfig } = await import('./customActionUI.js');
            return await showModifyAttributeConfig(context.guildId, actionId, actionIndex);

          } else if (action.type === 'give_role' || action.type === 'remove_role') {
            // Show role configuration UI inline
            console.log(`‚úÖ SUCCESS: safari_edit_action - showing role config for ${actionId}[${actionIndex}]`);

            // Get current role ID if any
            const currentRoleId = action.config?.roleId || '';

            // Create UI for role selection
            const components = [];

            // Header
            components.push({
              type: 10, // Text Display
              content: `# ${action.type === 'give_role' ? 'üéØ Give Role Configuration' : 'üö´ Remove Role Configuration'}\n\n**Action:** ${button.label}\n**Type:** ${action.type}\n\n${currentRoleId ? `**Current Role:** <@&${currentRoleId}>` : '**Current Role:** None selected'}\n\nClick the button below to select a role.`
            });

            // Role selection and delete buttons in same row
            const buttonRow = {
              type: 1, // Action Row
              components: [{
                type: 2, // Button
                custom_id: `safari_role_select_${context.guildId}_${actionId}_${actionIndex}`,
                label: 'Select Role',
                style: 1, // Primary
                emoji: { name: 'üë•' }
              }, {
                type: 2, // Button
                custom_id: `safari_remove_action_${actionId}_${actionIndex}`,
                label: 'Delete Action',
                style: 4, // Danger (red)
                emoji: { name: 'üóëÔ∏è' }
              }]
            };

            components.push(buttonRow);

            // Separator before back button
            components.push({
              type: 14 // Separator
            });

            // Back button
            const backButton = {
              type: 1, // Action Row
              components: [{
                type: 2, // Button
                custom_id: `entity_custom_action_edit_${actionId}`,
                label: '‚Üê Back',
                style: 2, // Secondary
                emoji: { name: '‚ö°' }
              }]
            };

            components.push(backButton);

            return {
              flags: (1 << 15) | (1 << 6), // IS_COMPONENTS_V2 | EPHEMERAL
              components: [{
                type: 17, // Container
                components: components
              }]
            };

          } else {
            console.log(`‚ùå FAILURE: safari_edit_action - unsupported action type ${action.type}`);
            return {
              content: `‚ùå Editing ${action.type} actions is not yet supported.`,
              ephemeral: true
            };
          }
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_role_select_')) {
      // Handle role selection for editing existing role actions
      return ButtonHandlerFactory.create({
        id: 'safari_role_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: safari_role_select - user ${context.userId}`);
          
          // Parse custom_id: safari_role_select_{guildId}_{actionId}_{actionIndex}
          const parts = context.customId.replace('safari_role_select_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const actionId = parts.slice(1, -1).join('_'); // Skip guildId (first part) and actionIndex (last part)
          
          console.log(`üîß Configuring role for action ${actionIndex} in button ${actionId}`);
          
          // Show role selection using Components V2
          return {
            flags: (1 << 15) | (1 << 6), // IS_COMPONENTS_V2 | EPHEMERAL
            components: [{
              type: 17, // Container
              components: [
                {
                  type: 10, // Text Display
                  content: '# üë• Role Selection\n\nSelect a role using the menu below:'
                },
                {
                  type: 1, // Action Row
                  components: [{
                    type: 6, // Role Select (Type 6 per ComponentsV2.md)
                    custom_id: `safari_role_update_${context.guildId}_${actionId}_${actionIndex}`,
                    placeholder: 'Select a role for this action',
                    min_values: 1,
                    max_values: 1
                  }]
                }
              ]
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_role_update_')) {
      // Handle role selection submission for editing
      return ButtonHandlerFactory.create({
        id: 'safari_role_update',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_role_update - user ${context.userId}`);
          
          // Parse custom_id: safari_role_update_{guildId}_{actionId}_{actionIndex}
          const parts = context.customId.replace('safari_role_update_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const actionId = parts.slice(1, -1).join('_'); // Skip guildId and actionIndex
          const roleId = context.values?.[0];
          
          if (!roleId) {
            return {
              content: '‚ùå No role selected.',
              ephemeral: true
            };
          }
          
          console.log(`üéØ Updating role ${roleId} for action ${actionIndex} in button ${actionId}`);
          
          // Update the action's role ID
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[actionId];
          
          if (!button || !button.actions || !button.actions[actionIndex]) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }
          
          // Update the role ID in the action config
          const action = button.actions[actionIndex];
          if (!action.config) {
            action.config = {};
          }
          action.config.roleId = roleId;
          
          // Save the updated data
          await saveSafariContent(safariData);
          
          console.log(`‚úÖ SUCCESS: safari_role_update - updated role for action ${actionIndex} in button ${actionId}`);
          
          // Return to custom action editor
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          return await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId: actionId
          });
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_display_text_edit_')) {
      // Handle Edit Text button for display_text actions
      return ButtonHandlerFactory.create({
        id: 'safari_display_text_edit',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: safari_display_text_edit - user ${context.userId}`);
          
          const { handleDisplayTextEdit } = await import('./customActionUI.js');
          const result = await handleDisplayTextEdit(context.guildId, context.userId, context.customId);
          
          return result;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_display_text_execute_on_')) {
      // Handle display text execute on condition changes
      return ButtonHandlerFactory.create({
        id: 'safari_display_text_execute_on',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: safari_display_text_execute_on - user ${context.userId}`);
          
          const { handleDisplayTextExecuteOn } = await import('./customActionUI.js');
          const result = await handleDisplayTextExecuteOn(context.guildId, context.customId, context.values[0]);
          
          return result;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_calculate_results_scope_')) {
      // Handle calculate results scope selection
      return ButtonHandlerFactory.create({
        id: 'safari_calculate_results_scope',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: safari_calculate_results_scope - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_calculate_results_scope_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const scopeValue = context.values[0];

          // Validate parsing
          if (isNaN(actionIndex) || actionIndex < 0) {
            console.error(`‚ùå Invalid actionIndex parsed: ${actionIndex} from ${context.customId}`);
            return {
              content: '‚ùå Invalid action configuration. Please recreate this action.',
              ephemeral: true
            };
          }

          console.log(`üéØ SCOPE: safari_calculate_results_scope - setting to ${scopeValue} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button) {
            console.error(`‚ùå Button ${buttonId} not found during scope update for guild ${context.guildId}`);
            return {
              content: `‚ùå Button "${buttonId}" not found.\n\nThe button you're trying to update no longer exists.`,
              ephemeral: true
            };
          }

          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }

          // Create action if it doesn't exist (for new actions)
          if (!button.actions[actionIndex]) {
            button.actions[actionIndex] = {
              type: 'calculate_results',
              order: actionIndex,
              config: {
                scope: 'all_players'
              },
              executeOn: 'true'
            };
          }

          // Update the scope value
          if (!button.actions[actionIndex].config) {
            button.actions[actionIndex].config = {};
          }
          button.actions[actionIndex].config.scope = scopeValue;

          // Update metadata
          button.metadata.lastModified = Date.now();

          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showCalculateResultsConfig } = await import('./customActionUI.js');
          const updatedConfig = await showCalculateResultsConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_calculate_results_scope - updated to ${scopeValue}`);
          return {
            ...updatedConfig,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_calculate_results_display_')) {
      // Handle calculate results display mode selection
      return ButtonHandlerFactory.create({
        id: 'safari_calculate_results_display',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: safari_calculate_results_display - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_calculate_results_display_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const displayModeValue = context.values[0];

          // Validate parsing
          if (isNaN(actionIndex) || actionIndex < 0) {
            console.error(`‚ùå Invalid actionIndex parsed: ${actionIndex} from ${context.customId}`);
            return {
              content: '‚ùå Invalid action configuration. Please recreate this action.',
              ephemeral: true
            };
          }

          console.log(`üìä DISPLAY: safari_calculate_results_display - setting to ${displayModeValue} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button) {
            console.error(`‚ùå Button ${buttonId} not found during display mode update for guild ${context.guildId}`);
            return {
              content: `‚ùå Button "${buttonId}" not found.\n\nThe button you're trying to update no longer exists.`,
              ephemeral: true
            };
          }

          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }

          // Create action if it doesn't exist (for new actions)
          if (!button.actions[actionIndex]) {
            button.actions[actionIndex] = {
              type: 'calculate_results',
              order: actionIndex,
              config: {
                scope: 'all_players',
                displayMode: 'silent'
              },
              executeOn: 'true'
            };
          }

          // Update display mode in config
          if (!button.actions[actionIndex].config) {
            button.actions[actionIndex].config = {};
          }
          button.actions[actionIndex].config.displayMode = displayModeValue;

          // Update metadata
          button.metadata.lastModified = Date.now();

          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showCalculateResultsConfig } = await import('./customActionUI.js');
          const updatedConfig = await showCalculateResultsConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_calculate_results_display - updated to ${displayModeValue}`);
          return {
            ...updatedConfig,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_calculate_results_execute_on_')) {
      // Handle calculate results execute on condition changes
      return ButtonHandlerFactory.create({
        id: 'safari_calculate_results_execute_on',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: safari_calculate_results_execute_on - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_calculate_results_execute_on_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const executeOnValue = context.values[0];

          // Validate parsing
          if (isNaN(actionIndex) || actionIndex < 0) {
            console.error(`‚ùå Invalid actionIndex parsed: ${actionIndex} from ${context.customId}`);
            return {
              content: '‚ùå Invalid action configuration. Please recreate this action.',
              ephemeral: true
            };
          }

          console.log(`üéØ EXECUTE ON: safari_calculate_results_execute_on - setting to ${executeOnValue} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button) {
            console.error(`‚ùå Button ${buttonId} not found during executeOn update for guild ${context.guildId}`);
            return {
              content: `‚ùå Button "${buttonId}" not found.\n\nThe button you're trying to update no longer exists.`,
              ephemeral: true
            };
          }

          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }

          // Create action if it doesn't exist (for new actions)
          if (!button.actions[actionIndex]) {
            button.actions[actionIndex] = {
              type: 'calculate_results',
              order: actionIndex,
              config: {
                scope: 'all_players'
              },
              executeOn: 'true'
            };
          }

          // Update the executeOn value
          button.actions[actionIndex].executeOn = executeOnValue;

          // Update metadata
          button.metadata.lastModified = Date.now();

          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showCalculateResultsConfig } = await import('./customActionUI.js');
          const updatedConfig = await showCalculateResultsConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_calculate_results_execute_on - updated to ${executeOnValue}`);
          return {
            ...updatedConfig,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_calculate_attack_scope_')) {
      // Handle calculate attack scope selection
      return ButtonHandlerFactory.create({
        id: 'safari_calculate_attack_scope',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: safari_calculate_attack_scope - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_calculate_attack_scope_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const scopeValue = context.values[0];

          // Validate parsing
          if (isNaN(actionIndex) || actionIndex < 0) {
            console.error(`‚ùå Invalid actionIndex parsed: ${actionIndex} from ${context.customId}`);
            return {
              content: '‚ùå Invalid action configuration. Please recreate this action.',
              ephemeral: true
            };
          }

          console.log(`üéØ SCOPE: safari_calculate_attack_scope - setting to ${scopeValue} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button) {
            console.error(`‚ùå Button ${buttonId} not found during scope update for guild ${context.guildId}`);
            return {
              content: `‚ùå Button "${buttonId}" not found.\n\nThe button you're trying to update no longer exists.`,
              ephemeral: true
            };
          }

          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }

          // Create action if it doesn't exist (for new actions)
          if (!button.actions[actionIndex]) {
            button.actions[actionIndex] = {
              type: 'calculate_attack',
              order: actionIndex,
              config: {
                playerScope: 'all_players',
                displayMode: 'silent'
              },
              executeOn: 'true'
            };
          }

          // Update player scope in config
          if (!button.actions[actionIndex].config) {
            button.actions[actionIndex].config = {};
          }
          button.actions[actionIndex].config.playerScope = scopeValue;

          // Save updated data
          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showCalculateAttackConfig } = await import('./customActionUI.js');
          const updatedConfig = await showCalculateAttackConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_calculate_attack_scope - updated to ${scopeValue}`);
          return {
            ...updatedConfig,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_calculate_attack_display_')) {
      // Handle calculate attack display mode selection
      return ButtonHandlerFactory.create({
        id: 'safari_calculate_attack_display',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: safari_calculate_attack_display - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_calculate_attack_display_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const displayValue = context.values[0];

          // Validate parsing
          if (isNaN(actionIndex) || actionIndex < 0) {
            console.error(`‚ùå Invalid actionIndex parsed: ${actionIndex} from ${context.customId}`);
            return {
              content: '‚ùå Invalid action configuration. Please recreate this action.',
              ephemeral: true
            };
          }

          console.log(`üéØ DISPLAY: safari_calculate_attack_display - setting to ${displayValue} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button) {
            console.error(`‚ùå Button ${buttonId} not found during display update for guild ${context.guildId}`);
            return {
              content: `‚ùå Button "${buttonId}" not found.\n\nThe button you're trying to update no longer exists.`,
              ephemeral: true
            };
          }

          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }

          // Create action if it doesn't exist (for new actions)
          if (!button.actions[actionIndex]) {
            button.actions[actionIndex] = {
              type: 'calculate_attack',
              order: actionIndex,
              config: {
                playerScope: 'all_players',
                displayMode: 'silent'
              },
              executeOn: 'true'
            };
          }

          // Update display mode in config
          if (!button.actions[actionIndex].config) {
            button.actions[actionIndex].config = {};
          }
          button.actions[actionIndex].config.displayMode = displayValue;

          // Save updated data
          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showCalculateAttackConfig } = await import('./customActionUI.js');
          const updatedConfig = await showCalculateAttackConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_calculate_attack_display - updated to ${displayValue}`);
          return {
            ...updatedConfig,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_calculate_attack_execute_on_')) {
      // Handle calculate attack execute on condition changes
      return ButtonHandlerFactory.create({
        id: 'safari_calculate_attack_execute_on',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: safari_calculate_attack_execute_on - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_calculate_attack_execute_on_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const executeOnValue = context.values[0];

          // Validate parsing
          if (isNaN(actionIndex) || actionIndex < 0) {
            console.error(`‚ùå Invalid actionIndex parsed: ${actionIndex} from ${context.customId}`);
            return {
              content: '‚ùå Invalid action configuration. Please recreate this action.',
              ephemeral: true
            };
          }

          console.log(`üéØ EXECUTE ON: safari_calculate_attack_execute_on - setting to ${executeOnValue} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button) {
            console.error(`‚ùå Button ${buttonId} not found during executeOn update for guild ${context.guildId}`);
            return {
              content: `‚ùå Button "${buttonId}" not found.\n\nThe button you're trying to update no longer exists.`,
              ephemeral: true
            };
          }

          // Initialize actions array if needed
          if (!button.actions) {
            button.actions = [];
          }

          // Create action if it doesn't exist (for new actions)
          if (!button.actions[actionIndex]) {
            button.actions[actionIndex] = {
              type: 'calculate_attack',
              order: actionIndex,
              config: {
                playerScope: 'all_players',
                displayMode: 'silent'
              },
              executeOn: 'true'
            };
          }

          // Update executeOn field
          button.actions[actionIndex].executeOn = executeOnValue;

          // Save updated data
          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showCalculateAttackConfig } = await import('./customActionUI.js');
          const updatedConfig = await showCalculateAttackConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_calculate_attack_execute_on - updated to ${executeOnValue}`);
          return {
            ...updatedConfig,
            ephemeral: true
          };
        }
      })(req, res, client);

    // ============================================================
    // MODIFY ATTRIBUTE CONFIG HANDLERS
    // ============================================================

    } else if (custom_id.startsWith('safari_modify_attr_select_')) {
      // Handle modify attribute - attribute selection
      return ButtonHandlerFactory.create({
        id: 'safari_modify_attr_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_modify_attr_select - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_modify_attr_select_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const attributeId = context.values[0];

          console.log(`üìä ATTR: safari_modify_attr_select - setting attributeId to ${attributeId} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button || !button.actions?.[actionIndex]) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }

          // Ensure config exists
          if (!button.actions[actionIndex].config) {
            button.actions[actionIndex].config = {};
          }

          // Update the attribute ID
          button.actions[actionIndex].config.attributeId = attributeId;

          // Save updated data
          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showModifyAttributeConfig } = await import('./customActionUI.js');
          const updatedConfig = await showModifyAttributeConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_modify_attr_select - updated to ${attributeId}`);
          return updatedConfig;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('safari_modify_attr_operation_')) {
      // Handle modify attribute - operation selection
      return ButtonHandlerFactory.create({
        id: 'safari_modify_attr_operation',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_modify_attr_operation - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_modify_attr_operation_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const operationValue = context.values[0];

          console.log(`üìä OPERATION: safari_modify_attr_operation - setting to ${operationValue} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button || !button.actions?.[actionIndex]) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }

          // Ensure config exists
          if (!button.actions[actionIndex].config) {
            button.actions[actionIndex].config = {};
          }

          // Update the operation
          button.actions[actionIndex].config.operation = operationValue;

          // Save updated data
          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showModifyAttributeConfig } = await import('./customActionUI.js');
          const updatedConfig = await showModifyAttributeConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_modify_attr_operation - updated to ${operationValue}`);
          return updatedConfig;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('safari_modify_attr_display_')) {
      // Handle modify attribute - display mode selection
      return ButtonHandlerFactory.create({
        id: 'safari_modify_attr_display',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_modify_attr_display - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_modify_attr_display_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const displayModeValue = context.values[0];

          console.log(`üìä DISPLAY: safari_modify_attr_display - setting to ${displayModeValue} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button || !button.actions?.[actionIndex]) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }

          // Ensure config exists
          if (!button.actions[actionIndex].config) {
            button.actions[actionIndex].config = {};
          }

          // Update the display mode
          button.actions[actionIndex].config.displayMode = displayModeValue;

          // Save updated data
          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showModifyAttributeConfig } = await import('./customActionUI.js');
          const updatedConfig = await showModifyAttributeConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_modify_attr_display - updated to ${displayModeValue}`);
          return updatedConfig;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('safari_modify_attr_execute_on_')) {
      // Handle modify attribute - execute on condition changes
      return ButtonHandlerFactory.create({
        id: 'safari_modify_attr_execute_on',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_modify_attr_execute_on - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_modify_attr_execute_on_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const executeOnValue = context.values[0];

          console.log(`üìä EXEC: safari_modify_attr_execute_on - setting to ${executeOnValue} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button || !button.actions?.[actionIndex]) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }

          // Update the executeOn field
          button.actions[actionIndex].executeOn = executeOnValue;

          // Save updated data
          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showModifyAttributeConfig } = await import('./customActionUI.js');
          const updatedConfig = await showModifyAttributeConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_modify_attr_execute_on - updated to ${executeOnValue}`);
          return updatedConfig;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('safari_modify_attr_limit_')) {
      // Handle modify attribute - usage limit selection
      return ButtonHandlerFactory.create({
        id: 'safari_modify_attr_limit',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_modify_attr_limit - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_modify_attr_limit_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const limitValue = context.values[0];

          console.log(`üìä LIMIT: safari_modify_attr_limit - setting to ${limitValue} for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button || !button.actions?.[actionIndex]) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }

          // Ensure config exists
          if (!button.actions[actionIndex].config) {
            button.actions[actionIndex].config = {};
          }

          // Update the limit configuration
          if (limitValue === 'unlimited') {
            // Remove limit config if unlimited
            delete button.actions[actionIndex].config.limit;
          } else {
            // Set limit with type and empty claimedBy
            button.actions[actionIndex].config.limit = {
              type: limitValue,
              claimedBy: limitValue === 'once_per_player' ? [] : null
            };
          }

          // Save updated data
          await saveSafariContent(safariData);

          // Return updated configuration UI
          const { showModifyAttributeConfig } = await import('./customActionUI.js');
          const updatedConfig = await showModifyAttributeConfig(context.guildId, buttonId, actionIndex);

          console.log(`‚úÖ SUCCESS: safari_modify_attr_limit - updated to ${limitValue}`);
          return updatedConfig;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('safari_modify_attr_reset_')) {
      // Handle modify attribute - reset claims
      return ButtonHandlerFactory.create({
        id: 'safari_modify_attr_reset',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîÑ RESET: safari_modify_attr_reset - user ${context.userId}`);

          // Parse buttonId and actionIndex from custom_id
          const parts = context.customId.replace('safari_modify_attr_reset_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');

          console.log(`üîÑ RESET: safari_modify_attr_reset - resetting claims for ${buttonId}[${actionIndex}]`);

          // Load and update safari data
          const { saveSafariContent, loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];

          if (!button || !button.actions?.[actionIndex]) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }

          const action = button.actions[actionIndex];

          // Reset the claimedBy based on limit type
          if (action.config?.limit) {
            if (action.config.limit.type === 'once_per_player') {
              action.config.limit.claimedBy = [];
            } else if (action.config.limit.type === 'once_globally') {
              action.config.limit.claimedBy = null;
            }
          }

          // Save updated data
          await saveSafariContent(safariData);
          console.log(`‚úÖ Claims reset for modify_attribute action ${actionIndex}`);

          // Return updated configuration UI
          const { showModifyAttributeConfig } = await import('./customActionUI.js');
          const updatedConfig = await showModifyAttributeConfig(context.guildId, buttonId, actionIndex);

          return updatedConfig;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('safari_modify_attr_amount_')) {
      // Handle modify attribute - amount button (opens modal)
      // NOTE: Modals require direct res.send() - ButtonHandlerFactory can't handle them properly
      const guildId = req.body.guild_id;
      const userId = req.body.member?.user?.id;

      // Check permissions
      const memberPermissions = BigInt(req.body.member?.permissions || 0);
      if (!(memberPermissions & PermissionFlagsBits.ManageRoles)) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå You need Manage Roles permission to use this.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      console.log(`üîç START: safari_modify_attr_amount - user ${userId}`);

      // Parse buttonId and actionIndex from custom_id
      const parts = custom_id.replace('safari_modify_attr_amount_', '').split('_');
      const actionIndex = parseInt(parts[parts.length - 1]);
      const buttonId = parts.slice(0, -1).join('_');

      // Load current amount
      const { loadSafariContent } = await import('./safariManager.js');
      const safariData = await loadSafariContent();
      const button = safariData[guildId]?.buttons?.[buttonId];
      const currentAmount = button?.actions?.[actionIndex]?.config?.amount || 0;

      console.log(`üìä AMOUNT: safari_modify_attr_amount - opening modal for ${buttonId}[${actionIndex}], current: ${currentAmount}`);

      // Send modal response directly
      return res.send({
        type: InteractionResponseType.MODAL,
        data: {
          custom_id: `modal_modify_attr_amount_${buttonId}_${actionIndex}`,
          title: 'Set Attribute Amount',
          components: [
            {
              type: 1, // Action Row
              components: [
                {
                  type: 4, // Text Input
                  custom_id: 'attr_amount',
                  label: 'Amount',
                  style: 1, // Short
                  placeholder: 'Enter a positive number (e.g., 5, 10, 100)',
                  required: true,
                  max_length: 10,
                  value: currentAmount.toString()
                }
              ]
            }
          ]
        }
      });

    } else if (custom_id.startsWith('safari_drop_type_')) {
      // Handle drop type selection
      return ButtonHandlerFactory.create({
        id: 'safari_drop_type',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const parts = context.customId.replace('safari_drop_type_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          
          console.log(`üîÑ START: safari_drop_type - button ${buttonId}, action ${actionIndex}`);
          
          // Show drop type selection
          return {
            components: [{
              type: 17, // Container
              components: [
                {
                  type: 10, // Text Display
                  content: '## Select Usage Limit\n\nChoose how often this reward can be claimed:'
                },
                { type: 14 }, // Separator
                {
                  type: 1, // Action Row
                  components: [{
                    type: 3, // String Select
                    custom_id: `safari_drop_type_select_${buttonId}_${actionIndex}`,
                    placeholder: 'Select usage limit...',
                    options: [
                      {
                        label: 'Unlimited',
                        value: 'unlimited',
                        description: 'Players can claim repeatedly',
                        emoji: { name: '‚ôæÔ∏è' }
                      },
                      {
                        label: 'Once per Player',
                        value: 'once_per_player',
                        description: 'Each player can claim once',
                        emoji: { name: 'üë§' }
                      },
                      {
                        label: 'Once Globally',
                        value: 'once_globally',
                        description: 'First player to claim gets it',
                        emoji: { name: 'üåç' }
                      }
                    ]
                  }]
                }
              ]
            }],
            flags: (1 << 15), // IS_COMPONENTS_V2
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_drop_type_select_')) {
      // Handle drop type selection from dropdown
      return ButtonHandlerFactory.create({
        id: 'safari_drop_type_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('safari_drop_type_select_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          const dropType = context.values?.[0];
          
          console.log(`üéØ SELECTED: safari_drop_type_select - ${dropType} for ${buttonId}[${actionIndex}]`);
          
          // Update the action's drop type
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];
          
          if (button && button.actions[actionIndex]) {
            button.actions[actionIndex].config.limit = {
              type: dropType,
              claimedBy: dropType === 'unlimited' ? undefined : []
            };
            await saveSafariContent(safariData);
          }
          
          // Return to drop configuration
          return showDropConfiguration(context.guildId, buttonId, actionIndex);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_drop_style_')) {
      // Handle button style selection
      return ButtonHandlerFactory.create({
        id: 'safari_drop_style',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const parts = context.customId.replace('safari_drop_style_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          
          console.log(`üé® START: safari_drop_style - button ${buttonId}, action ${actionIndex}`);
          
          // Show style selection
          return {
            components: [{
              type: 17, // Container
              components: [
                {
                  type: 10, // Text Display
                  content: '## Select Button Style\n\nChoose how the action button will appear:'
                },
                { type: 14 }, // Separator
                {
                  type: 1, // Action Row
                  components: [
                    {
                      type: 2, // Button
                      custom_id: `safari_drop_style_select_${buttonId}_${actionIndex}_1`,
                      label: 'Primary',
                      style: 1 // Blue
                    },
                    {
                      type: 2, // Button
                      custom_id: `safari_drop_style_select_${buttonId}_${actionIndex}_2`,
                      label: 'Secondary',
                      style: 2 // Grey
                    },
                    {
                      type: 2, // Button
                      custom_id: `safari_drop_style_select_${buttonId}_${actionIndex}_3`,
                      label: 'Success',
                      style: 3 // Green
                    },
                    {
                      type: 2, // Button
                      custom_id: `safari_drop_style_select_${buttonId}_${actionIndex}_4`,
                      label: 'Danger',
                      style: 4 // Red
                    }
                  ]
                }
              ]
            }],
            flags: (1 << 15), // IS_COMPONENTS_V2
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_drop_style_select_')) {
      // Handle style selection
      return ButtonHandlerFactory.create({
        id: 'safari_drop_style_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('safari_drop_style_select_', '').split('_');
          const style = parseInt(parts[parts.length - 1]);
          const actionIndex = parseInt(parts[parts.length - 2]);
          const buttonId = parts.slice(0, -2).join('_');
          
          console.log(`üé® SELECTED: safari_drop_style_select - style ${style} for ${buttonId}[${actionIndex}]`);
          
          // Update the button's style
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];
          
          if (button) {
            button.style = style;
            await saveSafariContent(safariData);
          }
          
          // Return to drop configuration
          return showDropConfiguration(context.guildId, buttonId, actionIndex);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_drop_reset_')) {
      // Handle claims reset
      return ButtonHandlerFactory.create({
        id: 'safari_drop_reset',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('safari_drop_reset_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          
          console.log(`üîÑ RESET: safari_drop_reset - button ${buttonId}, action ${actionIndex}`);
          
          // Reset claims for this action
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[buttonId];
          
          if (button && button.actions[actionIndex]) {
            if (button.actions[actionIndex].config.limit) {
              button.actions[actionIndex].config.limit.claimedBy = 
                button.actions[actionIndex].config.limit.type === 'unlimited' ? undefined : [];
            }
            await saveSafariContent(safariData);
          }
          
          // Return to drop configuration
          return showDropConfiguration(context.guildId, buttonId, actionIndex);
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_drop_save_')) {
      // Handle save and finish
      return ButtonHandlerFactory.create({
        id: 'safari_drop_save',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('safari_drop_save_', '').split('_');
          const actionIndex = parseInt(parts[parts.length - 1]);
          const buttonId = parts.slice(0, -1).join('_');
          
          console.log(`‚úÖ SAVE: safari_drop_save - button ${buttonId}, action ${actionIndex}`);
          
          // Load Safari data to trigger the finish button logic
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const guildData = allSafariContent[context.guildId] || {};
          const action = guildData.buttons?.[buttonId];
          
          if (!action) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }
          
          // Update map coordinate assignments - COMPLETE BIDIRECTIONAL SYNC
          // (reusing finish button logic)
          if (guildData.maps) {
            for (const mapId in guildData.maps) {
              const map = guildData.maps[mapId];
              if (map.coordinates) {
                for (const coord in map.coordinates) {
                  const coordData = map.coordinates[coord];
                  if (coordData.buttons) {
                    coordData.buttons = coordData.buttons.filter(id => id !== buttonId);
                  }
                }
              }
            }
          }
          
          if (action.coordinates && action.coordinates.length > 0) {
            if (!guildData.maps) guildData.maps = {};
            
            for (const mapId in guildData.maps) {
              if (mapId === 'active' || typeof guildData.maps[mapId] !== 'object') continue;
              
              const map = guildData.maps[mapId];
              if (!map.coordinates) map.coordinates = {};
              
              for (const coord of action.coordinates) {
                if (!map.coordinates[coord]) {
                  map.coordinates[coord] = {
                    buttons: []
                  };
                }
                
                if (!map.coordinates[coord].buttons.includes(buttonId)) {
                  map.coordinates[coord].buttons.push(buttonId);
                }
              }
            }
          }
          
          await saveSafariContent(allSafariContent);
          
          // Update anchor messages
          if (action.coordinates && action.coordinates.length > 0) {
            const { updateAnchorMessage } = await import('./mapCellUpdater.js');
            const activeMapId = allSafariContent[context.guildId]?.maps?.active;
            
            for (const coord of action.coordinates) {
              const coordData = allSafariContent[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
              if (coordData?.anchorMessageId) {
                try {
                  await updateAnchorMessage(context.guildId, coord, context.client);
                  console.log(`üìç Updated anchor message for ${coord}`);
                } catch (error) {
                  console.error(`Error updating anchor for ${coord}:`, error);
                }
              }
            }
          }
          
          // Show updated Custom Action Editor
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          const updatedUI = await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId: buttonId
          });
          
          return {
            ...updatedUI,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('custom_action_trigger_type_')) {
      // Handle trigger type selection
      return ButtonHandlerFactory.create({
        id: 'custom_action_trigger_type',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: custom_action_trigger_type - user ${context.userId}`);
          
          const selectedValue = context.values[0];
          const actionId = context.customId.replace('custom_action_trigger_type_', '');
          
          console.log(`üéØ Updating trigger type for ${actionId} to ${selectedValue}`);
          
          // Load and update button
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const guildData = allSafariContent[context.guildId] || {};
          const button = guildData.buttons?.[actionId];
          
          if (!button) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }
          
          // Update trigger type
          if (!button.trigger) {
            button.trigger = {};
          }
          button.trigger.type = selectedValue;
          
          // Set default configuration for new trigger type
          switch (selectedValue) {
            case 'button':
              button.trigger.button = {
                label: button.label || 'Click Me',
                emoji: button.emoji || '‚ö°',
                style: 'Primary' // Default to Primary (Blue) button style
              };
              break;
            case 'modal':
              button.trigger.modal = {
                keywords: [],
                caseSensitive: false
              };
              break;
            case 'select':
              button.trigger.select = {
                placeholder: 'Select an option',
                options: []
              };
              break;
            case 'schedule':
              button.trigger.schedule = {
                channelId: null
              };
              break;
          }

          await saveSafariContent(allSafariContent);
          
          // Update anchor messages for all coordinates using this action
          try {
            const { queueActionCoordinateUpdates } = await import('./anchorMessageManager.js');
            await queueActionCoordinateUpdates(context.guildId, actionId, 'trigger_type_updated');
          } catch (error) {
            console.error('Error queueing anchor updates:', error);
          }
          
          // Show trigger configuration UI
          const { createTriggerConfigUI } = await import('./customActionUI.js');
          const configUI = await createTriggerConfigUI({ guildId: context.guildId, actionId });
          
          console.log(`‚úÖ SUCCESS: custom_action_trigger_type - updated to ${selectedValue}`);
          return configUI;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('custom_action_button_style_')) {
      // Handle button style selection for custom actions
      return ButtonHandlerFactory.create({
        id: 'custom_action_button_style',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: custom_action_button_style - user ${context.userId}`);

          const selectedValue = context.values[0];
          const actionId = context.customId.replace('custom_action_button_style_', '');

          console.log(`üé® Updating button style for ${actionId} to ${selectedValue}`);

          // Load and update button
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const guildData = allSafariContent[context.guildId] || {};
          const button = guildData.buttons?.[actionId];

          if (!button) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }

          // Initialize trigger and button objects if needed
          if (!button.trigger) {
            button.trigger = { type: 'button' };
          }
          if (!button.trigger.button) {
            button.trigger.button = {
              label: button.label || 'Click Me',
              emoji: button.emoji || '‚ö°'
            };
          }

          // Update button style
          button.trigger.button.style = selectedValue;

          await saveSafariContent(allSafariContent);

          // Update anchor messages for all coordinates using this action
          try {
            const { queueActionCoordinateUpdates } = await import('./anchorMessageManager.js');
            await queueActionCoordinateUpdates(context.guildId, actionId, 'button_style_updated');
          } catch (error) {
            console.error('Error queueing anchor updates:', error);
          }

          // Show updated trigger configuration UI
          const { createTriggerConfigUI } = await import('./customActionUI.js');
          const configUI = await createTriggerConfigUI({ guildId: context.guildId, actionId });

          console.log(`‚úÖ SUCCESS: custom_action_button_style - updated to ${selectedValue}`);
          return configUI;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('ca_schedule_channel_')) {
      // Handle channel selection for scheduled custom action trigger
      return ButtonHandlerFactory.create({
        id: 'ca_schedule_channel',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const actionId = context.customId.replace('ca_schedule_channel_', '');
          const selectedChannelId = context.values[0];

          console.log(`üì∫ Saving schedule channel ${selectedChannelId} for action ${actionId}`);

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const button = allSafariContent[context.guildId]?.buttons?.[actionId];

          if (!button) {
            return { content: '‚ùå Action not found.', ephemeral: true };
          }

          if (!button.trigger) button.trigger = { type: 'schedule' };
          if (!button.trigger.schedule) button.trigger.schedule = {};
          button.trigger.schedule.channelId = selectedChannelId;
          await saveSafariContent(allSafariContent);

          const { createTriggerConfigUI } = await import('./customActionUI.js');
          return await createTriggerConfigUI({ guildId: context.guildId, actionId });
        }
      })(req, res, client);
    } else if (custom_id.startsWith('ca_schedule_task_')) {
      // Handle "Schedule Task" button ‚Äî opens time-input modal
      // Uses legacy pattern because ButtonHandlerFactory can't send MODAL responses
      try {
        const guildId = req.body.guild_id;
        const member = req.body.member;
        const actionId = custom_id.replace('ca_schedule_task_', '');

        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to schedule actions.')) return;

        const { loadSafariContent } = await import('./safariManager.js');
        const allSafariContent = await loadSafariContent();
        const button = allSafariContent[guildId]?.buttons?.[actionId];

        if (!button) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: { content: '‚ùå Action not found.', flags: InteractionResponseFlags.EPHEMERAL }
          });
        }

        const channelId = button.trigger?.schedule?.channelId;
        if (!channelId) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: { content: '‚ùå Please select a channel first.', flags: InteractionResponseFlags.EPHEMERAL }
          });
        }

        // Open modal with hours + minutes inputs
        const modalComponents = [
          {
            type: 10, // Text Display
            content: `### Schedule: ${button.name || 'Custom Action'}\nChannel: <#${channelId}>`
          },
          {
            type: 18, // Label
            label: 'Hours from now',
            description: '0-168 hours (leave empty to skip)',
            component: {
              type: 4, // Text Input
              custom_id: 'schedule_hours',
              style: 1,
              placeholder: '4',
              max_length: 3,
              required: false
            }
          },
          {
            type: 18, // Label
            label: 'Minutes from now',
            description: '0-59 minutes (leave empty to skip)',
            component: {
              type: 4, // Text Input
              custom_id: 'schedule_minutes',
              style: 1,
              placeholder: '30',
              max_length: 3,
              required: false
            }
          }
        ];

        return res.send({
          type: InteractionResponseType.MODAL,
          data: {
            custom_id: `ca_schedule_modal_${actionId}_${channelId}`,
            title: `Schedule ${(button.name || 'Action').substring(0, 30)}`,
            components: modalComponents
          }
        });
      } catch (error) {
        console.error('Error opening schedule modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: { content: '‚ùå Error opening schedule modal.', flags: InteractionResponseFlags.EPHEMERAL }
        });
      }
    } else if (custom_id.startsWith('ca_schedule_cancel_')) {
      // Handle cancel of a scheduled custom action task
      return ButtonHandlerFactory.create({
        id: 'ca_schedule_cancel',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const jobId = context.customId.replace('ca_schedule_cancel_', '');

          // Get the job's actionId before cancelling so we can re-render the right UI
          const allJobs = scheduler.getJobs({ action: 'execute_custom_action' });
          const job = allJobs.find(j => j.id === jobId);
          const actionId = job?.payload?.actionId;

          if (!job) {
            return { content: '‚ùå Task not found or already completed.', ephemeral: true };
          }

          scheduler.cancel(jobId);
          console.log(`üóëÔ∏è Cancelled scheduled custom action job ${jobId}`);

          if (actionId) {
            const { createTriggerConfigUI } = await import('./customActionUI.js');
            return await createTriggerConfigUI({ guildId: context.guildId, actionId });
          }

          return { content: '‚úÖ Scheduled task cancelled.', ephemeral: true };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('button_preview_')) {
      // Handle button preview clicks - do nothing to avoid errors
      return ButtonHandlerFactory.create({
        id: 'button_preview',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç Button preview clicked for ${context.customId} - doing nothing`);

          // Simply acknowledge the interaction without showing anything to the user
          return {
            type: 6 // DEFERRED_UPDATE_MESSAGE - acknowledges without response
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_player_menu') {
      // Player Menu button - back navigation for all players (no permission required)
      return ButtonHandlerFactory.create({
        id: 'prod_player_menu',
        updateMessage: true,
        handler: async (context) => {
          const { guildId, userId, client } = context;

          const playerData = await loadPlayerData();
          const guild = await client.guilds.fetch(guildId);
          const guildMember = await guild.members.fetch(userId);

          return await createPlayerManagementUI({
            mode: PlayerManagementMode.PLAYER,
            targetMember: guildMember,
            playerData,
            guildId,
            userId,
            channelId: context.channelId,
            showUserSelect: false,
            showVanityRoles: false,
            title: 'CastBot | Player Menu',
            client
          });
        }
      })(req, res, client);
    } else if (custom_id === 'prod_timezone_react') {
      // Execute same logic as player_set_timezone command (available to all users)
      try {
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);

        // Clean up any missing roles first
        const { cleanupMissingRoles } = await import('./storage.js');
        const cleanupResult = await cleanupMissingRoles(guildId, guild);
        if (cleanupResult.cleaned > 0) {
          console.log(`üßπ CLEANUP: Cleaned up ${cleanupResult.cleaned} missing roles before creating timezone reaction`);
        }

        // Get timezone roles from storage
        const timezones = await getGuildTimezones(guildId);
        if (!Object.keys(timezones).length) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'No timezone roles found. Ask an admin to add some using the "üó∫Ô∏è Add Timezone" button in the admin menu first!',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Get role objects and sort alphabetically
        console.log('üîç DEBUG: Creating timezone reaction message');
        const roleIds = Object.keys(timezones);
        console.log('üîç DEBUG: Found timezone role IDs:', roleIds);
        
        const roles = [];
        for (const roleId of roleIds) {
          try {
            const role = await guild.roles.fetch(roleId);
            if (role) {
              roles.push(role);
            } else {
              console.log(`‚ö†Ô∏è WARNING: Timezone role ${roleId} not found in Discord - may have been deleted`);
            }
          } catch (error) {
            console.log(`‚ö†Ô∏è WARNING: Failed to fetch timezone role ${roleId}:`, error.message);
          }
        }
        
        const sortedRoles = roles.sort((a, b) => a.name.localeCompare(b.name));
        console.log('üîç DEBUG: Found valid timezone roles:', sortedRoles.map(r => r.name));

        if (sortedRoles.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå **No Valid Timezone Roles Found**\n\nAll configured timezone roles appear to have been deleted. Please run **Setup** again to recreate them.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        if (sortedRoles.length > REACTION_EMOJIS.length) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `Too many timezone roles to post React for Pronouns prompt (maximum ${REACTION_EMOJIS.length} supported due to Discord limits). Please remove timezones from \`/menu\` > Reaction Roles > Bulk Modify (no offset) until you have ${REACTION_EMOJIS.length} or less.`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Create embed
        const embed = new EmbedBuilder()
          .setTitle('Timezone Role Selection')
          .setDescription('React with the emoji corresponding to your timezone:\n\n' + 
            sortedRoles.map((role, i) => `${REACTION_EMOJIS[i]} - ${role.name}`).join('\n'))
          .setColor('#7ED321');

        // Send initial response with embed directly
        res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            embeds: [embed]
          }
        });

        // Get the webhook message to add reactions
        // Use interaction webhook to reliably get the message we just sent
        const webhookUrl = `https://discord.com/api/v10/webhooks/${req.body.application_id}/${req.body.token}/messages/@original`;
        
        // Wait a moment for the message to be fully processed
        await new Promise(resolve => setTimeout(resolve, 500));
        
        let messageId;
        try {
          const webhookResponse = await fetch(webhookUrl, {
            headers: { Authorization: `Bot ${process.env.DISCORD_TOKEN}` }
          });
          const webhookData = await webhookResponse.json();
          messageId = webhookData.id;
          
          if (!messageId) {
            console.error('Failed to get message ID from webhook response');
            return;
          }
        } catch (error) {
          console.error('Failed to fetch webhook message:', error);
          return;
        }

        // Add reactions with proper error handling
        for (let i = 0; i < sortedRoles.length; i++) {
          try {
            await fetch(
              `https://discord.com/api/v10/channels/${req.body.channel_id}/messages/${messageId}/reactions/${encodeURIComponent(REACTION_EMOJIS[i])}/@me`,
              {
                method: 'PUT',
                headers: {
                  Authorization: `Bot ${process.env.DISCORD_TOKEN}`,
                },
              }
            );
            // Small delay to avoid rate limits
            await new Promise(resolve => setTimeout(resolve, 100));
          } catch (error) {
            console.error(`Failed to add reaction ${REACTION_EMOJIS[i]}:`, error);
          }
        }

        // Store role-emoji mappings persistently
        const roleMapping = Object.fromEntries(sortedRoles.map((role, i) => [REACTION_EMOJIS[i], role.id]));
        roleMapping.isTimezone = true;  // Mark this as a timezone role mapping
        
        // Save to persistent storage
        await saveReactionMapping(guildId, messageId, roleMapping);
        
        // Also update in-memory cache for immediate use
        if (!client.roleReactions) client.roleReactions = new Map();
        client.roleReactions.set(messageId, roleMapping);

      } catch (error) {
        console.error('Error in prod_timezone_react:', error);
        // Only send error response if we haven't already sent a response
        if (!res.headersSent) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'Error creating timezone reaction message',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
      }
    } else if (custom_id === 'prod_availability_react') {
      // Post availability time slot reactions - PUBLIC MESSAGE for everyone to react
      return ButtonHandlerFactory.create({
        id: 'prod_availability_react',
        publicMessage: true, // CRITICAL: Make this message public, not ephemeral
        handler: async (context) => {
          console.log(`üîç START: prod_availability_react - user ${context.userId}`);
          
          const { guildId, userId } = context;
          const guild = await client.guilds.fetch(guildId);
          
          // Fetch the member properly
          const member = await guild.members.fetch(userId);
          
          // Get user's timezone role to calculate their local times
          const timezones = await getGuildTimezones(guildId);
          const timezoneRole = member.roles.cache.find(role => timezones[role.id]);
          
          if (!timezoneRole) {
            console.log(`‚ö†Ô∏è User ${userId} has no timezone role`);
            return {
              content: '‚ö†Ô∏è **Please set your timezone first!**\n\nUse `/player_set_timezone` or ask an admin to assign you a timezone role.',
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }
          
          const userOffset = timezones[timezoneRole.id].offset;
          console.log(`User ${userId} timezone: ${timezoneRole.name} (UTC${userOffset >= 0 ? '+' : ''}${userOffset})`);
          
          // Get current UTC hour
          const now = new Date();
          const currentUTCHour = now.getUTCHours();
          
          // Create time slots starting from next hour (20 slots total)
          const timeSlots = [];
          const reactionEmojis = [
            '1Ô∏è‚É£', '2Ô∏è‚É£', '3Ô∏è‚É£', '4Ô∏è‚É£', '5Ô∏è‚É£', '6Ô∏è‚É£', '7Ô∏è‚É£', '8Ô∏è‚É£', '9Ô∏è‚É£', 'üîü',
            'üá¶', 'üáß', 'üá®', 'üá©', 'üá™', 'üá´', 'üá¨', 'üá≠', 'üáÆ', 'üáØ'
          ];
          
          // Start from the next hour and go for 20 hours
          for (let i = 0; i < 20; i++) {
            const utcHour = (currentUTCHour + i + 1) % 24; // Start from next hour
            const localHour = (utcHour + userOffset + 24) % 24;
            const period = localHour >= 12 ? 'PM' : 'AM';
            const displayHour = localHour === 0 ? 12 : (localHour > 12 ? localHour - 12 : localHour);
            const timeString = `${displayHour}:00 ${period}`;
            
            // Add day indicator if it's tomorrow
            const dayIndicator = (currentUTCHour + i + 1) >= 24 ? ' (tomorrow)' : '';
            
            timeSlots.push({
              emoji: reactionEmojis[i],
              time: timeString + dayIndicator,
              utcHour: utcHour
            });
          }
          
          // Create Components V2 message with time slots
          const availabilityComponents = [
            {
              type: 10, // Text Display
              content: `# üïê Challenge Availability Times`
            },
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display
              content: `**React to indicate when you're available for challenges!**\n\nYour timezone: **${timezoneRole.name}** (UTC${userOffset >= 0 ? '+' : ''}${userOffset})`
            },
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display
              content: `**Available Time Slots (in your local time):**\n\n${timeSlots.map(slot => `${slot.emoji} - **${slot.time}**`).join('\n')}`
            },
            {
              type: 14, // Separator
              spacing: 1
            },
            {
              type: 10, // Text Display
              content: `*Select all times when you can participate in challenges*`
            }
          ];
          
          const availabilityContainer = {
            type: 17, // Container
            accent_color: 0x00FF00, // Green accent
            components: availabilityComponents
          };
          
          // Store data for later use
          // CRITICAL: We need to bypass ButtonHandlerFactory's default behavior
          // and send the response directly to make it public
          
          // Send public message directly (not ephemeral)
          res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              components: [availabilityContainer],
              flags: (1 << 15) // ONLY IS_COMPONENTS_V2, no EPHEMERAL flag
            }
          });
          
          // Add reactions after the response is sent
          setTimeout(async () => {
            try {
              // Get the message to add reactions
              const webhookUrl = `https://discord.com/api/v10/webhooks/${req.body.application_id}/${req.body.token}/messages/@original`;
              
              const webhookResponse = await fetch(webhookUrl, {
                headers: { Authorization: `Bot ${process.env.DISCORD_TOKEN}` }
              });
              
              if (!webhookResponse.ok) {
                console.error('Failed to fetch webhook message:', webhookResponse.status);
                return;
              }
              
              const webhookData = await webhookResponse.json();
              const messageId = webhookData.id;
              
              if (!messageId) {
                console.error('No message ID in webhook response');
                return;
              }
              
              // Get the actual message from Discord
              const channel = await client.channels.fetch(req.body.channel_id);
              const message = await channel.messages.fetch(messageId);
              
              // Add reactions sequentially
              for (const emoji of reactionEmojis) {
                try {
                  await message.react(emoji);
                  await new Promise(resolve => setTimeout(resolve, 250)); // Rate limit prevention
                } catch (error) {
                  console.error(`Failed to add reaction ${emoji}:`, error);
                }
              }
              
              // Store availability mapping in client memory AND persistent storage
              if (!client.availabilityReactions) client.availabilityReactions = new Map();
              
              // Create a universal slot mapping (not user-specific)
              const universalSlots = [];
              for (let i = 0; i < 20; i++) {
                const utcHour = (currentUTCHour + i + 1) % 24;
                universalSlots.push({
                  emoji: reactionEmojis[i],
                  utcHour: utcHour
                });
              }
              
              client.availabilityReactions.set(messageId, {
                slots: universalSlots,
                guildId: guildId,
                startHour: currentUTCHour
              });
              
              // Also save to persistent storage so it survives restarts
              const playerData = await loadPlayerData();
              if (!playerData[guildId].availabilityMessages) {
                playerData[guildId].availabilityMessages = {};
              }
              playerData[guildId].availabilityMessages[messageId] = {
                slots: universalSlots,
                startHour: currentUTCHour,
                channelId: req.body.channel_id,
                createdAt: Date.now()
              };
              await savePlayerData(playerData);
              
              console.log(`‚úÖ Reactions added to availability message ${messageId}`);
            } catch (error) {
              console.error('Error adding reactions to availability message:', error);
            }
          }, 1000); // Wait for response to be sent
          
          console.log(`‚úÖ SUCCESS: prod_availability_react - created availability message`);
          // Don't return anything since we already sent the response directly
          return;
        }
      })(req, res, client);
    } else if (custom_id === 'prod_availability_options') {
      // View availability groupings
      return ButtonHandlerFactory.create({
        id: 'prod_availability_options',
        handler: async (context) => {
          console.log(`üîç START: prod_availability_options - user ${context.userId}`);
          
          const { guildId } = context;
          const playerData = await loadPlayerData();
          
          // Get all player availability data
          const availability = playerData[guildId]?.availability || {};
          
          if (Object.keys(availability).length === 0) {
            const noDataComponents = [
              {
                type: 10, // Text Display
                content: '## üìä Availability Analysis'
              },
              {
                type: 14 // Separator
              },
              {
                type: 10, // Text Display
                content: '**No availability data yet**\n\nPlayers need to react to availability messages first.'
              }
            ];
            
            const noDataContainer = {
              type: 17, // Container
              accent_color: 0xFF0000, // Red accent for no data
              components: noDataComponents
            };
            
            return {
              components: [noDataContainer],
              flags: (1 << 15) // IS_COMPONENTS_V2 (removed EPHEMERAL so all can see availability)
            };
          }
          
          // Analyze overlapping availability
          const timeSlotCoverage = {};
          
          for (let hour = 0; hour < 20; hour++) {
            timeSlotCoverage[hour] = [];
            
            for (const [userId, userSlots] of Object.entries(availability)) {
              if (userSlots.includes(hour)) {
                timeSlotCoverage[hour].push(userId);
              }
            }
          }
          
          // Find optimal time slots (most players available)
          const sortedSlots = Object.entries(timeSlotCoverage)
            .sort((a, b) => b[1].length - a[1].length)
            .filter(([_, players]) => players.length > 0);
          
          // Create Components V2 display
          const analysisComponents = [
            {
              type: 10, // Text Display
              content: '## üìä Availability Analysis'
            },
            {
              type: 14 // Separator
            }
          ];
          
          if (sortedSlots.length === 0) {
            analysisComponents.push({
              type: 10, // Text Display
              content: '*No overlapping availability found*'
            });
          } else {
            analysisComponents.push({
              type: 10, // Text Display
              content: '**Optimal Challenge Times:**'
            });
            
            // Get guild for member fetching
            const guild = await client.guilds.fetch(guildId);
            
            // Show top time slots with sections
            for (let i = 0; i < Math.min(10, sortedSlots.length); i++) {
              const [hour, playerIds] = sortedSlots[i];
              const hourNum = parseInt(hour);
              const displayHour = hourNum === 0 ? 12 : (hourNum > 12 ? hourNum - 12 : hourNum);
              const period = hourNum >= 12 ? 'PM' : 'AM';
              const timeString = `${displayHour}:00 ${period} UTC`;
              
              // Get player names
              const playerNames = [];
              for (const playerId of playerIds) {
                try {
                  const member = await guild.members.fetch(playerId);
                  playerNames.push(member.displayName);
                } catch (e) {
                  // Skip unknown players
                }
              }
              
              if (playerNames.length > 0) {
                // Add separator between time slots
                if (i > 0) {
                  analysisComponents.push({
                    type: 14, // Separator
                    spacing: 1, // Small spacing
                    divider: false // No line
                  });
                }
                
                // Add time slot section - simpler format without nested components
                analysisComponents.push({
                  type: 10, // Text Display
                  content: `**${timeString}** - ${playerIds.length} players available\n> ${playerNames.slice(0, 10).join(', ')}${playerNames.length > 10 ? ` +${playerNames.length - 10} more` : ''}`
                });
              }
            }
            
            // Add summary at the end
            analysisComponents.push(
              {
                type: 14 // Separator
              },
              {
                type: 10, // Text Display
                content: `*Total players with availability data: ${Object.keys(availability).length}*`
              }
            );
          }
          
          const analysisContainer = {
            type: 17, // Container
            accent_color: 0x00FF00, // Green accent for data
            components: analysisComponents
          };
          
          console.log(`‚úÖ SUCCESS: prod_availability_options - displayed analysis`);
          return {
            components: [analysisContainer],
            flags: (1 << 15) // IS_COMPONENTS_V2 (removed EPHEMERAL so all can see availability)
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_availability_clear') {
      // Clear user's availability
      return ButtonHandlerFactory.create({
        id: 'prod_availability_clear',
        handler: async (context) => {
          console.log(`üîç START: prod_availability_clear - user ${context.userId}`);
          
          const { guildId, userId } = context;
          const playerData = await loadPlayerData();
          
          if (!playerData[guildId]) {
            playerData[guildId] = {};
          }
          if (!playerData[guildId].availability) {
            playerData[guildId].availability = {};
          }
          
          // Clear user's availability
          delete playerData[guildId].availability[userId];
          await savePlayerData(playerData);
          
          const clearComponents = [
            {
              type: 10, // Text Display
              content: '## ‚úÖ Availability Cleared'
            },
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display
              content: 'Your availability has been successfully cleared.\n\nYou can set new availability by reacting to an availability message.'
            }
          ];
          
          const clearContainer = {
            type: 17, // Container
            accent_color: 0x00FF00, // Green accent for success
            components: clearComponents
          };
          
          console.log(`‚úÖ SUCCESS: prod_availability_clear - cleared for user ${userId}`);
          return {
            components: [clearContainer],
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL // IS_COMPONENTS_V2 + EPHEMERAL
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_pronoun_react') {
      // Use the enhanced pronoun reaction function with heart emojis
      try {
        const guildId = req.body.guild_id;
        const channelId = req.body.channel_id;
        const token = req.body.token;
        const applicationId = req.body.application_id;
        
        // Clean up any missing roles first
        const guild = await client.guilds.fetch(guildId);
        const { cleanupMissingRoles } = await import('./storage.js');
        const cleanupResult = await cleanupMissingRoles(guildId, guild);
        if (cleanupResult.cleaned > 0) {
          console.log(`üßπ CLEANUP: Cleaned up ${cleanupResult.cleaned} missing roles before creating pronoun reaction`);
        }

        // Load guild data (after potential cleanup)
        const playerData = await loadPlayerData();
        const guildData = { 
          ...playerData[guildId], 
          guildId // Add guildId for the function
        };
        
        // Call the enhanced function that includes heart emojis
        const response = await createPronounReactionMessage(guildData, channelId, token, client);
        
        // Send the response
        return res.send(response);

      } catch (error) {
        console.error('Error in prod_pronoun_react:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error creating pronoun reaction message',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'prod_ban_react') {
      // Post React for Ban honeypot message
      return ButtonHandlerFactory.create({
        id: 'prod_ban_react',
        requiresPermission: PermissionFlagsBits.BanMembers,
        permissionName: 'Ban Members',
        handler: async (context) => {
          const { guildId, channelId, client } = context;
          const guild = await client.guilds.fetch(guildId);

          // Verify bot has BanMembers permission
          const botMember = await guild.members.fetch(client.user.id);
          if (!botMember.permissions.has(PermissionFlagsBits.BanMembers)) {
            return {
              content: '‚ùå **CastBot needs the Ban Members permission** to use React for Bans.\n\nPlease update CastBot\'s role permissions and try again.',
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }

          // Idempotently ensure ban role exists and get its ID
          const { roleId: banRoleId, created } = await ensureBanRole(guild, guildId);
          console.log(`üéØ Ban role ${created ? 'created' : 'found'}: ${banRoleId}`);

          // Check if role ID changed from what existing mappings use ‚Äî update them
          const playerData = await loadPlayerData();
          const existingBanRoles = playerData[guildId]?.banRoleIds || {};
          const allBanRoleIds = Object.keys(existingBanRoles);
          if (allBanRoleIds.length > 1) {
            for (const oldId of allBanRoleIds) {
              if (oldId !== banRoleId) {
                await updateReactionMappingsForRole(guildId, oldId, banRoleId, 'isBan', client);
              }
            }
          }

          // Post public ban trap message asynchronously after response is sent
          setTimeout(async () => {
            try {
              const banContainer = {
                type: 17,
                accent_color: 0xe74c3c, // Bright red ‚Äî danger
                components: [
                  {
                    type: 10,
                    content: `## üéØ React for ·ó∑·ó©·ëéÍì¢\n\nThe following should not be used by real people ‚Äî this is intended to be clicked by ·ó∑OTÍì¢ who may spam to gain trusted access to the server. Clicking this will automatically ·ó∑·ó©·ëé you from the server.`
                  },
                  { type: 14 },
                  {
                    type: 10,
                    content: `üéØ ‚Äî ·ó∑·ó©·ëé`
                  }
                ]
              };

              const postResponse = await fetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
                method: 'POST',
                headers: {
                  Authorization: `Bot ${process.env.DISCORD_TOKEN}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  components: [banContainer],
                  flags: (1 << 15) // IS_COMPONENTS_V2
                })
              });
              const postedMessage = await postResponse.json();

              if (!postedMessage.id) {
                console.error('‚ùå Failed to post ban trap message:', postedMessage);
                return;
              }

              const messageId = postedMessage.id;
              console.log(`üéØ Ban trap message posted: ${messageId}`);

              // Add the üéØ reaction
              await fetch(
                `https://discord.com/api/v10/channels/${channelId}/messages/${messageId}/reactions/${encodeURIComponent('üéØ')}/@me`,
                {
                  method: 'PUT',
                  headers: { Authorization: `Bot ${process.env.DISCORD_TOKEN}` }
                }
              );

              // Store role-emoji mapping with isBan flag
              const roleMapping = { 'üéØ': banRoleId, isBan: true };
              await saveReactionMapping(guildId, messageId, roleMapping);
              if (!client.roleReactions) client.roleReactions = new Map();
              client.roleReactions.set(messageId, roleMapping);

              console.log(`‚úÖ Ban trap reaction setup complete for message ${messageId}`);
            } catch (error) {
              console.error('‚ùå Error posting ban trap message:', error);
            }
          }, 500);

          // Return ephemeral confirmation (ButtonHandlerFactory sends this)
          return {
            content: '‚úÖ React for Ban message posted below.',
            flags: InteractionResponseFlags.EPHEMERAL
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_view_timezones') {
      // Display all timezone roles with LEAN design
      return ButtonHandlerFactory.create({
        id: 'prod_view_timezones',
        updateMessage: true,  // Button click - update existing message
        handler: async (context) => {
          return await buildTimezonesViewMenu(context.guildId, context.client);
        }
      })(req, res, client);
    } else if (custom_id === 'prod_view_pronouns') {
      // Display all pronoun roles with LEAN design
      return ButtonHandlerFactory.create({
        id: 'prod_view_pronouns',
        updateMessage: true,  // Button click - update existing message
        handler: async (context) => {
          return await buildPronounsViewMenu(context.guildId, context.client);
        }
      })(req, res, client);
    } else if (custom_id === 'prod_view_tribes') {
      // Display all tribes organized by castlist
      return ButtonHandlerFactory.create({
        id: 'prod_view_tribes',
        updateMessage: true,  // Button click - update existing message
        handler: async (context) => {
          return await buildTribesViewMenu(context.guildId, context.client);
        }
      })(req, res, client);
    } else if (custom_id === 'prod_edit_timezones') {
      // Show role select menu for timezone editing with LEAN design
      return ButtonHandlerFactory.create({
        id: 'prod_edit_timezones',
        updateMessage: true,  // Button click - update existing message
        handler: async (context) => {
          return await buildTimezoneEditMenu(context.guildId);
        }
      })(req, res, client);
    } else if (custom_id === 'prod_edit_pronouns') {
      // Show role select menu for pronoun editing with LEAN design
      return ButtonHandlerFactory.create({
        id: 'prod_edit_pronouns',
        updateMessage: true,  // Button click - update existing message
        handler: async (context) => {
          const { guildId } = context;
          const pronounRoleIDs = await getGuildPronouns(guildId);

          // Use Discord.js RoleSelectMenuBuilder for better compatibility
          const roleSelect = new RoleSelectMenuBuilder()
            .setCustomId('prod_edit_pronouns_select')
            .setPlaceholder('Select roles to add/remove as pronoun roles')
            .setMinValues(0)
            .setMaxValues(25);

          // Set default values if any exist (limited to Discord's 25 role maximum)
          if (pronounRoleIDs && pronounRoleIDs.length > 0) {
            const limitedRoles = pronounRoleIDs.slice(0, 25);
            roleSelect.setDefaultRoles(limitedRoles);
          }

          const selectRow = new ActionRowBuilder().addComponents(roleSelect);

          // Navigation row
          const navRow = new ActionRowBuilder()
            .addComponents(
              new ButtonBuilder()
                .setCustomId('prod_manage_pronouns_timezones')
                .setLabel('‚Üê Reaction Roles')
                .setStyle(ButtonStyle.Secondary)
            );

          // Build LEAN container
          const containerComponents = [
            { type: 10, content: '## üíô Edit Pronoun Roles | Bulk Modify' },
            { type: 14 }, // Separator
            { type: 10, content: `> **\`üíô Role Selection\`**` },
            { type: 10, content: 'Select which roles should be pronoun roles. Currently selected roles are already ticked. Add or remove roles as needed.' },
            { type: 14 }, // Separator
            selectRow.toJSON(),
            { type: 14 }, // Separator before navigation
            navRow.toJSON()
          ];

          return {
            components: [{
              type: 17, // Container
              accent_color: 0xE91E63, // Pink - personal identity theme
              components: containerComponents
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_add_tribe') {
      // Step 1: Role selection for tribe - Using ComponentsV2 Container
      try {
        // Create ComponentsV2 container following LEAN Menu Design Standards
        const addTribeContainer = {
          type: 17, // Container (MANDATORY for ComponentsV2)
          accent_color: 0xE67E22, // Orange accent to match tribe management theme
          components: [
            {
              type: 10, // Text Display
              content: `## CastBot | Add Tribe to Castlist`
            },
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display
              content: `Please select the role corresponding to the tribe you want to add to the castlist.\n\nIf you have not yet created the tribe role, please do so from the Discord roles menu.\n\n‚ö†Ô∏è **Note:** You can add your tribes to the castlist before players have been assigned the tribes, however they'll appear blank if any spectator views the castlist.`
            },
            {
              type: 14 // Separator
            },
            {
              type: 1, // ActionRow
              components: [{
                type: 6, // Role Select (Type 6 per ComponentsV2.md)
                custom_id: 'prod_add_tribe_role_select',
                placeholder: 'Select the role of the tribe to add',
                min_values: 1,
                max_values: 1
              }]
            }
          ]
        };

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
            components: [addTribeContainer]
          }
        });
        
      } catch (error) {
        console.error('Error in prod_add_tribe:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error loading tribe addition interface.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'prod_clear_tribe') {
      // Show role select with existing tribes only
      try {
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        const playerData = await loadPlayerData();
        const tribes = playerData[guildId]?.tribes || {};
        
        if (Object.keys(tribes).length === 0) {
          // Create ComponentsV2 container for empty state
          const emptyContainer = {
            type: 17, // Container
            accent_color: 0xE67E22, // Orange accent
            components: [
              {
                type: 10, // Text Display
                content: `## CastBot | Clear Tribe`
              },
              {
                type: 14 // Separator
              },
              {
                type: 10, // Text Display
                content: `No tribes found to clear.\n\nAdd some tribes first using **Add Tribe**.`
              }
            ]
          };
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
              components: [emptyContainer]
            }
          });
        }
        
        // Create string select with existing tribe roles (showing castlist names)
        const existingTribeRoles = Object.keys(tribes);
        
        // Build options with role names and castlist info
        const options = [];
        for (const roleId of existingTribeRoles) {
          const role = guild.roles.cache.get(roleId);
          const tribeData = tribes[roleId];
          if (role) {
            const castlistName = tribeData.castlist || 'default';
            const emoji = tribeData.emoji ? `${tribeData.emoji} ` : '';
            options.push({
              label: `${emoji}${role.name}`,
              description: `Remove from castlist: ${castlistName}`,
              value: roleId,
              emoji: { name: 'üóëÔ∏è' }
            });
          }
        }
        
        // Use string select instead of role select for better UX
        const stringSelect = new StringSelectMenuBuilder()
          .setCustomId('prod_clear_tribe_select')
          .setPlaceholder('Select tribe to clear from castlist')
          .setMinValues(1)
          .setMaxValues(1)
          .addOptions(options.slice(0, 25)); // Discord limit

        // Create ComponentsV2 container following LEAN Menu Design Standards
        const clearTribeContainer = {
          type: 17, // Container (MANDATORY for ComponentsV2)
          accent_color: 0xE67E22, // Orange accent to match tribe management theme
          components: [
            {
              type: 10, // Text Display
              content: `## CastBot | Clear Tribe`
            },
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display
              content: `Select the tribe you want to remove from the castlist.\n\n‚ö†Ô∏è **Note:** This will remove it from CastBot but won't delete the Discord role.`
            },
            {
              type: 14 // Separator
            },
            {
              type: 1, // ActionRow
              components: [{
                type: 3, // String Select
                custom_id: 'prod_clear_tribe_select',
                placeholder: 'Select tribe to clear from castlist',
                min_values: 1,
                max_values: 1,
                options: options.slice(0, 25) // Discord limit
              }]
            }
          ]
        };

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
            components: [clearTribeContainer]
          }
        });
        
      } catch (error) {
        console.error('Error in prod_clear_tribe:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error loading tribe clearing interface.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'prod_create_emojis') {
      return ButtonHandlerFactory.create({
        id: 'prod_create_emojis',
        updateMessage: true,
        handler: async (context) => {
          const { guildId, client } = context;
          const guild = await client.guilds.fetch(guildId);

          // Get emoji counts and limits
          const emojis = await guild.emojis.fetch();
          const staticCount = emojis.filter(e => !e.animated).size;
          const animatedCount = emojis.filter(e => e.animated).size;
          const limits = { 0: 50, 1: 100, 2: 150, 3: 250 };
          const emojiLimit = limits[guild.premiumTier] || 50;

          // Check for selectable roles
          const roles = await guild.roles.fetch();
          const hasRoles = roles.some(role => role.id !== guild.id && !role.managed);

          if (!hasRoles) {
            return {
              components: [{
                type: 17, accent_color: 0xe74c3c,
                components: [
                  { type: 10, content: '## üòÄ Add/Remove Emojis' },
                  { type: 14 },
                  { type: 10, content: '‚ùå No selectable roles found in this server.' },
                  { type: 14 },
                  { type: 1, components: [{ type: 2, custom_id: 'castbot_tools', label: '‚Üê Tools', style: 2 }] }
                ]
              }]
            };
          }

          return {
            components: [{
              type: 17, accent_color: 0x7ED321,
              components: [
                { type: 10, content: '## üòÄ Add/Remove Emojis' },
                { type: 14 },
                { type: 10, content: `Select a role (tribe) to auto-create emojis from player avatars for rankings, fan favourite, etc.\n\n\`${staticCount}/${emojiLimit}\` static | \`${animatedCount}/${emojiLimit}\` animated\n\nüí° To remove CastBot-created emojis, select the same role again.` },
                { type: 14 },
                { type: 10, content: '> **`üé≠ Select Role`**' },
                {
                  type: 1,
                  components: [{
                    type: 6, // Role Select
                    custom_id: 'prod_emoji_role_select',
                    placeholder: 'Select a role to generate/clear emojis for'
                  }]
                },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: 'castbot_tools', label: '‚Üê Tools', style: 2 }] }
              ]
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('admin_set_pronouns_') || custom_id.startsWith('admin_set_timezone_') || custom_id.startsWith('admin_set_age_') || custom_id.startsWith('admin_manage_vanity_') || custom_id.startsWith('admin_set_attributes_')) {
      // üîò Convert to ButtonHandlerFactory
      return ButtonHandlerFactory.create({
        id: custom_id,
        updateMessage: true, // Update existing message
        handler: async (context) => {
          const playerData = await loadPlayerData();
          return await handlePlayerButtonClick(req, res, custom_id, playerData, context.client);
        }
      })(req, res, client);
    // Removed disabled legacy vanity handler
    // Removed disabled legacy timezone handler
    } else if ((custom_id.startsWith('admin_integrated_age') || custom_id.startsWith('player_integrated_age')) &&
               req.body.data.values?.[0] === 'age_custom') {
      // üîò Handle age_custom modal separately (modals cannot be deferred)
      const mode = custom_id.startsWith('player_integrated_') ? 'player' : 'admin';
      const targetPlayerId = mode === 'player' ?
        req.body.member?.user?.id || req.body.user?.id :
        custom_id.split('_')[3];

      const modal = new ModalBuilder()
        .setCustomId(mode === 'admin' ? `admin_age_modal_${targetPlayerId}` : 'player_age_modal')
        .setTitle('Set Player Age');

      const ageInput = new TextInputBuilder()
        .setCustomId('age')
        .setLabel('Enter your age')
        .setStyle(TextInputStyle.Short)
        .setRequired(true)
        .setMaxLength(10)
        .setPlaceholder("e.g. 25 or '30s'");

      const row = new ActionRowBuilder().addComponents(ageInput);
      modal.addComponents(row);

      return res.send({
        type: InteractionResponseType.MODAL,
        data: modal.toJSON()
      });

    } else if (custom_id.startsWith('admin_integrated_attributes_')) {
      // Handle attribute selection - opens modal to set value
      const targetPlayerId = custom_id.split('_')[3];
      const selectedAttrId = req.body.data.values?.[0];

      if (!selectedAttrId || selectedAttrId === 'none') {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå No attribute selected',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      const guildId = req.body.guild_id;
      const { getAttributeDefinitions, getPlayerAttribute } = await import('./safariManager.js');
      const attributes = await getAttributeDefinitions(guildId);
      const attr = attributes[selectedAttrId];

      if (!attr) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Attribute not found',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Get current value for placeholder
      let currentValue = attr.defaultMax || attr.defaultValue || 0;
      try {
        const playerAttr = await getPlayerAttribute(guildId, targetPlayerId, selectedAttrId);
        currentValue = playerAttr.current ?? currentValue;
      } catch (e) {
        // Use default
      }

      // Open modal to set attribute value
      const isResource = attr.category === 'resource';

      return res.send({
        type: InteractionResponseType.MODAL,
        data: {
          custom_id: `modal_admin_set_attr_${targetPlayerId}_${selectedAttrId}`,
          title: `Set ${attr.emoji} ${attr.name}`,
          components: [
            {
              type: 1, // ActionRow
              components: [{
                type: 4, // Text Input
                custom_id: 'attr_value',
                label: isResource ? 'Current Value' : 'Value',
                style: 1, // Short
                placeholder: `Current: ${currentValue}`,
                min_length: 1,
                max_length: 10,
                required: true
              }]
            },
            ...(isResource ? [{
              type: 1,
              components: [{
                type: 4,
                custom_id: 'attr_max',
                label: 'Max Value (optional)',
                style: 1,
                placeholder: `Current max: ${attr.defaultMax || 100}`,
                min_length: 0,
                max_length: 10,
                required: false
              }]
            }] : [])
          ]
        }
      });

    } else if (custom_id.startsWith('admin_integrated_age') || custom_id.startsWith('player_integrated_age') ||
               custom_id.startsWith('admin_integrated_pronouns') || custom_id.startsWith('player_integrated_pronouns') ||
               custom_id.startsWith('admin_integrated_timezone') || custom_id.startsWith('player_integrated_timezone') ||
               custom_id.startsWith('admin_integrated_vanity')) {
      // üîò Convert to ButtonHandlerFactory with deferred response
      return ButtonHandlerFactory.create({
        id: custom_id,
        updateMessage: true, // Update existing message (like admin_player_select_update)
        handler: async (context) => {
          const { guildId, userId, member, client } = context;
          const guild = await client.guilds.fetch(guildId);
          const selectedValues = context.values || []; // ButtonHandlerFactory provides values directly, not context.data.values

          // Parse action type and target player
          let actionType, targetPlayerId, mode;

          if (custom_id.startsWith('player_integrated_')) {
            mode = 'player';
            targetPlayerId = userId;
            actionType = custom_id.replace('player_integrated_', '').split('_')[0];
          } else {
            mode = 'admin';
            const parts = custom_id.split('_');
            actionType = parts[2]; // pronouns, timezone, age, or vanity
            targetPlayerId = parts[3];
          }

          const targetMember = await guild.members.fetch(targetPlayerId);

          // Handle the selection based on type
          if (actionType === 'pronouns') {
            try {
              // Remove all current pronoun roles
              const pronounRoleIDs = await getGuildPronouns(guildId);
              const currentPronounRoles = targetMember.roles.cache.filter(role =>
                pronounRoleIDs.includes(role.id)
              );
              if (currentPronounRoles.size > 0) {
                await targetMember.roles.remove(currentPronounRoles.map(role => role.id));
              }
              // Add new roles
              if (selectedValues.length > 0) {
                await targetMember.roles.add(selectedValues);
              }
            } catch (error) {
              console.error('‚ùå Pronoun role assignment failed:', error);
              if (error.code === 50013) {
                // Discord permission error - send non-ephemeral message
                return {
                  content: '‚ö†Ô∏è **Permission Error**: Unable to assign pronoun roles. Please advise the production team to move the CastBot role to the top of the Discord hierarchy, above pronoun roles.',
                  flags: 0 // Non-ephemeral message
                };
              } else {
                // Other errors - send ephemeral message
                return {
                  content: '‚ùå Failed to update pronoun roles. Please try again.',
                  flags: InteractionResponseFlags.EPHEMERAL
                };
              }
            }
          } else if (actionType === 'timezone') {
            // Remove current timezone role
            const timezones = await getGuildTimezones(guildId);
            const timezoneRoleIds = Object.keys(timezones);
            const currentTimezoneRole = targetMember.roles.cache.find(role =>
              timezoneRoleIds.includes(role.id)
            );
            if (currentTimezoneRole) {
              try {
                await targetMember.roles.remove(currentTimezoneRole.id);
              } catch (error) {
                console.warn(`üö® Could not remove timezone role ${currentTimezoneRole.id}:`, error.message);
              }
            }
            // Add new timezone
            if (selectedValues.length > 0) {
              try {
                await targetMember.roles.add(selectedValues[0]);
              } catch (error) {
                console.error(`‚ùå Failed to add timezone role ${selectedValues[0]}:`, error.message);
                return {
                  content: '‚ùå Failed to update timezone. The selected role may no longer exist.',
                  flags: InteractionResponseFlags.EPHEMERAL
                };
              }
            }
          } else if (actionType === 'age') {
            // Handle age selection (modal case handled separately above)
            if (selectedValues.length > 0) {
              const ageValue = selectedValues[0];
              // age_custom is handled by separate modal handler above
              // Only process direct age selections here
              const age = ageValue.replace('age_', '');
              await updatePlayer(guildId, targetPlayerId, { age });
            }
          } else if (actionType === 'vanity') {
            // Handle vanity roles (admin only)
            // Note: Vanity roles are display-only metadata for castlists, not actual Discord role assignments
            const playerData = await loadPlayerData();
            if (!playerData[guildId].players[targetPlayerId]) {
              playerData[guildId].players[targetPlayerId] = {};
            }

            // Update vanity roles in playerData only (no Discord role sync)
            playerData[guildId].players[targetPlayerId].vanityRoles = selectedValues;
            await savePlayerData(playerData);
          }

          // Rebuild the interface with the same active button
          const freshPlayerData = await loadPlayerData();
          const activeButton = actionType === 'vanity' ? 'vanity' : actionType;

          // Check if this is an application channel context for player mode
          let isApplicationChannel = false;
          let customTitle = '';
          let hideBottomButtons = false;

          if (mode === 'player') {
            const channelId = context.channelId;
            isApplicationChannel = freshPlayerData[guildId]?.applications &&
              Object.values(freshPlayerData[guildId].applications).some(app => app.channelId === channelId);

            if (isApplicationChannel) {
              customTitle = 'Set your age, pronouns and timezone.';
              hideBottomButtons = true;
            } else {
              customTitle = 'CastBot | Player Menu';
            }
          }

          const updatedUI = await createPlayerManagementUI({
            mode: mode === 'admin' ? PlayerManagementMode.ADMIN : PlayerManagementMode.PLAYER,
            targetMember,
            playerData: freshPlayerData,
            guildId,
            userId,
            showUserSelect: mode === 'admin',
            showVanityRoles: mode === 'admin',
            title: mode === 'admin' ?
              `Player Management | ${targetMember.displayName}` :
              customTitle,
            activeButton,
            hideBottomButtons: mode === 'player' ? hideBottomButtons : false,
            isApplicationContext: mode === 'player' ? isApplicationChannel : false,
            client
          });

          // Return UI for UPDATE_MESSAGE (ButtonHandlerFactory handles the response type)
          return updatedUI;
        }
      })(req, res, client);
    // Legacy handler removed - now using ButtonHandlerFactory above
    } else if (false && custom_id.startsWith('admin_integrated_OLD')) {
      // üîç DEBUG: Log which integrated handler is being used
      console.log('üîç DEBUG: Integrated select handler triggered for custom_id:', custom_id);
      // Handle ALL integrated select changes with auto-refresh
      try {
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        const selectedValues = data.values || [];
        
        // Parse action type and target player
        let actionType, targetPlayerId, mode;
        
        if (custom_id.startsWith('player_integrated_')) {
          mode = 'player';
          targetPlayerId = req.body.member.user.id;
          actionType = custom_id.replace('player_integrated_', '').split('_')[0];
        } else {
          mode = 'admin';
          const parts = custom_id.split('_');
          actionType = parts[2]; // pronouns, timezone, age, or vanity
          targetPlayerId = parts[3];
        }

        const targetMember = await guild.members.fetch(targetPlayerId);

        // Handle the selection based on type
        if (actionType === 'pronouns') {
          try {
            // Remove all current pronoun roles
            const pronounRoleIDs = await getGuildPronouns(guildId);
            const currentPronounRoles = targetMember.roles.cache.filter(role => 
              pronounRoleIDs.includes(role.id)
            );
            if (currentPronounRoles.size > 0) {
              await targetMember.roles.remove(currentPronounRoles.map(role => role.id));
            }
            // Add new roles
            if (selectedValues.length > 0) {
              await targetMember.roles.add(selectedValues);
            }
          } catch (error) {
            console.error('‚ùå Pronoun role assignment failed:', error);
            if (error.code === 50013) {
              // Discord permission error - send non-ephemeral message
              return res.send({
                type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                data: {
                  content: '‚ö†Ô∏è **Permission Error**: Unable to assign pronoun roles. Please advise the production team to move the CastBot role to the top of the Discord hierarchy, above pronoun roles.',
                  flags: 0 // Non-ephemeral message
                }
              });
            } else {
              // Other errors - send ephemeral message
              return res.send({
                type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                data: {
                  content: '‚ùå Failed to update pronoun roles. Please try again.',
                  flags: InteractionResponseFlags.EPHEMERAL
                }
              });
            }
          }
        } else if (actionType === 'timezone') {
          // Remove current timezone role
          const timezones = await getGuildTimezones(guildId);
          const timezoneRoleIds = Object.keys(timezones);
          const currentTimezoneRole = targetMember.roles.cache.find(role => 
            timezoneRoleIds.includes(role.id)
          );
          if (currentTimezoneRole) {
            try {
              await targetMember.roles.remove(currentTimezoneRole.id);
            } catch (error) {
              console.warn(`üö® Could not remove timezone role ${currentTimezoneRole.id}:`, error.message);
            }
          }
          // Add new timezone
          if (selectedValues.length > 0) {
            try {
              await targetMember.roles.add(selectedValues[0]);
            } catch (error) {
              console.error(`‚ùå Failed to add timezone role ${selectedValues[0]}:`, error.message);
              return res.send({
                type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                data: {
                  content: '‚ùå Failed to update timezone. The selected role may no longer exist.',
                  flags: InteractionResponseFlags.EPHEMERAL
                }
              });
            }
          }
        } else if (actionType === 'age') {
          // Handle age selection
          if (selectedValues.length > 0) {
            const ageValue = selectedValues[0];
            if (ageValue === 'age_custom') {
              // Show modal for custom age
              const modal = new ModalBuilder()
                .setCustomId(mode === 'admin' ? `admin_age_modal_${targetPlayerId}` : 'player_age_modal')
                .setTitle('Set Player Age');

              const ageInput = new TextInputBuilder()
                .setCustomId('age')
                .setLabel('Enter your age')
                .setStyle(TextInputStyle.Short)
                .setRequired(true)
                .setMaxLength(10)
                .setPlaceholder("e.g. 25 or '30s'");

              const row = new ActionRowBuilder().addComponents(ageInput);
              modal.addComponents(row);

              return res.send({
                type: InteractionResponseType.MODAL,
                data: modal.toJSON()
              });
            } else {
              // Direct age selection
              const age = ageValue.replace('age_', '');
              await updatePlayer(guildId, targetPlayerId, { age });
            }
          }
        } else if (actionType === 'vanity') {
          // Handle vanity roles (admin only)
          const playerData = await loadPlayerData();
          if (!playerData[guildId].players[targetPlayerId]) {
            playerData[guildId].players[targetPlayerId] = {};
          }
          
          // Remove old vanity roles
          const oldVanityRoles = playerData[guildId].players[targetPlayerId].vanityRoles || [];
          if (oldVanityRoles.length > 0) {
            await targetMember.roles.remove(oldVanityRoles).catch(console.error);
          }
          
          // Save and add new vanity roles
          playerData[guildId].players[targetPlayerId].vanityRoles = selectedValues;
          await savePlayerData(playerData);
          
          if (selectedValues.length > 0) {
            await targetMember.roles.add(selectedValues);
          }
        }

        // Rebuild the interface with the same active button
        const freshPlayerData = await loadPlayerData();
        const activeButton = actionType === 'vanity' ? 'vanity' : actionType;
        
        // Check if this is an application channel context for player mode
        let isApplicationChannel = false;
        let customTitle = '';
        let hideBottomButtons = false;
        
        if (mode === 'player') {
          const channelId = req.body.channel_id;
          isApplicationChannel = freshPlayerData[guildId]?.applications && 
            Object.values(freshPlayerData[guildId].applications).some(app => app.channelId === channelId);
          
          if (isApplicationChannel) {
            customTitle = 'Set your age, pronouns and timezone.';
            hideBottomButtons = true;
          } else {
            customTitle = 'CastBot | Player Menu';
          }
        }
        
        const updatedUI = await createPlayerManagementUI({
          mode: mode === 'admin' ? PlayerManagementMode.ADMIN : PlayerManagementMode.PLAYER,
          targetMember,
          playerData: freshPlayerData,
          guildId,
          userId: req.body.member.user.id,
          showUserSelect: mode === 'admin',
          showVanityRoles: mode === 'admin',
          title: mode === 'admin' ? 
            `Player Management | ${targetMember.displayName}` : 
            customTitle,
          activeButton,
          hideBottomButtons: mode === 'player' ? hideBottomButtons : false,
          isApplicationContext: mode === 'player' ? isApplicationChannel : false,
          client
        });

        // Remove ephemeral flag for update
        updatedUI.flags = (1 << 15); // Only IS_COMPONENTS_V2

        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: updatedUI
        });

      } catch (error) {
        console.error('Error handling integrated select:', error);
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            content: 'Error updating selection.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    // Removed disabled legacy age handler
    } else if (false) { // DISABLED
      // Admin age management
      try {
        const guildId = req.body.guild_id;
        const adminUserId = req.body.member.user.id;
        const targetPlayerId = custom_id.split('_')[3]; // Extract player ID from admin_set_age_${playerId}
        
        const guild = await client.guilds.fetch(guildId);
        
        // Check admin permissions
        const adminMember = await guild.members.fetch(adminUserId);
        if (!adminMember.permissions.has(PermissionFlagsBits.ManageRoles) && 
            !adminMember.permissions.has(PermissionFlagsBits.ManageChannels) && 
            !adminMember.permissions.has(PermissionFlagsBits.ManageGuild)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå You need Manage Roles, Manage Channels, or Manage Server permissions to use this feature.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Get target player
        let targetMember;
        try {
          targetMember = await guild.members.fetch(targetPlayerId);
        } catch (error) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Unable to find the target player in this server.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Get current age if exists
        const currentAge = getPlayer(guildId, targetPlayerId)?.age || '';

        // Create age input modal
        const ageModal = new ModalBuilder()
          .setCustomId(`admin_age_modal_${targetPlayerId}`)
          .setTitle(`Set Age for ${targetMember.displayName}`);

        const ageInput = new TextInputBuilder()
          .setCustomId('age_input')
          .setLabel('Age')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('Enter age (numbers only)')
          .setRequired(false)
          .setMaxLength(3);

        if (currentAge) {
          ageInput.setValue(currentAge);
        }

        const ageRow = new ActionRowBuilder().addComponents(ageInput);
        ageModal.addComponents(ageRow);

        return res.send({
          type: InteractionResponseType.MODAL,
          data: ageModal
        });

      } catch (error) {
        console.error('Error handling admin_set_age button:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error creating age input',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    // Removed disabled legacy vanity handler  
    } else if (false) { // DISABLED
      // Admin vanity roles management
      try {
        const guildId = req.body.guild_id;
        const adminUserId = req.body.member.user.id;
        const targetPlayerId = custom_id.split('_')[3]; // Extract player ID from admin_manage_vanity_${playerId}
        
        const guild = await client.guilds.fetch(guildId);
        
        // Check admin permissions
        const adminMember = await guild.members.fetch(adminUserId);
        if (!adminMember.permissions.has(PermissionFlagsBits.ManageRoles) && 
            !adminMember.permissions.has(PermissionFlagsBits.ManageChannels) && 
            !adminMember.permissions.has(PermissionFlagsBits.ManageGuild)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå You need Manage Roles, Manage Channels, or Manage Server permissions to use this feature.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Get target player
        let targetMember;
        try {
          targetMember = await guild.members.fetch(targetPlayerId);
        } catch (error) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Unable to find the target player in this server.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Get current vanity roles
        const playerData = await loadPlayerData();
        const currentVanityRoles = playerData[guildId]?.players?.[targetPlayerId]?.vanityRoles || [];

        // Create role select menu
        const roleSelect = new RoleSelectMenuBuilder()
          .setCustomId(`admin_select_vanity_${targetPlayerId}`)
          .setPlaceholder('Special roles to appear under the player in the castlist')
          .setMinValues(0)
          .setMaxValues(25);

        if (currentVanityRoles.length > 0) {
          const limitedRoles = currentVanityRoles.slice(0, 25);
          roleSelect.setDefaultRoles(limitedRoles);
        }

        const selectRow = new ActionRowBuilder().addComponents(roleSelect);

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `Select vanity roles for **${targetMember.displayName}**:\n*These roles will appear under their name in the castlist.*`,
            components: [selectRow],
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });

      } catch (error) {
        console.error('Error handling admin_manage_vanity button:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error creating vanity role selection',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'player_set_pronouns') {
      // Use new modular handler
      const playerData = await loadPlayerData();
      return await handlePlayerButtonClick(req, res, custom_id, playerData, client);
    } else if (custom_id === 'player_set_timezone') {
      // Use new modular handler
      const playerData = await loadPlayerData();
      return await handlePlayerButtonClick(req, res, custom_id, playerData, client);
    } else if (custom_id === 'player_set_age') {
      // Use new modular handler
      const playerData = await loadPlayerData();
      return await handlePlayerButtonClick(req, res, custom_id, playerData, client);
    } else if (custom_id === 'player_menu') {
      // Show player management menu
      try {
        const guildId = req.body.guild_id;
        const channelId = req.body.channel_id;
        const userId = req.body.member.user.id;
        const guild = await client.guilds.fetch(guildId);
        const member = await guild.members.fetch(userId);
        const playerData = await loadPlayerData();
        
        // Check if this is an application channel context
        const isApplicationChannel = playerData[guildId]?.applications && 
          Object.values(playerData[guildId].applications).some(app => app.channelId === channelId);
        
        // Use custom title and hide bottom buttons if in application context
        const title = isApplicationChannel ? 'Set your age, pronouns and timezone.' : 'CastBot | Player Menu';
        const hideBottomButtons = isApplicationChannel;
        
        console.log(`üîç Player Menu Context: Channel ${channelId}, Application Channel: ${isApplicationChannel}, Title: "${title}"`);
        
        // Create player management UI
        const playerMenuUI = await createPlayerManagementUI({
          mode: PlayerManagementMode.PLAYER,
          targetMember: member,
          playerData,
          guildId,
          userId,
          showUserSelect: false,
          showVanityRoles: false,
          title: title,
          activeButton: null,
          hideBottomButtons: hideBottomButtons,
          isApplicationContext: isApplicationChannel,
          client
        });
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: playerMenuUI
        });
      } catch (error) {
        console.error('Error showing player menu:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error loading player menu.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('app_continue_')) {
      // Handle "Move on to main questions" button click in application channels
      try {
        // Extract guildId and userId from custom_id: app_continue_{guildId}_{userId}
        const parts = custom_id.split('_');
        const guildId = parts[2];
        const userId = parts[3];
        const channelId = req.body.channel_id;
        
        console.log(`üîç App Continue: Guild ${guildId}, User ${userId}, Channel ${channelId}`);
        
        // Load player data to find the application and its configId
        const playerData = await loadPlayerData();
        const application = playerData[guildId]?.applications?.[channelId];
        
        if (!application) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Application data not found for this channel.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const configId = application.configId;
        console.log(`üîç Found configId: ${configId}`);
        
        // Get the application configuration to retrieve questions
        const config = await getApplicationConfig(guildId, configId);
        
        if (!config) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Application configuration not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Check if there are questions configured
        if (!config.questions || config.questions.length === 0) {
          // Fall back to legacy welcome message if no questions
          const welcomeTitle = config.welcomeTitle || 'Next Steps';
          const welcomeDescription = config.welcomeDescription || 'No additional instructions configured - ask your hosts what to do next!';
          
          const customWelcomeContainer = {
            type: 17, // Container
            accent_color: 0x3498db, // Blue color
            components: [
              {
                type: 10, // Text Display
                content: `## ${welcomeTitle}\n\n${welcomeDescription}`
              }
            ]
          };
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              flags: (1 << 15), // IS_COMPONENTS_V2
              components: [customWelcomeContainer]
            }
          });
        }
        
        // Initialize progress tracker (backwards compatible)
        if (!application.currentQuestion) {
          application.currentQuestion = 0; // Initialize for existing applications
        }
        
        // Save updated progress
        await savePlayerData(playerData);
        
        // Show first question
        return showApplicationQuestion(res, config, channelId, 0);
        
      } catch (error) {
        console.error('Error in app_continue handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error loading next steps. Please contact an admin.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('app_next_question_')) {
      // Handle next question navigation
      try {
        // Extract channelId and index: app_next_question_{channelId}_{index}
        const prefix = 'app_next_question_';
        const remaining = custom_id.replace(prefix, '');
        const lastUnderscoreIndex = remaining.lastIndexOf('_');
        const channelId = remaining.substring(0, lastUnderscoreIndex);
        const currentIndex = parseInt(remaining.substring(lastUnderscoreIndex + 1));
        const nextIndex = currentIndex + 1;
        const guildId = req.body.guild_id;
        
        console.log(`üîç Next Question: Channel ${channelId}, Current: ${currentIndex}, Next: ${nextIndex}`);
        
        // Load player data to find the application and its configId
        const playerData = await loadPlayerData();
        const application = playerData[guildId]?.applications?.[channelId];
        
        if (!application) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Application data not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const config = await getApplicationConfig(guildId, application.configId);
        
        console.log(`üîç COMPLETION CHECK: config exists=${!!config}, questions exist=${!!config?.questions}, questions length=${config?.questions?.length}, nextIndex=${nextIndex}, should complete=${nextIndex >= (config?.questions?.length || 0)}`);
        
        if (!config || !config.questions || nextIndex >= config.questions.length) {
          // No more questions - application is complete
          console.log(`‚úÖ APPLICATION COMPLETE: No more questions to show`);
          // Simply return success - the last question handles completion
          return res.send({
            type: InteractionResponseType.UPDATE_MESSAGE,
            data: {
              content: '', // Clear the message since we're done
              components: [] // Remove all components
            }
          });
        }
        
        // Check if we're on the second-to-last question clicking to the last
        const isGoingToLastQuestion = nextIndex === config.questions.length - 1;
        
        // Update channel name when going to the last question
        if (isGoingToLastQuestion) {
          try {
            const channel = await client.channels.fetch(channelId);
            let currentName = channel.name;
            
            // Remove document emoji if it exists
            currentName = currentName.replace(/^üìù/, '');
            
            // Only update if it doesn't already have a checkmark
            if (!currentName.startsWith('‚òëÔ∏è') && !currentName.startsWith('‚úÖ')) {
              await channel.setName(`‚òëÔ∏è${currentName}`);
              console.log(`üìù Updated channel name to: ‚òëÔ∏è${currentName}`);
            }
          } catch (channelError) {
            console.error('Error updating channel name:', channelError);
          }
        }
        
        // Update progress tracker (backwards compatible)
        if (!application.currentQuestion) {
          application.currentQuestion = 0; // Initialize for existing applications
        }
        application.currentQuestion = nextIndex;
        
        // Save updated progress
        await savePlayerData(playerData);
        
        // Show next question
        return showApplicationQuestion(res, config, channelId, nextIndex);
        
      } catch (error) {
        console.error('‚ùå CRITICAL ERROR in app_next_question handler:', error);
        console.error('‚ùå Error stack:', error.stack);
        console.error('‚ùå Channel ID:', channelId);
        console.error('‚ùå Current Index:', currentIndex);
        console.error('‚ùå Next Index:', nextIndex);
        console.error('‚ùå Application data:', application);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error loading next question. Please contact an admin.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'app_withdraw') {
      // Handle application withdrawal
      try {
        const channelId = req.body.channel_id;
        const guildId = req.body.guild_id;
        const messageId = req.body.message.id;
        const userId = req.body.member.user.id;
        
        console.log(`‚ùå Application withdrawal requested for channel ${channelId}`);
        
        // Update channel name to show withdrawal
        try {
          const channel = await client.channels.fetch(channelId);
          let currentName = channel.name;
          
          // Remove ALL existing prefixes if they exist
          currentName = currentName.replace(/^[üìù‚òëÔ∏è‚ùå]+/, '');
          
          // Add withdrawal prefix
          await channel.setName(`‚ùå${currentName}`);
          console.log(`üìù Updated channel name to: ‚ùå${currentName}`);
          
          // Get application config to include production role
          const playerData = await loadPlayerData();
          const applications = playerData[guildId]?.applications || {};
          const appData = Object.values(applications).find(app => app.channelId === channelId);
          let config = null;
          if (appData?.configId) {
            config = await getApplicationConfig(guildId, appData.configId);
          }
          
          // Update the original message with new button states
          const welcomeContainer = {
            type: 17, // Container
            accent_color: 0x3498db, // Blue color (#3498db)
            components: [
              {
                type: 10, // Text Display
                content: `## üöÄ Get Started with Your Application\n\nWelcome <@${userId}>! This is your private application channel.\n\nOnly you and the ${config?.productionRole ? `production team (<@&${config.productionRole}>)` : 'admin team'} can see this channel.\n\nTo get your application started, please set up your basic information using the button above:\n\n‚Ä¢ **Pronouns** - Let us know your preferred pronouns\n‚Ä¢ **Timezone** - Help other players understand your availability\n‚Ä¢ **Age** - Set how old you are\n\nClick the button above to get started!`
              },
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    custom_id: 'app_reapply',
                    label: 'Re-apply',
                    style: 1, // Primary
                    emoji: { name: 'üîÑ' }
                  },
                  {
                    type: 2, // Button
                    custom_id: 'app_withdraw',
                    label: 'Withdraw your application',
                    style: 2, // Secondary (grey)
                    emoji: { name: '‚ùå' },
                    disabled: true // Disable since already withdrawn
                  }
                ]
              },
              {
                type: 10, // Text Display
                content: `-# You can update this information from any channel at any time by typing \\\`/menu\\\``
              }
            ]
          };
          
          // Update the original message
          await fetch(`https://discord.com/api/v10/channels/${channelId}/messages/${messageId}`, {
            method: 'PATCH',
            headers: {
              'Authorization': `Bot ${process.env.DISCORD_TOKEN}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              flags: (1 << 15), // IS_COMPONENTS_V2
              components: [welcomeContainer]
            })
          });
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå **Application Withdrawn**\n\nYour application has been withdrawn. If you change your mind, you can re-apply using the button above.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        } catch (channelError) {
          console.error('Error updating channel name for withdrawal:', channelError);
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error withdrawing application. Please contact an admin.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
      } catch (error) {
        console.error('‚ùå ERROR in app_withdraw handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error withdrawing application. Please contact an admin.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'app_reapply') {
      // Handle application re-apply
      try {
        const channelId = req.body.channel_id;
        const guildId = req.body.guild_id;
        const messageId = req.body.message.id;
        const userId = req.body.member.user.id;
        
        console.log(`üîÑ Application re-apply requested for channel ${channelId}`);
        
        // Update channel name to restore document prefix
        try {
          const channel = await client.channels.fetch(channelId);
          let currentName = channel.name;
          
          // Remove ALL existing prefixes if they exist
          currentName = currentName.replace(/^[üìù‚òëÔ∏è‚ùå]+/, '');
          
          // Add document prefix
          await channel.setName(`üìù${currentName}`);
          console.log(`üìù Updated channel name to: üìù${currentName}`);
          
          // Get application config to include production role
          const playerData = await loadPlayerData();
          const applications = playerData[guildId]?.applications || {};
          const appData = Object.values(applications).find(app => app.channelId === channelId);
          let config = null;
          if (appData?.configId) {
            config = await getApplicationConfig(guildId, appData.configId);
          }
          
          // Update the original message with new button states
          const welcomeContainer = {
            type: 17, // Container
            accent_color: 0x3498db, // Blue color (#3498db)
            components: [
              {
                type: 10, // Text Display
                content: `## üöÄ Get Started with Your Application\n\nWelcome <@${userId}>! This is your private application channel.\n\nOnly you and the ${config?.productionRole ? `production team (<@&${config.productionRole}>)` : 'admin team'} can see this channel.\n\nTo get your application started, please set up your basic information using the button above:\n\n‚Ä¢ **Pronouns** - Let us know your preferred pronouns\n‚Ä¢ **Timezone** - Help other players understand your availability\n‚Ä¢ **Age** - Set how old you are\n\nClick the button above to get started!`
              },
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    custom_id: 'player_menu',
                    label: 'Start your application',
                    style: 1, // Primary
                    emoji: { name: 'üöÄ' }
                  },
                  {
                    type: 2, // Button
                    custom_id: 'app_withdraw',
                    label: 'Withdraw your application',
                    style: 2, // Secondary (grey)
                    emoji: { name: '‚ùå' },
                    disabled: false // Enable since re-applied
                  }
                ]
              },
              {
                type: 10, // Text Display
                content: `-# You can update this information from any channel at any time by typing \\\`/menu\\\``
              }
            ]
          };
          
          // Update the original message
          await fetch(`https://discord.com/api/v10/channels/${channelId}/messages/${messageId}`, {
            method: 'PATCH',
            headers: {
              'Authorization': `Bot ${process.env.DISCORD_TOKEN}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              flags: (1 << 15), // IS_COMPONENTS_V2
              components: [welcomeContainer]
            })
          });
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'üîÑ **Application Reactivated**\n\nYour application has been reactivated. You can now continue with your application process.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        } catch (channelError) {
          console.error('Error updating channel name for re-apply:', channelError);
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error reactivating application. Please contact an admin.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
      } catch (error) {
        console.error('‚ùå ERROR in app_reapply handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error reactivating application. Please contact an admin.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'player_menu_test') {
      // TEST HANDLER: Proof of concept for new parameters (custom title + hidden bottom buttons)
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member.user.id;
        const guild = await client.guilds.fetch(guildId);
        const member = await guild.members.fetch(userId);
        const playerData = await loadPlayerData();
        
        console.log(`üß™ TEST: Testing new createPlayerManagementUI parameters for user ${userId}`);
        
        // Create player management UI with TEST PARAMETERS
        const testMenuUI = await createPlayerManagementUI({
          mode: PlayerManagementMode.PLAYER,
          targetMember: member,
          playerData,
          guildId,
          userId,
          showUserSelect: false,
          showVanityRoles: false,
          title: 'üß™ TEST MODE | Custom Title Demo', // CUSTOM TITLE
          activeButton: null,
          hideBottomButtons: true, // HIDE BOTTOM BUTTONS
          client
        });
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: testMenuUI
        });
      } catch (error) {
        console.error('Error in player_menu_test handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Test handler error. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'select_pronouns') {
      // Handle pronoun role selection
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member.user.id;
        const userName = req.body.member.nick || req.body.member.user.username;
        const selectedRoleIds = data.values || [];

        const guild = await client.guilds.fetch(guildId);
        const member = await guild.members.fetch(userId);

        // Check permissions for all selected roles before making any changes
        for (const roleId of selectedRoleIds) {
          const permissionCheck = await checkRoleHierarchyPermission(guild, roleId, client);
          if (!permissionCheck.allowed) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå ${permissionCheck.reason}`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
        }

        // Get all configured pronoun roles for this guild
        const pronounRoleIDs = await getGuildPronouns(guildId);
        
        // Remove all existing pronoun roles first
        const currentPronounRoles = member.roles.cache.filter(role => 
          pronounRoleIDs.includes(role.id)
        );
        
        try {
          if (currentPronounRoles.size > 0) {
            await member.roles.remove(currentPronounRoles.map(role => role.id));
          }

          // Add new selected roles
          if (selectedRoleIds.length > 0) {
            await member.roles.add(selectedRoleIds);
            
            // Get role names for confirmation message
            const selectedRoles = await Promise.all(
              selectedRoleIds.map(id => guild.roles.fetch(id))
            );
            const roleNames = selectedRoles.filter(role => role).map(role => role.name);
            
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `${userName} has set their pronouns to: ${roleNames.join(', ')}`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          } else {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `${userName} has removed all pronoun roles`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
        } catch (error) {
          console.error('‚ùå Pronoun role assignment failed in select_pronouns:', error);
          if (error.code === 50013) {
            // Discord permission error - send non-ephemeral message
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ö†Ô∏è **Permission Error**: Unable to assign pronoun roles. Please advise the production team to move the CastBot role to the top of the Discord hierarchy, above pronoun roles.',
                flags: 0 // Non-ephemeral message
              }
            });
          } else {
            // Other errors - send ephemeral message
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Failed to update pronoun roles. Please try again.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
        }

      } catch (error) {
        console.error('Error handling pronoun selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error setting pronoun roles.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'select_timezone') {
      // Handle timezone role selection
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member.user.id;
        const userName = req.body.member.nick || req.body.member.user.username;
        const selectedRoleIds = data.values || [];

        const guild = await client.guilds.fetch(guildId);
        const member = await guild.members.fetch(userId);

        // Check permissions for selected role before making any changes
        if (selectedRoleIds.length > 0) {
          const selectedRoleId = selectedRoleIds[0]; // Only take the first one
          const permissionCheck = await checkRoleHierarchyPermission(guild, selectedRoleId, client);
          if (!permissionCheck.allowed) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå ${permissionCheck.reason}`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
        }

        // Get all configured timezone roles for this guild
        const timezones = await getGuildTimezones(guildId);
        const timezoneRoleIds = Object.keys(timezones);
        
        // Remove all existing timezone roles first
        const currentTimezoneRoles = member.roles.cache.filter(role => 
          timezoneRoleIds.includes(role.id)
        );
        
        if (currentTimezoneRoles.size > 0) {
          await member.roles.remove(currentTimezoneRoles.map(role => role.id));
        }

        // Add new selected role (only one timezone allowed)
        if (selectedRoleIds.length > 0) {
          const selectedRoleId = selectedRoleIds[0]; // Only take the first one
          await member.roles.add(selectedRoleId);
          
          // Get role name and offset for confirmation message
          const selectedRole = await guild.roles.fetch(selectedRoleId);
          const timezoneData = timezones[selectedRoleId];
          const offset = timezoneData ? timezoneData.offset : 'Unknown';
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `${userName} has set their timezone to: ${selectedRole.name} (UTC${offset >= 0 ? '+' : ''}${offset})`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        } else {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `${userName} has removed their timezone role`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

      } catch (error) {
        console.error('Error handling timezone selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error setting timezone role.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('admin_select_pronouns_')) {
      // Handle admin pronoun role selection
      try {
        const guildId = req.body.guild_id;
        const adminUserId = req.body.member.user.id;
        const targetPlayerId = custom_id.split('_')[3]; // Extract player ID from admin_select_pronouns_${playerId}
        const selectedRoleIds = data.values || [];

        const guild = await client.guilds.fetch(guildId);
        const targetMember = await guild.members.fetch(targetPlayerId);
        const adminMember = await guild.members.fetch(adminUserId);

        // Check admin permissions
        if (!adminMember.permissions.has(PermissionFlagsBits.ManageRoles) && 
            !adminMember.permissions.has(PermissionFlagsBits.ManageChannels) && 
            !adminMember.permissions.has(PermissionFlagsBits.ManageGuild)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå You need Manage Roles, Manage Channels, or Manage Server permissions to use this feature.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Check permissions for all selected roles before making any changes
        for (const roleId of selectedRoleIds) {
          const permissionCheck = await checkRoleHierarchyPermission(guild, roleId, client);
          if (!permissionCheck.allowed) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå ${permissionCheck.reason}`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
        }

        // Get all configured pronoun roles for this guild
        const pronounRoleIDs = await getGuildPronouns(guildId);
        
        // Remove all existing pronoun roles first
        const currentPronounRoles = targetMember.roles.cache.filter(role => 
          pronounRoleIDs.includes(role.id)
        );
        
        if (currentPronounRoles.size > 0) {
          await targetMember.roles.remove(currentPronounRoles.map(role => role.id));
        }

        // Add new selected roles
        if (selectedRoleIds.length > 0) {
          await targetMember.roles.add(selectedRoleIds);
          
          // Get role names for confirmation message
          const selectedRoles = await Promise.all(
            selectedRoleIds.map(id => guild.roles.fetch(id))
          );
          const roleNames = selectedRoles.filter(role => role).map(role => role.name);
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚úÖ Set ${targetMember.displayName}'s pronouns to: ${roleNames.join(', ')}`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        } else {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚úÖ Removed all pronoun roles from ${targetMember.displayName}`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

      } catch (error) {
        console.error('Error handling admin pronoun selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error setting pronoun roles.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('admin_select_timezone_')) {
      // Handle admin timezone role selection
      try {
        const guildId = req.body.guild_id;
        const adminUserId = req.body.member.user.id;
        const targetPlayerId = custom_id.split('_')[3]; // Extract player ID from admin_select_timezone_${playerId}
        const selectedRoleIds = data.values || [];

        const guild = await client.guilds.fetch(guildId);
        const targetMember = await guild.members.fetch(targetPlayerId);
        const adminMember = await guild.members.fetch(adminUserId);

        // Check admin permissions
        if (!adminMember.permissions.has(PermissionFlagsBits.ManageRoles) && 
            !adminMember.permissions.has(PermissionFlagsBits.ManageChannels) && 
            !adminMember.permissions.has(PermissionFlagsBits.ManageGuild)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå You need Manage Roles, Manage Channels, or Manage Server permissions to use this feature.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Check permissions for selected role before making changes
        if (selectedRoleIds.length > 0) {
          const permissionCheck = await checkRoleHierarchyPermission(guild, selectedRoleIds[0], client);
          if (!permissionCheck.allowed) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå ${permissionCheck.reason}`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
        }

        // Get all configured timezone roles for this guild
        const timezoneRoles = await getGuildTimezones(guildId);
        const timezoneRoleIds = Object.keys(timezoneRoles || {});
        
        // Remove all existing timezone roles first
        const currentTimezoneRoles = targetMember.roles.cache.filter(role => 
          timezoneRoleIds.includes(role.id)
        );
        
        if (currentTimezoneRoles.size > 0) {
          await targetMember.roles.remove(currentTimezoneRoles.map(role => role.id));
        }

        // Add new selected role (only one timezone allowed)
        if (selectedRoleIds.length > 0) {
          await targetMember.roles.add(selectedRoleIds[0]);
          
          // Get role name and offset for confirmation message
          const selectedRole = await guild.roles.fetch(selectedRoleIds[0]);
          const offset = timezoneRoles[selectedRoleIds[0]]?.offset || 0;
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚úÖ Set ${targetMember.displayName}'s timezone to: ${selectedRole.name} (UTC${offset >= 0 ? '+' : ''}${offset})`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        } else {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚úÖ Removed timezone role from ${targetMember.displayName}`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

      } catch (error) {
        console.error('Error handling admin timezone selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error setting timezone role.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('admin_select_vanity_')) {
      // Handle admin vanity role selection
      try {
        const guildId = req.body.guild_id;
        const adminUserId = req.body.member.user.id;
        const targetPlayerId = custom_id.split('_')[3]; // Extract player ID from admin_select_vanity_${playerId}
        const selectedRoleIds = data.values || [];

        const guild = await client.guilds.fetch(guildId);
        const targetMember = await guild.members.fetch(targetPlayerId);
        const adminMember = await guild.members.fetch(adminUserId);

        // Check admin permissions
        if (!adminMember.permissions.has(PermissionFlagsBits.ManageRoles) && 
            !adminMember.permissions.has(PermissionFlagsBits.ManageChannels) && 
            !adminMember.permissions.has(PermissionFlagsBits.ManageGuild)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå You need Manage Roles, Manage Channels, or Manage Server permissions to use this feature.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Update player data with vanity roles (additive per user requirement)
        if (selectedRoleIds.length > 0) {
          // Get current vanity roles
          const currentPlayer = getPlayer(guildId, targetPlayerId) || {};
          const currentVanityRoles = currentPlayer.vanityRoles || [];
          
          // Add new roles to existing ones (additive) - avoid duplicates
          const newVanityRoles = [...new Set([...currentVanityRoles, ...selectedRoleIds])];
          
          // Update player data
          updatePlayer(guildId, targetPlayerId, { vanityRoles: newVanityRoles });
          
          // Get role names for confirmation (only show newly added roles)
          const rolePromises = selectedRoleIds.map(async (roleId) => {
            try {
              const role = await guild.roles.fetch(roleId);
              return role ? role.name : roleId;
            } catch {
              return roleId;
            }
          });
          
          const roleNames = await Promise.all(rolePromises);
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚úÖ Added vanity roles to ${targetMember.displayName}: ${roleNames.join(', ')}`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        } else {
          // If no roles selected, treat as "clear all"
          updatePlayer(guildId, targetPlayerId, { vanityRoles: [] });
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚úÖ Removed all vanity roles from ${targetMember.displayName}`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

      } catch (error) {
        console.error('Error handling admin vanity role selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error setting vanity roles.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'prod_edit_timezones_select') {
      // Handle timezone role selection for editing
      try {
        const guildId = req.body.guild_id;
        const selectedRoleIds = data.values || [];
        
        // Get current timezone roles
        const currentTimezones = await getGuildTimezones(guildId);
        const currentRoleIds = Object.keys(currentTimezones);
        
        // Determine which roles to add and remove
        const rolesToAdd = selectedRoleIds.filter(roleId => !currentRoleIds.includes(roleId));
        const rolesToRemove = currentRoleIds.filter(roleId => !selectedRoleIds.includes(roleId));
        
        // Update playerData
        const playerData = await loadPlayerData();
        if (!playerData[guildId]) playerData[guildId] = {};
        if (!playerData[guildId].timezones) playerData[guildId].timezones = {};
        
        // Remove old roles
        for (const roleId of rolesToRemove) {
          delete playerData[guildId].timezones[roleId];
        }
        
        // Add new roles with default UTC offset (admins can adjust via slash commands)
        for (const roleId of rolesToAdd) {
          playerData[guildId].timezones[roleId] = { offset: 0 };
        }
        
        // Save data
        await savePlayerData(playerData);
        
        const addedCount = rolesToAdd.length;
        const removedCount = rolesToRemove.length;
        let resultMessage = '## Timezone Roles Updated!\n\n';
        
        if (addedCount > 0) {
          resultMessage += `‚úÖ Added ${addedCount} timezone role(s)\n`;
        }
        if (removedCount > 0) {
          resultMessage += `üóëÔ∏è Removed ${removedCount} timezone role(s)\n`;
        }
        if (addedCount === 0 && removedCount === 0) {
          resultMessage += '‚úÖ No changes made\n';
        }
        
        resultMessage += '\n**Note:** New timezone roles default to UTC+0. Use the "üó∫Ô∏è Add Timezone" button to set specific offsets.';
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: resultMessage,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error handling timezone role selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error updating timezone roles.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'prod_add_timezone') {
      // Show role select menu for adding a timezone with offset and LEAN design
      return ButtonHandlerFactory.create({
        id: 'prod_add_timezone',
        updateMessage: true,  // Button click - update existing message
        handler: async (context) => {
          // Use Discord.js RoleSelectMenuBuilder for selecting existing roles
          const roleSelect = new RoleSelectMenuBuilder()
            .setCustomId('prod_add_timezone_select')
            .setPlaceholder('Select an existing role from your server')
            .setMinValues(1)
            .setMaxValues(1);

          const selectRow = new ActionRowBuilder().addComponents(roleSelect);

          // Navigation row
          const navRow = new ActionRowBuilder()
            .addComponents(
              new ButtonBuilder()
                .setCustomId('prod_manage_pronouns_timezones')
                .setLabel('‚Üê Reaction Roles')
                .setStyle(ButtonStyle.Secondary)
            );

          // Build LEAN container
          const containerComponents = [
            { type: 10, content: '## üó∫Ô∏è Add Timezone | Set UTC Offset' },
            { type: 14 }, // Separator
            { type: 10, content: `> **\`üó∫Ô∏è Role Selection\`**` },
            { type: 10, content: 'Select an existing role from your server.\n\n**Example Positive UTC values:** 4 corresponds to UTC+4, 5.5 corresponds to UTC+5:30.\n**Example negative UTC values:** -5, -3.5.\n**Enter 0** where the offset is 0, like GMT.' },
            { type: 14 }, // Separator
            selectRow.toJSON(),
            { type: 14 }, // Separator before navigation
            navRow.toJSON()
          ];

          return {
            components: [{
              type: 17, // Container
              accent_color: 0xFF9800, // Orange - "add new" action theme
              components: containerComponents
            }]
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_add_timezone_select') {
      // Handle role selection for adding timezone - show offset modal
      return ButtonHandlerFactory.create({
        id: 'prod_add_timezone_select',
        handler: async (context) => {
          const selectedRoleId = context.values[0]; // Single role selection

          // Create offset input modal
          const modal = new ModalBuilder()
            .setCustomId(`prod_timezone_offset_modal_${selectedRoleId}`)
            .setTitle('Set Offset');

          const offsetInput = new TextInputBuilder()
            .setCustomId('offset')
            .setLabel('UTC Offset')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMaxLength(10)
            .setPlaceholder('e.g. 4, -5, 5.5, 0');

          const row = new ActionRowBuilder().addComponents(offsetInput);
          modal.addComponents(row);

          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
    } else if (custom_id === 'dst_timezone_select') {
      // Handle DST timezone selection - toggle DST state
      return ButtonHandlerFactory.create({
        id: 'dst_timezone_select',
        ephemeral: true,
        handler: async (context) => {
          const selectedTimezoneId = context.values[0];
          console.log(`üåç DEBUG: Toggling DST for timezone ${selectedTimezoneId}`);

          // Load DST state
          const { loadDSTState, saveDSTState } = await import('./storage.js');
          const dstState = await loadDSTState();

          const timezone = dstState[selectedTimezoneId];
          if (!timezone) {
            return {
              content: `‚ùå Error: Timezone ${selectedTimezoneId} not found in DST state.`,
              ephemeral: true
            };
          }

          // Check if this timezone observes DST
          if (!timezone.dstObserved) {
            return {
              content: `‚ö†Ô∏è **${timezone.displayName}** does not observe Daylight Saving Time.\n\nThis timezone maintains a constant UTC offset year-round.`,
              ephemeral: true
            };
          }

          // Toggle DST state
          const oldState = timezone.isDST;
          const newState = !oldState;

          // Update the timezone data
          timezone.isDST = newState;
          timezone.currentOffset = newState ? timezone.dstOffset : timezone.standardOffset;

          // Save the updated DST state
          await saveDSTState(dstState);

          // Create success message with details
          const oldAbbrev = oldState ? timezone.dstAbbrev : timezone.standardAbbrev;
          const newAbbrev = newState ? timezone.dstAbbrev : timezone.standardAbbrev;
          const oldOffset = oldState ? timezone.dstOffset : timezone.standardOffset;
          const newOffset = newState ? timezone.dstOffset : timezone.standardOffset;

          const response = [
            `‚úÖ **DST State Updated**`,
            '',
            `**Timezone:** ${timezone.displayName}`,
            `**Changed from:** ${oldAbbrev} (UTC${oldOffset >= 0 ? '+' : ''}${oldOffset}) ${oldState ? '‚òÄÔ∏è' : '‚ùÑÔ∏è'}`,
            `**Changed to:** ${newAbbrev} (UTC${newOffset >= 0 ? '+' : ''}${newOffset}) ${newState ? '‚òÄÔ∏è' : '‚ùÑÔ∏è'}`,
            '',
            `This change affects all servers using the "${timezone.roleFormat}" role with the new DST system.`,
            '',
            `üí° **Note:** Players will see updated times immediately in castlists and other displays.`
          ].join('\n');

          console.log(`‚úÖ DST toggled for ${selectedTimezoneId}: ${oldAbbrev} ‚Üí ${newAbbrev}`);

          return {
            content: response,
            ephemeral: true
          };
        }
      })(req, res, client);
    } else if (custom_id === 'prod_edit_pronouns_select') {
      // Handle pronoun role selection for editing
      try {
        const guildId = req.body.guild_id;
        const selectedRoleIds = data.values || [];
        
        // Update playerData
        const playerData = await loadPlayerData();
        if (!playerData[guildId]) playerData[guildId] = {};
        
        // Set new pronoun roles (replace entirely)
        playerData[guildId].pronounRoleIDs = selectedRoleIds;
        
        // Save data
        await savePlayerData(playerData);
        
        const resultMessage = `## Pronoun Roles Updated!\n\n‚úÖ Set ${selectedRoleIds.length} pronoun role(s)`;
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: resultMessage,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error handling pronoun role selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error updating pronoun roles.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_post_select_button') {
      // Handle Safari button selection for posting
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const selectedButtonId = data.values[0];
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to post custom buttons.')) return;
        
        console.log(`üì§ DEBUG: Selected button ${selectedButtonId} to post`);
        
        // Import Safari manager functions
        const { getCustomButton } = await import('./safariManager.js');
        
        // Get the selected button details
        const button = await getCustomButton(guildId, selectedButtonId);
        if (!button) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Selected button not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Create channel selection dropdown
        const channelSelect = new ChannelSelectMenuBuilder()
          .setCustomId(`safari_post_channel_${selectedButtonId}`)
          .setPlaceholder('Choose a channel to post the button...')
          .setChannelTypes([ChannelType.GuildText, ChannelType.GuildAnnouncement]);
        
        const channelSelectRow = new ActionRowBuilder().addComponents(channelSelect);
        
        // Create cancel button
        const cancelButton = new ButtonBuilder()
          .setCustomId('safari_post_button')
          .setLabel('‚¨Ö Back')
          .setStyle(ButtonStyle.Secondary);
        
        const cancelRow = new ActionRowBuilder().addComponents(cancelButton);
        
        // Create response with Components V2
        const containerComponents = [
          {
            type: 10, // Text Display component
            content: `## üì§ Post Custom Button\n\n**Selected:** ${button.label} ${button.emoji || ''}`
          },
          {
            type: 10, // Text Display component
            content: `> **Actions:** ${button.actions.length}\n> **Created:** ${new Date(button.metadata.createdAt).toLocaleDateString()}\n> **Usage:** ${button.metadata.usageCount} time${button.metadata.usageCount !== 1 ? 's' : ''}`
          },
          {
            type: 10, // Text Display component
            content: `**Choose a channel to post this button:**`
          },
          channelSelectRow.toJSON(), // Channel selection dropdown
          {
            type: 14 // Separator
          },
          cancelRow.toJSON() // Back button
        ];
        
        const container = {
          type: 17, // Container component
          accent_color: 0xf39c12, // Orange accent color
          components: containerComponents
        };
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 flag + ephemeral
            components: [container]
          }
        });
        
      } catch (error) {
        console.error('Error handling safari button selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error selecting button.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_post_channel_')) {
      // Handle Safari channel selection for posting button
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const buttonId = custom_id.replace('safari_post_channel_', '');
        const selectedChannelId = data.values[0];
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to post custom buttons.')) return;
        
        console.log(`üì§ DEBUG: Posting button ${buttonId} to channel ${selectedChannelId}`);
        
        // Import Safari manager functions
        const { getCustomButton, postButtonToChannel } = await import('./safariManager.js');
        
        // Get the button details
        const button = await getCustomButton(guildId, buttonId);
        if (!button) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Button not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Post the button to the selected channel
        try {
          await postButtonToChannel(guildId, buttonId, selectedChannelId, client);
          
          // Get channel info for confirmation
          const channel = await client.channels.fetch(selectedChannelId);
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚úÖ **Button posted successfully!**\n\n**Button:** ${button.label} ${button.emoji || ''}\n**Channel:** <#${selectedChannelId}>\n\nPlayers can now interact with your custom button!`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
          
        } catch (postError) {
          console.error('Error posting button to channel:', postError);
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Failed to post button to channel. Please check bot permissions.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
      } catch (error) {
        console.error('Error handling safari channel selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error posting button.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_currency_select_user') {
      // Handle user selection for setting currency - show currency input modal (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_currency_select_user',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const selectedUserId = context.values[0];
          
          console.log(`üí∞ DEBUG: Selected user ${selectedUserId} for currency setting`);
          
          // Get current currency balance
          const playerData = await loadPlayerData();
          const currentCurrency = playerData[context.guildId]?.players?.[selectedUserId]?.safari?.currency || 0;
          
          // Create currency input modal
          const modal = new ModalBuilder()
            .setCustomId(`safari_currency_modal_${selectedUserId}`)
            .setTitle('Set Player Currency');

          const currencyInput = new TextInputBuilder()
            .setCustomId('currency_amount')
            .setLabel('Currency Amount')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMaxLength(10)
            .setPlaceholder('Enter amount (0-999999)')
            .setValue(currentCurrency.toString());

          const row = new ActionRowBuilder().addComponents(currencyInput);
          modal.addComponents(row);

          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_item_qty_user_select_')) {
      // Handle user selection for item quantity management - show quantity input modal (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_item_qty_user_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context, req) => {
          const selectedUserId = req.body.data.values[0];
          
          // Extract item ID from custom_id: safari_item_qty_user_select_${guildId}_${itemId}
          const parts = context.customId.split('_');
          // Skip: safari(0), item(1), qty(2), user(3), select(4), guildId(5), then itemId starts at index 6
          const itemId = parts.slice(6).join('_'); // Everything after the guildId
          
          console.log(`üì¶ DEBUG: Selected user ${selectedUserId} for item ${itemId} quantity management`);
          
          // Load item data to get item name and attack info
          const { loadEntity } = await import('./entityManager.js');
          const item = await loadEntity(context.guildId, 'item', itemId);
          console.log(`üì¶ DEBUG: loadEntity result for item ${itemId}:`, item);
          const itemName = item?.name || 'Unknown Item';
          
          // Get current item quantity and check if it's an attack item
          const playerData = await loadPlayerData();
          const inventory = playerData[context.guildId]?.players?.[selectedUserId]?.safari?.inventory || {};
          const currentItem = inventory[itemId];
          
          let currentQuantity = '';
          let modalLabel = 'Qty';
          
          if (currentItem) {
            // Item exists - show current quantity
            currentQuantity = currentItem.quantity?.toString() || '0';
            
            // Check if it's an attack item (has numAttacksAvailable property)
            if (currentItem.numAttacksAvailable !== undefined) {
              modalLabel = `Qty (numAttacksAvailable = ${currentItem.numAttacksAvailable})`;
            }
          } else {
            // Item doesn't exist - blank modal (never interacted with this item)
            currentQuantity = '';
          }
          
          // Get target user info for modal title
          const guild = await client.guilds.fetch(context.guildId);
          const targetMember = await guild.members.fetch(selectedUserId);
          
          // Create quantity input modal with truncated title to fit Discord's 45 char limit
          let modalTitle = `Set ${itemName} Quantity`;
          if (modalTitle.length > 45) {
            // Truncate item name to fit, accounting for ellipsis
            const maxItemNameLength = 45 - 16; // "Set " (4) + "... Quantity" (12) = 16
            modalTitle = `Set ${itemName.substring(0, maxItemNameLength)}... Quantity`;
          }
          
          const modal = new ModalBuilder()
            .setCustomId(`safari_item_qty_modal_${context.guildId}_${itemId}_${selectedUserId}`)
            .setTitle(modalTitle);

          const quantityInput = new TextInputBuilder()
            .setCustomId('item_quantity')
            .setLabel(modalLabel)
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMaxLength(10)
            .setPlaceholder('Enter quantity (0 or higher)');
          
          // Set value if item exists
          if (currentQuantity !== '') {
            quantityInput.setValue(currentQuantity);
          }

          const row = new ActionRowBuilder().addComponents(quantityInput);
          modal.addComponents(row);

          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
    } else if (custom_id === 'safari_inventory_user_select') {
      // Handle user selection for inventory viewing - show complete player inventory
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const selectedUserId = data.values[0];
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to view player inventories.')) return;
        
        console.log(`üëÄ DEBUG: Selected user ${selectedUserId} for inventory viewing`);
        
        // Import and use the existing inventory display function
        const { createPlayerInventoryDisplay } = await import('./safariManager.js');
        
        // Get user info for display
        const guild = await client.guilds.fetch(guildId);
        const targetMember = await guild.members.fetch(selectedUserId);
        
        // Create inventory display for the selected player (page 0 initially)
        const inventoryDisplay = await createPlayerInventoryDisplay(guildId, selectedUserId, targetMember, 0);
        
        // The inventory display already has the proper structure
        // Just send it directly - it already has IS_COMPONENTS_V2 flag and ephemeral
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: inventoryDisplay
        });
        
      } catch (error) {
        console.error('Error handling inventory user selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error viewing player inventory.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_inv_page_')) {
      // Handle inventory page navigation
      return ButtonHandlerFactory.create({
        id: 'safari_inv_page',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: safari_inv_page - user ${context.userId}`);
          const { guildId, userId: viewerId } = context;
          
          // Extract userId and page from custom_id: safari_inv_page_{userId}_{page}
          const parts = context.customId.split('_');
          const targetUserId = parts[3]; // safari_inv_page_{userId}_{page}
          const targetPage = parseInt(parts[4]);
          
          console.log(`üìÑ Navigating to inventory page ${targetPage} for user ${targetUserId}`);
          
          // Import inventory display function
          const { createPlayerInventoryDisplay } = await import('./safariManager.js');
          
          // Check if this is admin viewing another user's inventory or self-viewing
          let targetMember = null;
          if (targetUserId !== viewerId) {
            // Admin viewing another user - fetch member info
            try {
              const guild = await client.guilds.fetch(guildId);
              targetMember = await guild.members.fetch(targetUserId);
            } catch (error) {
              console.error('Error fetching target member:', error);
            }
          }
          
          // Create inventory display for the requested page
          const inventoryDisplay = await createPlayerInventoryDisplay(guildId, targetUserId, targetMember, targetPage);
          
          console.log(`‚úÖ SUCCESS: safari_inv_page - navigated to page ${targetPage}`);
          
          // Return the updated inventory display
          return inventoryDisplay;
        }
      })(req, res, client);
    // safari_store_edit_select handler removed - functionality replaced by safari_store_manage_items
    } else if (custom_id === 'safari_item_edit_select') {
      // Handle item selection for editing - redirect to new entity management UI (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_item_edit_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const selectedItemId = context.values[0];
          
          console.log(`‚úèÔ∏è DEBUG: Selected item ${selectedItemId} for editing`);
          
          // Create entity management UI with selected item - go directly to edit mode
          const uiResponse = await createEntityManagementUI({
            entityType: 'item',
            guildId: context.guildId,
            selectedId: selectedItemId,
            activeFieldGroup: null,
            searchTerm: '',
            mode: 'edit'
          });
          
          return uiResponse;
        }
      })(req, res, client);
    // ==================== ENTITY MANAGEMENT HANDLERS ====================
    // New entity management system for Safari items, stores, and buttons
    
    } else if (custom_id.startsWith('condition_type_select_')) {
      // Handle condition type selector
      return ButtonHandlerFactory.create({
        id: 'condition_type_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_type_select - user ${context.userId}`);
          
          // Parse custom_id: condition_type_select_actionId_conditionIndex_currentPage
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // Remove 'condition'
          customIdParts.shift(); // Remove 'type'
          customIdParts.shift(); // Remove 'select'
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          
          const newType = context.values[0];
          
          // Load and update condition
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          
          if (!condition) {
            throw new Error('Condition not found');
          }
          
          // Update condition type and reset type-specific fields
          condition.type = newType;
          
          // Reset fields based on new type
          switch (newType) {
            case 'currency':
              condition.operator = 'gte';
              condition.value = 0;
              delete condition.itemId;
              delete condition.roleId;
              break;
            case 'item':
              condition.operator = 'has';  // Always reset to valid operator
              delete condition.value;
              delete condition.roleId;
              // Set to first available item if any exist, otherwise null
              const availableItems = Object.keys(allSafariContent[context.guildId]?.items || {});
              condition.itemId = availableItems.length > 0 ? availableItems[0] : null;
              break;
            case 'role':
              condition.operator = 'has';
              delete condition.value;
              delete condition.itemId;
              condition.roleId = null;
              break;
            case 'attribute_check':
              // Initialize config object for attribute conditions
              condition.config = {
                attributeId: null,
                comparison: 'gte',
                target: 'current',
                value: 0,
                includeItemBonuses: false
              };
              // Clean up fields used by other condition types
              delete condition.operator;
              delete condition.value;
              delete condition.itemId;
              delete condition.roleId;
              break;
            case 'attribute_compare':
              // Initialize config for comparing two attributes
              condition.config = {
                leftAttributeId: null,
                leftTarget: 'current',
                comparison: 'gte',
                rightAttributeId: null,
                rightTarget: 'current',
                includeItemBonuses: false
              };
              delete condition.operator;
              delete condition.value;
              delete condition.itemId;
              delete condition.roleId;
              break;
            case 'multi_attribute_check':
              // Initialize config for multi-attribute checks
              condition.config = {
                mode: 'all',
                attributes: [],
                comparison: 'gte',
                value: 0,
                includeItemBonuses: false
              };
              delete condition.operator;
              delete condition.value;
              delete condition.itemId;
              delete condition.roleId;
              break;
          }

          // Save changes
          await saveSafariContent(allSafariContent);
          
          console.log(`‚úÖ SUCCESS: condition_type_select - changed to ${newType}`);
          
          // Refresh condition editor
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({
            res,
            actionId,
            conditionIndex,
            guildId: context.guildId,
            currentPage
          });
          
          return;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('whisper_player_select_')) {
      // Handle whisper player selection (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'whisper_player_select',
        isModal: true,
        handler: async (context) => {
          console.log(`üîç START: whisper_player_select - user ${context.userId}`);
          
          const coordinate = context.customId.replace('whisper_player_select_', '');
          const targetUserId = context.values[0]; // From select menu
          
          console.log(`üí¨ Whisper player selected - sender: ${context.userId}, target: ${targetUserId}, coord: ${coordinate}`);
          
          try {
            const { showWhisperModal } = await import('./whisperManager.js');
            const modalResponse = await showWhisperModal({ 
              userId: context.userId, 
              guildId: context.guildId, 
              token: context.token 
            }, targetUserId, coordinate, client);
            
            console.log(`‚úÖ SUCCESS: whisper_player_select - modal shown`);
            return modalResponse;
          } catch (error) {
            console.error('‚ùå Failed to show whisper modal:', error);
            return {
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå An error occurred while preparing the whisper interface.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('entity_select_')) {
      // Handle entity selection from dropdown (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'entity_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context, req, res) => {
          const parts = context.customId.split('_');
          const entityType = parts.slice(2).join('_'); // Handle entity types with underscores
          const selectedValue = context.values[0];
        
          console.log(`üìã DEBUG: Entity select - Type: ${entityType}, Value: ${selectedValue}`);
          
          // Handle seasons entity type specially
          if (entityType === 'seasons') {
            if (selectedValue === 'create_new_season') {
              // Show season creation modal using modern Label components (Type 18)
              return res.send({
                type: InteractionResponseType.MODAL,
                data: {
                  custom_id: 'season_modal:create',
                  title: 'Manage Season Details',
                  components: [
                    {
                      type: 18, // Label component
                      label: 'Season Name',
                      component: {
                        type: 4, // Text Input
                        custom_id: 'season_name',
                        style: 1, // Short
                        placeholder: 'e.g., "Season 12 - Jurassic Park"',
                        required: true,
                        max_length: 100
                      }
                    },
                    {
                      type: 18, // Label component
                      label: 'Season Description',
                      description: 'Brief description of this season (optional)',
                      component: {
                        type: 4, // Text Input
                        custom_id: 'season_description',
                        style: 2, // Paragraph
                        placeholder: 'Describe your season...',
                        required: false,
                        max_length: 500
                      }
                    }
                  ]
                }
              });
            } else {
              // Selected an existing season - show season management UI
              const configId = selectedValue;
              const playerData = await loadPlayerData();
              const config = playerData[context.guildId]?.applicationConfigs?.[configId];
              
              if (!config) {
                return {
                  content: '‚ùå Season not found.',
                  ephemeral: true
                };
              }

              // Ensure questions array exists
              if (!config.questions) {
                config.questions = [];
                await savePlayerData(playerData);
              }
              
              // Use the updated question management UI function (start at page 0)
              // Call the function but don't return its result since it sends the response directly
              await refreshQuestionManagementUI(res, config, configId, 0);
              // Return undefined to indicate the response was already sent
              return;
            }
          }
          
          // Handle special actions for other entity types
          if (selectedValue === 'back_to_all') {
            // Return to full entity list
            const { createEntityManagementUI } = await import('./entityManagementUI.js');
            const ui = await createEntityManagementUI({
              entityType: entityType,
              guildId: context.guildId,
              mode: 'list'
            });
            
            return res.send({
              type: InteractionResponseType.UPDATE_MESSAGE,
              data: {
                ...ui,
                ephemeral: true
              }
            });
          } else if (selectedValue === 'search_entities') {
            // Show search modal
            return res.send({
              type: InteractionResponseType.MODAL,
              data: {
                title: `Search ${entityType}s`,
                custom_id: `entity_search_modal_${entityType}`,
                components: [{
                  type: 1, // ActionRow
                  components: [{
                    type: 4, // Text Input
                    custom_id: 'search_term',
                    label: 'Search Term',
                    style: 1, // Short
                    placeholder: 'Enter name or description to search...',
                    required: true,
                    max_length: 50
                  }]
                }]
              }
            });
          } else if (selectedValue === 'create_new') {
            // Show creation modal with Item Info format (name, emoji, description)
            const { createFieldGroupModal } = await import('./fieldEditors.js');
            
            try {
              const modal = createFieldGroupModal(entityType, 'new', 'info', {});
              if (modal) {
                // Update modal title and custom_id for creation
                modal.data.title = `Create New ${entityType === 'safari_button' ? 'Button' : entityType.charAt(0).toUpperCase() + entityType.slice(1)}`;
                modal.data.custom_id = `entity_create_modal_${entityType}_info`;
                return res.send(modal);
              }
            } catch (modalError) {
              console.error('Error creating field group modal:', modalError);
            }
            
            // Fallback to simple modal if field group modal fails
            return res.send({
              type: InteractionResponseType.MODAL,
              data: {
                title: `Create New ${entityType === 'safari_button' ? 'Button' : entityType.charAt(0).toUpperCase() + entityType.slice(1)}`,
                custom_id: `entity_create_modal_${entityType}`,
                components: [{
                  type: 1, // ActionRow
                  components: [{
                    type: 4, // Text Input
                    custom_id: 'name',
                    label: entityType === 'safari_button' ? 'Button Label' : 'Name',
                    style: 1, // Short
                    placeholder: `Enter ${entityType === 'safari_button' ? 'button label' : 'name'}...`,
                    required: true,
                    max_length: entityType === 'safari_button' ? 80 : 100
                  }]
                }]
              }
            });
          } else {
            // Check if this is a map cell selection - if so, go directly to custom actions
            if (entityType === 'map_cell') {
              // For map cells, directly open the custom action UI
              const { createCustomActionSelectionUI } = await import('./customActionUI.js');
              const { loadSafariContent } = await import('./safariManager.js');
              
              const allSafariData = await loadSafariContent();
              const guildData = allSafariData[context.guildId] || {};
              const activeMapId = guildData.maps?.active;
              
              if (!activeMapId) {
                return res.send({
                  type: InteractionResponseType.UPDATE_MESSAGE,
                  data: {
                    content: '‚ùå No active map found.',
                    flags: InteractionResponseFlags.EPHEMERAL
                  }
                });
              }
              
              // selectedValue is the coordinate (e.g., "B3")
              const customActionUI = await createCustomActionSelectionUI({
                guildId: context.guildId,
                coordinate: selectedValue,
                mapId: activeMapId
              });
              
              return res.send({
                type: InteractionResponseType.UPDATE_MESSAGE,
                data: {
                  ...customActionUI,
                  ephemeral: true
                }
              });
            }
            
            // Regular entity selection - go straight to edit mode
            const uiResponse = await createEntityManagementUI({
              entityType: entityType,
              guildId: context.guildId,
              selectedId: selectedValue,
              activeFieldGroup: null,
              searchTerm: '',
              mode: 'edit'
            });
            
            // Use UPDATE_MESSAGE to replace the entity picker with the item editor
            return res.send({
              type: InteractionResponseType.UPDATE_MESSAGE,
              data: {
                ...uiResponse,
                ephemeral: true
              }
            });
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('entity_search_again_')) {
      // Handle "Search Again" button from too many results screen (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'entity_search_again',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const entityType = context.customId.replace('entity_search_again_', '');
          
          console.log(`üîç DEBUG: Search again clicked for entityType: ${entityType}`);
          
          // Show search modal (same as the "search_entities" option)
          return {
            type: InteractionResponseType.MODAL,
            data: {
              title: `Search ${entityType}s`,
              custom_id: `entity_search_modal_${entityType}`,
              components: [{
                type: 1, // ActionRow
                components: [{
                  type: 4, // Text Input
                  custom_id: 'search_term',
                  label: 'Search Term',
                  style: 1, // Short
                  placeholder: 'Enter name or description to search...',
                  required: true,
                  max_length: 50
                }]
              }]
            }
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('entity_edit_mode_')) {
      // Switch to edit mode for an entity (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'entity_edit_mode',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.split('_');
          const entityType = parts[3];
          const entityId = parts.slice(4).join('_');
          
          console.log(`‚úèÔ∏è DEBUG: Edit mode - Type: ${entityType}, ID: ${entityId}`);
          
          const uiResponse = await createEntityManagementUI({
            entityType: entityType,
            guildId: context.guildId,
            selectedId: entityId,
            activeFieldGroup: null,
            searchTerm: '',
            mode: 'edit'
          });
          
          return {
            ...uiResponse,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('entity_view_mode_')) {
      // Switch back to view mode for an entity (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'entity_view_mode',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true, // Replace delete confirmation with item editor
        handler: async (context) => {
          const parts = context.customId.split('_');
          const entityType = parts[3];
          const entityId = parts.slice(4).join('_');
          
          console.log(`üëÅÔ∏è DEBUG: View mode - Type: ${entityType}, ID: ${entityId}`);
          
          const uiResponse = await createEntityManagementUI({
            entityType: entityType,
            guildId: context.guildId,
            selectedId: entityId,
            activeFieldGroup: null,
            searchTerm: '',
            mode: 'edit'
          });
          
          return uiResponse;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('entity_field_group_')) {
      // Handle field group button click (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'entity_field_group',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context, req, res) => {
          // Parse: entity_field_group_{entityType}_{entityId}_{fieldGroup}
          const withoutPrefix = context.customId.replace('entity_field_group_', '');
          const parts = withoutPrefix.split('_');
          
          // Handle special case for map_cell entityType
          let entityType, entityId, fieldGroup;
          if (parts[0] === 'map' && parts[1] === 'cell') {
            entityType = 'map_cell';
            fieldGroup = parts[parts.length - 1];
            entityId = parts.slice(2, -1).join('_'); // Skip 'map_cell', take until fieldGroup
          } else {
            entityType = parts[0];
            fieldGroup = parts[parts.length - 1];
            entityId = parts.slice(1, -1).join('_');
          }
          
          console.log('üîç DEBUG: Field group click - Type:', entityType, 'ID:', entityId, 'Group:', fieldGroup);
        
          // Handle special field groups for map_cell
          if (entityType === 'map_cell') {
            if (fieldGroup === 'stores') {
              // Use IDENTICAL store selector as safari_store_manage_items (GOLD STANDARD)
              const { createStoreSelectionUI } = await import('./storeSelector.js');

              // Load current stores for this location for pre-selection
              const { loadSafariContent } = await import('./safariManager.js');
              const safariData = await loadSafariContent();
              const activeMapId = safariData[context.guildId]?.maps?.active;
              const coordStores = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[entityId]?.stores || [];
              console.log(`üîç DEBUG: Map location ${entityId} - activeMapId: ${activeMapId}, coordStores: ${JSON.stringify(coordStores)}, length: ${coordStores.length}`);

              // Get IDENTICAL working UI but with location-specific data
              const uiResponse = await createStoreSelectionUI({
                guildId: context.guildId,
                action: 'add_to_location',  // Pass location action to enable sorting
                entityId: entityId,
                preSelectedStores: coordStores  // CRITICAL: Pass current stores for sorting
              });

              // Modify the working UI for location behavior
              if (uiResponse.components?.[0]?.components) {
                for (const component of uiResponse.components[0].components) {
                  // Update the select menu
                  if (component.type === 1 && component.components?.[0]?.custom_id === 'safari_store_items_select') {
                    const selectMenu = component.components[0];

                    // Change custom_id to route to location handler
                    selectMenu.custom_id = `safari_store_select_add_to_location_${entityId}`;

                    // Set min_values to 0 to allow deselection
                    selectMenu.min_values = 0;

                    // Keep single-select behavior for proper toggle (no pre-selection conflicts)
                    selectMenu.max_values = 1;

                    // Add visual indicators instead of pre-selection (bulletproof approach)
                    if (selectMenu.options && coordStores.length > 0) {
                      selectMenu.options.forEach(option => {
                        // Skip special options (Create New Store, Search)
                        if (option.value === 'create_new_store' || option.value === 'search_stores') {
                          return;
                        }

                        // Add visual indicator for currently added stores
                        if (coordStores.includes(option.value)) {
                          option.label = option.label + ' (‚úÖ Currently Added)';
                          option.description = 'Click to remove from this location';
                        } else {
                          option.description = 'Click to add to this location';
                        }
                      });
                    }
                  }

                  // Update the title text to show location-specific info
                  if (component.type === 10) { // Text Display
                    const selectedCount = coordStores.length;
                    const instructions = selectedCount > 0
                      ? `**Current**: ${selectedCount} store${selectedCount !== 1 ? 's' : ''}\n‚Ä¢ Click highlighted stores to remove\n‚Ä¢ Click others to add`
                      : `Select a store to add to this location`;

                    component.content = `## üè™ Manage Stores at ${entityId}\n\n${instructions}`;
                  }
                }
              }

              return uiResponse;

            } else if (fieldGroup === 'items') {
              // Show drop management interface
              const { loadSafariContent } = await import('./safariManager.js');
              const safariData = await loadSafariContent();
              const items = safariData[context.guildId]?.items || {};
              const activeMapId = safariData[context.guildId]?.maps?.active;
              const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[entityId];
              
              const components = [
                {
                  type: 10, // Text Display
                  content: `# Drop Management for ${entityId}\n\nManage item and currency drops at this location.`
                },
                { type: 14 } // Separator
              ];
              
              // Show existing currency drops
              if (coordData?.currencyDrops?.length > 0) {
                components.push({
                  type: 10, // Text Display
                  content: `### ü™ô Currency Drops (${coordData.currencyDrops.length})`
                });
                
                coordData.currencyDrops.forEach((drop, index) => {
                  const config = safariData[context.guildId]?.safariConfig || {};
                  const currencyEmoji = config.currencyEmoji || 'ü™ô';
                  const currencyName = config.currencyName || 'coins';
                  
                  components.push({
                    type: 9, // Section
                    components: [{
                      type: 10,
                      content: `**${drop.buttonEmoji} ${drop.buttonText}**\nAmount: ${drop.amount} ${currencyEmoji} ${currencyName}\nType: ${drop.dropType === 'once_per_player' ? 'One per player' : 'One per season'}`
                    }],
                    accessory: {
                      type: 2, // Button
                      custom_id: `map_currency_drop_config_${entityId}_${index}`,
                      label: 'Configure',
                      style: 2, // Secondary
                      emoji: { name: '‚öôÔ∏è' }
                    }
                  });
                });
                components.push({ type: 14 }); // Separator after currency drops
              }
              
              // Show existing item drops
              if (coordData?.itemDrops?.length > 0) {
                components.push({
                  type: 10, // Text Display
                  content: `### üì¶ Item Drops (${coordData.itemDrops.length})`
                });
                
                coordData.itemDrops.forEach((drop, index) => {
                  const item = safariData[context.guildId]?.items?.[drop.itemId];
                  if (item) {
                    components.push({
                      type: 9, // Section
                      components: [{
                        type: 10,
                        content: `**${drop.buttonEmoji} ${drop.buttonText}**\nItem: ${item.emoji || 'üì¶'} ${item.name}\nType: ${drop.dropType === 'once_per_player' ? 'One per player' : 'One per season'}`
                      }],
                      accessory: {
                        type: 2, // Button
                        custom_id: `map_item_drop_config_${entityId}_${drop.itemId}`,
                        label: 'Configure',
                        style: 2, // Secondary
                        emoji: { name: '‚öôÔ∏è' }
                      }
                    });
                  }
                });
                components.push({ type: 14 }); // Separator after item drops
              }
              
              // Add buttons for new drops
              components.push({
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    custom_id: `map_add_item_drop_${entityId}`,
                    label: 'Add Item Drop',
                    style: 1, // Primary
                    emoji: { name: 'üì¶' },
                    disabled: Object.keys(items).length === 0
                  },
                  {
                    type: 2, // Button
                    custom_id: `map_add_currency_drop_${entityId}`,
                    label: 'Add Currency Drop',
                    style: 1, // Primary
                    emoji: { name: 'ü™ô' }
                  }
                ]
              });
              
              // Build final response
              return {
                components: [{
                  type: 17, // Container
                  components: components
                }],
                flags: (1 << 15), // IS_COMPONENTS_V2
                ephemeral: true
              };
            }
          }
          
          // For consumable property, show select menu instead of modal
          if (fieldGroup === 'properties' && entityType === 'item') {
            const { loadEntity } = await import('./entityManager.js');
            const entity = await loadEntity(context.guildId, entityType, entityId);
            if (!entity) throw new Error('Entity not found');
            
            const { createEntityManagementUI } = await import('./entityManagementUI.js');
            const { createConsumableSelect, createDefaultItemSelect } = await import('./fieldEditors.js');
            
            const uiResponse = await createEntityManagementUI({
              entityType: entityType,
              guildId: context.guildId,
              selectedId: entityId,
              activeFieldGroup: fieldGroup,
              searchTerm: '',
              mode: 'edit'
            });
            
            // Get current defaultItem value from metadata
            const defaultItemValue = entity.metadata?.defaultItem || 'No';
            
            // Create the UI components to add
            const consumableText = {
              type: 10, // Text Display
              content: '**Consumable?**'
            };
            
            const consumableSelect = createConsumableSelect(entityId, entity.consumable);
            
            const defaultItemText = {
              type: 10, // Text Display
              content: '**Starting Item (x1)?**'
            };
            
            const defaultItemSelect = createDefaultItemSelect(entityId, defaultItemValue);
            
            const containerComponents = uiResponse.components[0].components;
            
            // Find the position of the second separator (before Done button)
            let insertIndex = containerComponents.length - 2; // Before separator and Done button
            for (let i = containerComponents.length - 1; i >= 0; i--) {
              if (containerComponents[i].type === 14) { // Separator
                insertIndex = i;
                break;
              }
            }
            
            // Insert all components in order before the separator
            containerComponents.splice(insertIndex, 0, 
              consumableText, 
              consumableSelect, 
              defaultItemText, 
              defaultItemSelect
            );
            
            return {
              ...uiResponse,
              ephemeral: true
            };
          } else if (entityType === 'map_cell' && fieldGroup === 'interaction') {
            // Custom Actions UI - opens editor for actions
            const { createCustomActionSelectionUI } = await import('./customActionUI.js');
            const { loadSafariContent } = await import('./safariManager.js');
            
            const allSafariData = await loadSafariContent();
            const guildData = allSafariData[context.guildId] || {};
            const activeMapId = guildData.maps?.active;
            
            if (!activeMapId) {
              return {
                content: '‚ùå No active map found.',
                ephemeral: true
              };
            }
            
            // entityId is the coordinate (e.g., "B3")
            const customActionUI = await createCustomActionSelectionUI({
              guildId: context.guildId,
              coordinate: entityId,
              mapId: activeMapId
            });
            
            return {
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + ephemeral
              components: customActionUI.components
            };
          } else if (entityType === 'item' && fieldGroup === 'stats') {
            // Phase 5: Stats field group - custom UI for attribute modifiers
            const { loadSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const item = safariData[context.guildId]?.items?.[entityId];
            const attributeDefs = safariData[context.guildId]?.attributeDefinitions || {};

            if (!item) {
              return {
                components: [{ type: 17, components: [{ type: 10, content: '‚ùå Item not found.' }] }]
              };
            }

            const modifiers = item.attributeModifiers || [];

            // Build content showing current bonuses
            let contentLines = [
              `## üìä Attribute Bonuses`,
              ``,
              `Configure stat bonuses granted by **${item.emoji || ''} ${item.name}**.`,
              `*(Non-consumable items only - bonuses persist while in inventory)*`
            ];

            if (modifiers.length > 0) {
              contentLines.push('', '**Current Bonuses:**');
              modifiers.forEach(mod => {
                const attrDef = attributeDefs[mod.attributeId];
                const emoji = attrDef?.emoji || 'üìä';
                const name = attrDef?.name || mod.attributeId;
                const opLabel = mod.operation === 'addMax' ? ' max' : '';
                contentLines.push(`‚Ä¢ ${emoji} **${name}**: +${mod.value}${opLabel}`);
              });
            } else {
              contentLines.push('', '*No attribute bonuses configured.*');
            }

            // Build components - Container structure
            const containerComponents = [
              { type: 10, content: contentLines.join('\n') },
              { type: 14 }  // Separator
            ];

            // Add "Manage existing" select if there are modifiers
            if (modifiers.length > 0) {
              const manageOptions = modifiers.map((mod, index) => {
                const attrDef = attributeDefs[mod.attributeId];
                const emoji = attrDef?.emoji || 'üìä';
                const name = attrDef?.name || mod.attributeId;
                const opLabel = mod.operation === 'addMax' ? ' max' : '';
                return {
                  label: `${emoji} ${name} (+${mod.value}${opLabel})`,
                  value: `edit_${index}`,
                  description: 'Edit or remove this bonus'
                };
              });
              manageOptions.push({
                label: 'üóëÔ∏è Remove All Bonuses',
                value: 'remove_all',
                description: 'Clear all attribute bonuses from this item'
              });

              containerComponents.push({
                type: 1,  // ActionRow
                components: [{
                  type: 3,  // String Select
                  custom_id: `item_attr_manage_${entityId}`,
                  placeholder: 'Manage existing bonus...',
                  options: manageOptions
                }]
              });
            }

            // Add bonus button
            containerComponents.push({
              type: 1,  // ActionRow
              components: [{
                type: 2,  // Button
                custom_id: `item_attr_add_${entityId}`,
                label: 'Add Bonus',
                style: 3,  // Success (green)
                emoji: { name: '‚ûï' }
              }]
            });

            containerComponents.push({ type: 14 });  // Separator

            // Field group buttons (split into 2 rows for 5-button limit)
            const { getFieldGroups } = await import('./entityManagementUI.js');
            const fieldGroups = getFieldGroups('item');
            const groupEntries = Object.entries(fieldGroups);
            const row1Groups = groupEntries.slice(0, 3);
            const row2Groups = groupEntries.slice(3);

            containerComponents.push({
              type: 1,  // ActionRow
              components: row1Groups.map(([groupId, group]) => ({
                type: 2,  // Button
                custom_id: `entity_field_group_item_${entityId}_${groupId}`,
                label: group.label,
                style: groupId === 'stats' ? 1 : 2,  // Primary if active
                emoji: { name: group.emoji }
              }))
            });

            containerComponents.push({
              type: 1,  // ActionRow
              components: row2Groups.map(([groupId, group]) => ({
                type: 2,  // Button
                custom_id: `entity_field_group_item_${entityId}_${groupId}`,
                label: group.label,
                style: groupId === 'stats' ? 1 : 2,  // Primary if active
                emoji: { name: group.emoji }
              }))
            });

            // Back button
            containerComponents.push({
              type: 1,  // ActionRow
              components: [{
                type: 2,  // Button
                custom_id: 'prod_menu_back',
                label: '‚Üê Menu',
                style: 2  // Secondary
              }]
            });

            return {
              components: [{
                type: 17,  // Container
                accent_color: 0x5865f2,
                components: containerComponents
              }]
            };
          } else {
            // Open modal directly for field group editing
            try {
              const { loadEntity } = await import('./entityManager.js');
              const { createFieldGroupModal } = await import('./fieldEditors.js');
              
              const entity = await loadEntity(context.guildId, entityType, entityId);
              if (!entity) {
                console.error(`üö® Entity not found: ${entityType} ${entityId} in guild ${context.guildId}`);
                throw new Error('Entity not found');
              }
              
              console.log(`üîç DEBUG: Creating modal for ${entityType} ${entityId} fieldGroup ${fieldGroup}`);
              const modalResponse = createFieldGroupModal(entityType, entityId, fieldGroup, entity);
              
              if (!modalResponse) {
                console.error(`üö® No modal created for ${entityType} ${fieldGroup}`);
                throw new Error('No modal available for this field group');
              }
              
              console.log(`‚úÖ DEBUG: Modal created successfully`);
              // CRITICAL FIX: Return the complete modal response with type
              // The ButtonHandlerFactory will handle sending the response
              return modalResponse;
            } catch (error) {
              console.error(`üö® Error in field group handler:`, error);
              throw error;
            }
          }
        }
      })(req, res, client);

    // ============================================================================
    // Phase 5: Item Attribute Modifiers - Add/Manage/Edit handlers
    // ============================================================================

    } else if (custom_id.startsWith('item_attr_add_')) {
      // Add attribute bonus button - show attribute selector
      return ButtonHandlerFactory.create({
        id: 'item_attr_add',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const itemId = context.customId.replace('item_attr_add_', '');
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const attributeDefs = safariData[context.guildId]?.attributeDefinitions || {};
          const item = safariData[context.guildId]?.items?.[itemId];
          const existingModifiers = item?.attributeModifiers || [];

          // Get available attributes (exclude ones already configured)
          const configuredAttrIds = existingModifiers.map(m => m.attributeId);
          const availableAttrs = Object.entries(attributeDefs)
            .filter(([attrId]) => !configuredAttrIds.includes(attrId))
            .map(([attrId, def]) => ({
              label: `${def.emoji || 'üìä'} ${def.name || attrId}`,
              value: attrId,
              description: def.category === 'stat' ? 'Stat attribute' : 'Resource attribute'
            }));

          if (availableAttrs.length === 0) {
            return {
              components: [{
                type: 17,
                components: [
                  { type: 10, content: '‚ùå **No attributes available**\n\nAll server attributes are already configured on this item, or no attributes have been created.\n\nGo to **Tools ‚Üí Attributes** to create attributes.' },
                  { type: 14 },
                  { type: 1, components: [{ type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back to Stats', style: 2 }] }
                ]
              }]
            };
          }

          return {
            components: [{
              type: 17,
              accent_color: 0x57f287,  // Green
              components: [
                { type: 10, content: `## ‚ûï Add Attribute Bonus\n\nSelect an attribute to add a bonus for **${item?.name || 'this item'}**:` },
                { type: 14 },
                {
                  type: 1,
                  components: [{
                    type: 3,
                    custom_id: `item_attr_select_${itemId}`,
                    placeholder: 'Select attribute...',
                    options: availableAttrs.slice(0, 25)  // Max 25 options
                  }]
                },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back to Stats', style: 2 }] }
              ]
            }]
          };
        }
      })(req, res, client);

    } else if (custom_id.startsWith('item_attr_select_')) {
      // Attribute selected - open modal to configure value
      return ButtonHandlerFactory.create({
        id: 'item_attr_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        modal: true,
        handler: async (context) => {
          const itemId = context.customId.replace('item_attr_select_', '');
          const attrId = context.values[0];
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const attributeDefs = safariData[context.guildId]?.attributeDefinitions || {};
          const attrDef = attributeDefs[attrId] || {};

          // Return modal for configuring the bonus
          return {
            type: InteractionResponseType.MODAL,
            data: {
              custom_id: `modal_item_attr_${itemId}_${attrId}`,
              title: `Configure ${attrDef.name || attrId} Bonus`,
              components: [
                {
                  type: 1,
                  components: [{
                    type: 4,
                    custom_id: 'bonus_value',
                    label: 'Bonus Amount',
                    style: 1,
                    placeholder: '5',
                    required: true,
                    max_length: 4
                  }]
                },
                {
                  type: 1,
                  components: [{
                    type: 4,
                    custom_id: 'bonus_operation',
                    label: 'Operation (add or addMax)',
                    style: 1,
                    placeholder: 'add',
                    value: 'add',
                    required: true,
                    max_length: 10
                  }]
                }
              ]
            }
          };
        }
      })(req, res, client);

    } else if (custom_id.startsWith('item_attr_manage_')) {
      // Manage existing modifier - show edit/remove options
      return ButtonHandlerFactory.create({
        id: 'item_attr_manage',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const itemId = context.customId.replace('item_attr_manage_', '');
          const selectedValue = context.values[0];
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const item = safariData[context.guildId]?.items?.[itemId];
          const attributeDefs = safariData[context.guildId]?.attributeDefinitions || {};

          if (!item) {
            return { components: [{ type: 17, components: [{ type: 10, content: '‚ùå Item not found.' }] }] };
          }

          if (selectedValue === 'remove_all') {
            // Clear all modifiers
            item.attributeModifiers = [];
            await saveSafariContent(safariData);

            return {
              components: [{
                type: 17,
                components: [
                  { type: 10, content: `‚úÖ **All attribute bonuses removed from ${item.name}.**` },
                  { type: 14 },
                  { type: 1, components: [{ type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back to Stats', style: 1 }] }
                ]
              }]
            };
          }

          // Parse edit_INDEX
          const modifierIndex = parseInt(selectedValue.replace('edit_', ''));
          const modifier = item.attributeModifiers?.[modifierIndex];

          if (!modifier) {
            return { components: [{ type: 17, components: [{ type: 10, content: '‚ùå Modifier not found.' }] }] };
          }

          const attrDef = attributeDefs[modifier.attributeId] || {};
          const emoji = attrDef.emoji || 'üìä';
          const name = attrDef.name || modifier.attributeId;
          const opLabel = modifier.operation === 'addMax' ? ' max' : '';

          return {
            components: [{
              type: 17,
              accent_color: 0x5865f2,
              components: [
                { type: 10, content: `## ${emoji} ${name} Bonus\n\n**Current Value:** +${modifier.value}${opLabel}\n\nWhat would you like to do?` },
                { type: 14 },
                {
                  type: 1,
                  components: [
                    { type: 2, custom_id: `item_attr_edit_${itemId}_${modifierIndex}`, label: 'Edit Value', style: 1, emoji: { name: '‚úèÔ∏è' } },
                    { type: 2, custom_id: `item_attr_remove_${itemId}_${modifierIndex}`, label: 'Remove', style: 4, emoji: { name: 'üóëÔ∏è' } },
                    { type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back', style: 2 }
                  ]
                }
              ]
            }]
          };
        }
      })(req, res, client);

    } else if (custom_id.startsWith('item_attr_edit_')) {
      // Edit existing modifier - open modal
      return ButtonHandlerFactory.create({
        id: 'item_attr_edit',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        modal: true,
        handler: async (context) => {
          const parts = context.customId.replace('item_attr_edit_', '').split('_');
          const modifierIndex = parseInt(parts.pop());
          const itemId = parts.join('_');

          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const item = safariData[context.guildId]?.items?.[itemId];
          const modifier = item?.attributeModifiers?.[modifierIndex];
          const attributeDefs = safariData[context.guildId]?.attributeDefinitions || {};
          const attrDef = attributeDefs[modifier?.attributeId] || {};

          return {
            type: InteractionResponseType.MODAL,
            data: {
              custom_id: `modal_item_attr_edit_${itemId}_${modifierIndex}`,
              title: `Edit ${attrDef.name || modifier?.attributeId || 'Attribute'} Bonus`,
              components: [
                {
                  type: 1,
                  components: [{
                    type: 4,
                    custom_id: 'bonus_value',
                    label: 'New Bonus Amount',
                    style: 1,
                    value: String(modifier?.value || ''),
                    required: true,
                    max_length: 4
                  }]
                },
                {
                  type: 1,
                  components: [{
                    type: 4,
                    custom_id: 'bonus_operation',
                    label: 'Operation (add or addMax)',
                    style: 1,
                    value: modifier?.operation || 'add',
                    required: true,
                    max_length: 10
                  }]
                }
              ]
            }
          };
        }
      })(req, res, client);

    } else if (custom_id.startsWith('item_attr_remove_')) {
      // Remove modifier
      return ButtonHandlerFactory.create({
        id: 'item_attr_remove',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const parts = context.customId.replace('item_attr_remove_', '').split('_');
          const modifierIndex = parseInt(parts.pop());
          const itemId = parts.join('_');

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const item = safariData[context.guildId]?.items?.[itemId];

          if (!item || !item.attributeModifiers) {
            return { components: [{ type: 17, components: [{ type: 10, content: '‚ùå Item or modifier not found.' }] }] };
          }

          const removed = item.attributeModifiers.splice(modifierIndex, 1)[0];
          await saveSafariContent(safariData);

          const attributeDefs = safariData[context.guildId]?.attributeDefinitions || {};
          const attrDef = attributeDefs[removed?.attributeId] || {};

          return {
            components: [{
              type: 17,
              components: [
                { type: 10, content: `‚úÖ **Removed ${attrDef.emoji || 'üìä'} ${attrDef.name || removed?.attributeId} bonus from ${item.name}.**` },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back to Stats', style: 1 }] }
              ]
            }]
          };
        }
      })(req, res, client);

    } else if (custom_id.startsWith('entity_custom_action_list_') || custom_id === 'entity_custom_action_list_global') {
      // Handle custom action selection from dropdown (coordinate-specific or global)
      return ButtonHandlerFactory.create({
        id: 'entity_custom_action_list',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: entity_custom_action_list - user ${context.userId}`);
          
          const selectedValue = context.values[0];
          
          // Parse coordinate and mapId if present
          let coordinate = null;
          let mapId = null;
          if (context.customId !== 'entity_custom_action_list_global') {
            // Parse: entity_custom_action_list_{coordinate}_{mapId}
            const parts = context.customId.replace('entity_custom_action_list_', '').split('_');
            coordinate = parts[0];
            mapId = parts[1];
          }
          
          if (selectedValue === 'back_to_all') {
            // Return to full action list
            const { createCustomActionSelectionUI } = await import('./customActionUI.js');
            
            const ui = await createCustomActionSelectionUI({
              guildId: context.guildId,
              coordinate: coordinate,
              mapId: mapId
            });
            
            return {
              ...ui,
              ephemeral: true
            };
          } else if (selectedValue === 'search_actions') {
            // Show search modal for custom actions
            const modalCustomId = coordinate ? 
              `custom_action_search_modal_${coordinate}_${mapId}` : 
              'custom_action_search_modal_global';
            
            return {
              type: InteractionResponseType.MODAL,
              data: {
                title: 'Search Custom Actions',
                custom_id: modalCustomId,
                components: [{
                  type: 1, // ActionRow
                  components: [{
                    type: 4, // Text Input
                    custom_id: 'search_term',
                    label: 'Search Term',
                    style: 1, // Short
                    placeholder: 'Enter action name or description...',
                    required: true,
                    max_length: 50
                  }]
                }]
              }
            };
          } else if (selectedValue === 'create_new') {
            // Show creation modal using standard factory pattern
            const modalCustomId = coordinate ? 
              `entity_create_modal_safari_button_info_${coordinate}` : 
              'global_create_modal_safari_button_info';
            const modal = {
              custom_id: modalCustomId,
              title: 'Create Custom Action',
              components: [
                {
                  type: 18, // Label
                  label: 'Action Name',
                  description: 'If the action type is Button Click, this will be the text on the button.',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'button_label',
                    style: 1, // Short
                    placeholder: 'e.g., "Start Adventure"',
                    required: true,
                    max_length: 80
                  }
                },
                {
                  type: 18, // Label
                  label: 'Action Emoji (Optional)',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'button_emoji',
                    style: 1, // Short
                    placeholder: 'e.g., üó∫Ô∏è',
                    required: false,
                    max_length: 100
                  }
                },
                {
                  type: 18, // Label
                  label: 'Action Description',
                  component: {
                    type: 4, // Text Input
                    custom_id: 'button_description',
                    style: 2, // Paragraph
                    placeholder: 'e.g., "Starts the jungle adventure safari"',
                    required: false
                  }
                }
              ]
            };

            console.log(`‚úÖ SUCCESS: entity_custom_action_list - showing creation modal`);
            return {
              type: InteractionResponseType.MODAL,
              data: modal
            };
          } else if (selectedValue === 'clone_action') {
            // Show clone source selection UI
            const { createCloneSourceSelectionUI } = await import('./customActionUI.js');
            const ui = await createCloneSourceSelectionUI({
              guildId: context.guildId,
              coordinate,
              mapId
            });

            console.log(`‚úÖ SUCCESS: entity_custom_action_list - showing clone source selection`);
            return ui;
          } else {
            // Edit existing action
            const { createCustomActionEditorUI } = await import('./customActionUI.js');
            const ui = await createCustomActionEditorUI({
              guildId: context.guildId,
              actionId: selectedValue,
              coordinate // will be null for global mode
            });
            
            console.log(`‚úÖ SUCCESS: entity_custom_action_list - showing action editor for ${selectedValue}`);
            return ui;
          }
        }
      })(req, res, client);

    } else if (custom_id.startsWith('entity_clone_source_list_') || custom_id === 'entity_clone_source_list_global') {
      // Handle clone source selection from dropdown
      return ButtonHandlerFactory.create({
        id: 'entity_clone_source_list',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîÑ START: entity_clone_source_list - user ${context.userId}`);

          const selectedValue = context.values[0];

          // Parse coordinate and mapId if present
          let coordinate = null;
          let mapId = null;
          if (context.customId !== 'entity_clone_source_list_global') {
            // Parse: entity_clone_source_list_{coordinate}_{mapId}
            const parts = context.customId.replace('entity_clone_source_list_', '').split('_');
            coordinate = parts[0];
            mapId = parts[1];
          }

          if (selectedValue === 'back_to_all') {
            // Return to main action list
            const { createCustomActionSelectionUI } = await import('./customActionUI.js');
            const ui = await createCustomActionSelectionUI({
              guildId: context.guildId,
              coordinate,
              mapId
            });

            console.log(`‚úÖ SUCCESS: entity_clone_source_list - returning to main list`);
            return ui;
          }

          // User selected an action to clone - show clone modal
          const { loadSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const sourceAction = allSafariContent[context.guildId]?.buttons?.[selectedValue];

          if (!sourceAction) {
            return {
              content: '‚ùå Source action not found.',
              ephemeral: true
            };
          }

          // Build modal with pre-filled values from source action
          const modalCustomId = coordinate
            ? `clone_action_modal_${selectedValue}_${coordinate}`
            : `clone_action_modal_${selectedValue}_global`;

          const modal = new ModalBuilder()
            .setCustomId(modalCustomId)
            .setTitle('Clone Action');

          // Pre-fill name with source action name
          const nameInput = new TextInputBuilder()
            .setCustomId('clone_name')
            .setLabel('Action Name')
            .setPlaceholder('Enter name for the cloned action')
            .setStyle(TextInputStyle.Short)
            .setValue(`${sourceAction.name || 'Unnamed'}`.substring(0, 80))
            .setRequired(true)
            .setMaxLength(80);

          // Pre-fill emoji from source
          const sourceEmoji = typeof sourceAction.emoji === 'string'
            ? sourceAction.emoji
            : (sourceAction.emoji?.name || sourceAction.trigger?.button?.emoji || '');
          const emojiInput = new TextInputBuilder()
            .setCustomId('clone_emoji')
            .setLabel('Action Emoji (Optional)')
            .setPlaceholder('e.g., üó∫Ô∏è')
            .setStyle(TextInputStyle.Short)
            .setValue(sourceEmoji)
            .setRequired(false)
            .setMaxLength(100);

          // Pre-fill description from source
          const descInput = new TextInputBuilder()
            .setCustomId('clone_description')
            .setLabel('Action Description')
            .setPlaceholder('Description for the cloned action')
            .setStyle(TextInputStyle.Paragraph)
            .setValue(sourceAction.description || '')
            .setRequired(false)
            .setMaxLength(4000);

          modal.addComponents(
            new ActionRowBuilder().addComponents(nameInput),
            new ActionRowBuilder().addComponents(emojiInput),
            new ActionRowBuilder().addComponents(descInput)
          );

          console.log(`‚úÖ SUCCESS: entity_clone_source_list - showing clone modal for ${selectedValue}`);
          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);

    } else if (custom_id.startsWith('entity_custom_action_edit_') && !custom_id.includes('_info_')) {
      // Handle back to action editor button
      return ButtonHandlerFactory.create({
        id: 'entity_custom_action_edit',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: entity_custom_action_edit - user ${context.userId}`);
          
          const actionId = context.customId.replace('entity_custom_action_edit_', '');
          
          // Return to custom action editor
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          const ui = await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId: actionId
          });
          
          console.log(`‚úÖ SUCCESS: entity_custom_action_edit - showing action editor for ${actionId}`);
          return ui;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('entity_custom_action_edit_info_')) {
      // Handle edit action info button
      return ButtonHandlerFactory.create({
        id: 'entity_custom_action_edit_info',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üìù START: entity_custom_action_edit_info - user ${context.userId}`);
          
          const actionId = context.customId.replace('entity_custom_action_edit_info_', '');
          
          // Load action data to pre-fill modal
          const { loadSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const action = allSafariContent[context.guildId]?.buttons?.[actionId];
          
          if (!action) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }
          
          // Create modal with pre-filled values (Label format - Components V2)
          const modal = {
            custom_id: `entity_edit_action_info_modal_${actionId}`,
            title: 'Edit Action Info',
            components: [
              {
                type: 18, // Label
                label: 'Action Name',
                description: 'If the action type is Button Click, this will be the text on the button.',
                component: {
                  type: 4, // Text Input
                  custom_id: 'action_name',
                  style: 1, // Short
                  placeholder: 'e.g., "Start Adventure"',
                  required: true,
                  max_length: 80,
                  ...(action.name ? { value: action.name } : {})
                }
              },
              {
                type: 18, // Label
                label: 'Action Emoji (Optional)',
                component: {
                  type: 4, // Text Input
                  custom_id: 'action_emoji',
                  style: 1, // Short
                  placeholder: 'e.g., üó∫Ô∏è or <:custom:123456>',
                  required: false,
                  max_length: 100,
                  ...(action.emoji ? { value: typeof action.emoji === 'string' ? action.emoji : (action.emoji?.name || '') } : {})
                }
              },
              {
                type: 18, // Label
                label: 'Action Description',
                component: {
                  type: 4, // Text Input
                  custom_id: 'action_description',
                  style: 2, // Paragraph
                  placeholder: 'e.g., "Begin your journey through the forest"',
                  required: false,
                  max_length: 4000,
                  ...(action.description ? { value: action.description } : {})
                }
              }
            ]
          };

          console.log(`‚úÖ SUCCESS: entity_custom_action_edit_info - showing edit modal for ${actionId}`);
          return {
            type: InteractionResponseType.MODAL,
            data: modal
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('entity_action_trigger_')) {
      // Handle trigger configuration button
      return ButtonHandlerFactory.create({
        id: 'entity_action_trigger',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: entity_action_trigger - user ${context.userId}`);
          
          const actionId = context.customId.replace('entity_action_trigger_', '');
          const { createTriggerConfigUI } = await import('./customActionUI.js');
          
          const ui = await createTriggerConfigUI({
            guildId: context.guildId,
            actionId
          });
          
          console.log(`‚úÖ SUCCESS: entity_action_trigger - showing trigger config`);
          return {
            ...ui,
            ephemeral: true // This will dismiss the Custom Action Editor and show trigger config privately
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('entity_action_conditions_')) {
      // Legacy conditions handler - kept for backward compatibility
      return ButtonHandlerFactory.create({
        id: 'entity_action_conditions',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: entity_action_conditions - user ${context.userId}`);
          
          const actionId = context.customId.replace('entity_action_conditions_', '');
          const { createConditionsConfigUI } = await import('./customActionUI.js');
          
          const ui = await createConditionsConfigUI({
            guildId: context.guildId,
            actionId
          });
          
          console.log(`‚úÖ SUCCESS: entity_action_conditions - showing conditions config`);
          return ui;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('condition_manager_')) {
      // New condition manager using Question Builder pattern
      return ButtonHandlerFactory.create({
        id: 'condition_manager',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_manager - user ${context.userId}`);
          
          // Parse custom_id: condition_manager_actionId_currentPage
          // The format is: condition_manager_<actionId>_<currentPage>
          // Where actionId might contain underscores, so we need to be careful
          const customIdParts = context.customId.split('_');
          
          // Remove 'condition' and 'manager' prefix
          customIdParts.shift(); // Remove 'condition'
          customIdParts.shift(); // Remove 'manager'
          
          // The last part is the page number
          const currentPage = parseInt(customIdParts.pop() || '0');
          
          // Everything else is the actionId (rejoin with underscores)
          const actionId = customIdParts.join('_');
          
          console.log(`üìù Parsed condition_manager: actionId="${actionId}", page=${currentPage}`);
          
          const { refreshConditionManagerUI } = await import('./customActionUI.js');
          
          await refreshConditionManagerUI({
            res,
            actionId,
            guildId: context.guildId,
            currentPage
          });
          
          console.log(`‚úÖ SUCCESS: condition_manager - displayed for action ${actionId} page ${currentPage}`);
          // Return undefined as response already sent
          return;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('condition_add_')) {
      // Add new condition handler
      return ButtonHandlerFactory.create({
        id: 'condition_add',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_add - user ${context.userId}`);
          
          // Parse custom_id: condition_add_actionId_currentPage
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // Remove 'condition'
          customIdParts.shift(); // Remove 'add'
          const currentPage = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          
          // Load action data
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const action = allSafariContent[context.guildId]?.buttons?.[actionId];
          
          if (!action) {
            throw new Error('Action not found');
          }
          
          // Ensure conditions is an array (legacy actions might have old structure)
          if (!Array.isArray(action.conditions)) {
            action.conditions = [];
          }
          
          // Create new condition with default values
          const newCondition = {
            id: `cond_${Date.now()}_${Math.random().toString(36).substr(2, 5)}`,
            type: 'currency', // Default type
            operator: 'gte',  // Default operator
            value: 0,         // Default value
            logic: 'AND'      // Default logic for next condition
          };
          
          // Add to conditions array
          action.conditions.push(newCondition);
          
          // Save updated action
          await saveSafariContent(allSafariContent);
          
          console.log(`‚úÖ SUCCESS: condition_add - added new condition to action ${actionId}`);
          
          // For now, redirect back to condition manager
          // TODO: Show condition editor for the new condition
          const { refreshConditionManagerUI } = await import('./customActionUI.js');
          
          // Calculate which page the new condition will be on
          const conditionsPerPage = 3;
          const newConditionPage = Math.floor((action.conditions.length - 1) / conditionsPerPage);
          
          await refreshConditionManagerUI({
            res,
            actionId,
            guildId: context.guildId,
            currentPage: newConditionPage
          });
          
          // Return undefined as response already sent
          return;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('condition_nav_next_')) {
      // Navigation next page handler
      return ButtonHandlerFactory.create({
        id: 'condition_nav_next',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_nav_next - user ${context.userId}`);
          
          // Parse custom_id: condition_nav_next_actionId_currentPage
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // Remove 'condition'
          customIdParts.shift(); // Remove 'nav'
          customIdParts.shift(); // Remove 'next'
          const currentPage = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          
          console.log(`üìÑ DEBUG: Navigating to next page from ${currentPage} for action ${actionId}`);
          
          const { refreshConditionManagerUI } = await import('./customActionUI.js');
          await refreshConditionManagerUI({
            res,
            actionId,
            guildId: context.guildId,
            currentPage: currentPage + 1
          });
          
          console.log(`‚úÖ SUCCESS: condition_nav_next - navigated to page ${currentPage + 1}`);
          return;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('condition_nav_prev_')) {
      // Navigation previous page handler
      return ButtonHandlerFactory.create({
        id: 'condition_nav_prev',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_nav_prev - user ${context.userId}`);
          
          // Parse custom_id: condition_nav_prev_actionId_currentPage
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // Remove 'condition'
          customIdParts.shift(); // Remove 'nav'
          customIdParts.shift(); // Remove 'prev'
          const currentPage = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          
          console.log(`üìÑ DEBUG: Navigating to previous page from ${currentPage} for action ${actionId}`);
          
          const { refreshConditionManagerUI } = await import('./customActionUI.js');
          await refreshConditionManagerUI({
            res,
            actionId,
            guildId: context.guildId,
            currentPage: Math.max(0, currentPage - 1)
          });
          
          console.log(`‚úÖ SUCCESS: condition_nav_prev - navigated to page ${Math.max(0, currentPage - 1)}`);
          return;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('condition_edit_')) {
      // Edit condition handler
      return ButtonHandlerFactory.create({
        id: 'condition_edit',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_edit - user ${context.userId}`);
          
          // Parse custom_id: condition_edit_actionId_conditionIndex_currentPage
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // Remove 'condition'
          customIdParts.shift(); // Remove 'edit'
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          
          console.log(`üìù Parsed condition_edit: actionId="${actionId}", conditionIndex=${conditionIndex}, page=${currentPage}`);
          
          const { showConditionEditor } = await import('./customActionUI.js');
          
          await showConditionEditor({
            res,
            actionId,
            conditionIndex,
            guildId: context.guildId,
            currentPage
          });
          
          console.log(`‚úÖ SUCCESS: condition_edit - showing editor for condition ${conditionIndex}`);
          // Return undefined as response already sent
          return;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('condition_delete_')) {
      // Delete condition handler
      return ButtonHandlerFactory.create({
        id: 'condition_delete',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_delete - user ${context.userId}`);
          
          // Parse custom_id: condition_delete_actionId_conditionIndex_currentPage
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // Remove 'condition'
          customIdParts.shift(); // Remove 'delete'
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          
          console.log(`üìù Parsed condition_delete: actionId="${actionId}", conditionIndex=${conditionIndex}, page=${currentPage}`);
          
          // Load action and validate
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const action = allSafariContent[context.guildId]?.buttons?.[actionId];
          
          if (!action || !action.conditions || conditionIndex < 0 || conditionIndex >= action.conditions.length) {
            console.error(`‚ùå Invalid condition delete: actionId=${actionId}, conditionIndex=${conditionIndex}`);
            return {
              content: '‚ùå Condition not found or invalid index.',
              ephemeral: true,
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }
          
          // Remove the condition from the array
          const deletedCondition = action.conditions[conditionIndex];
          action.conditions.splice(conditionIndex, 1);
          
          // Save changes
          await saveSafariContent(allSafariContent);
          
          console.log(`‚úÖ SUCCESS: condition_delete - removed condition ${conditionIndex}: ${deletedCondition.type}`);
          
          // Calculate which page to show after deletion
          const conditionsPerPage = 3;
          const totalConditions = action.conditions.length;
          const maxPage = Math.max(0, Math.ceil(totalConditions / conditionsPerPage) - 1);
          const targetPage = Math.min(currentPage, maxPage);
          
          // Refresh condition manager UI
          const { refreshConditionManagerUI } = await import('./customActionUI.js');
          await refreshConditionManagerUI({
            res,
            actionId,
            guildId: context.guildId,
            currentPage: targetPage
          });
          
          console.log(`‚úÖ SUCCESS: condition_delete - refreshed UI on page ${targetPage}`);
          // Return undefined as response already sent
          return;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('condition_currency_')) {
      // Handle currency operator toggle buttons
      return ButtonHandlerFactory.create({
        id: 'condition_currency_operator',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_currency_operator - user ${context.userId}`);
          
          // Parse custom_id: condition_currency_OPERATOR_actionId_conditionIndex_currentPage
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // Remove 'condition'
          customIdParts.shift(); // Remove 'currency'
          const operator = customIdParts.shift(); // Get operator (gte, lte, zero)
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          
          // Load and update condition
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          
          if (!condition) {
            throw new Error('Condition not found');
          }
          
          // Update operator
          condition.operator = operator === 'zero' ? 'eq_zero' : operator;
          
          // Save changes
          await saveSafariContent(allSafariContent);
          
          console.log(`‚úÖ SUCCESS: condition_currency_operator - changed to ${condition.operator}`);
          
          // Refresh condition editor
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({
            res,
            actionId,
            conditionIndex,
            guildId: context.guildId,
            currentPage
          });
          
          return;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('condition_set_currency_')) {
      // Handle currency amount setter modal
      return ButtonHandlerFactory.create({
        id: 'condition_set_currency',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: condition_set_currency - user ${context.userId}`);
          
          // Parse custom_id: condition_set_currency_actionId_conditionIndex_currentPage
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // Remove 'condition'
          customIdParts.shift(); // Remove 'set'
          customIdParts.shift(); // Remove 'currency'
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          
          // Show modal for currency amount
          const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = await import('discord.js');
          
          const modal = new ModalBuilder()
            .setCustomId(`condition_currency_modal_${actionId}_${conditionIndex}_${currentPage}`)
            .setTitle('Set Currency Amount');
            
          const amountInput = new TextInputBuilder()
            .setCustomId('currency_amount')
            .setLabel('Currency Amount')
            .setPlaceholder('Enter the amount to check against (e.g., 100)')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setValue('0');
            
          const actionRow = new ActionRowBuilder().addComponents(amountInput);
          modal.addComponents(actionRow);
          
          console.log(`‚úÖ SUCCESS: condition_set_currency - showing modal`);
          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('condition_has_') || custom_id.startsWith('condition_not_has_')) {
      // Handle has/not_has operator toggles for items and roles
      return ButtonHandlerFactory.create({
        id: 'condition_has_toggle',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_has_toggle - user ${context.userId}`);
          
          // Parse custom_id: condition_[has|not_has]_actionId_conditionIndex_currentPage_[item|role]
          const isHas = context.customId.startsWith('condition_has_');
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // Remove 'condition'
          customIdParts.shift(); // Remove 'has' or 'not'
          if (!isHas) customIdParts.shift(); // Remove 'has' from 'not_has'
          
          const conditionType = customIdParts.pop(); // Get 'item' or 'role'
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          
          // Load and update condition
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          
          if (!condition) {
            throw new Error('Condition not found');
          }
          
          // Update operator
          condition.operator = isHas ? 'has' : 'not_has';
          
          // Save changes
          await saveSafariContent(allSafariContent);
          
          console.log(`‚úÖ SUCCESS: condition_has_toggle - changed to ${condition.operator}`);
          
          // Refresh condition editor
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({
            res,
            actionId,
            conditionIndex,
            guildId: context.guildId,
            currentPage
          });
          
          return;
        }
      })(req, res, client);

    // ========== ATTRIBUTE CONDITION HANDLERS ==========

    } else if (custom_id.startsWith('condition_attr_select_')) {
      // Handle attribute selection for attribute_check condition
      return ButtonHandlerFactory.create({
        id: 'condition_attr_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_attr_select - user ${context.userId}`);

          // Parse custom_id: condition_attr_select_actionId_conditionIndex_currentPage
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // condition
          customIdParts.shift(); // attr
          customIdParts.shift(); // select
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          const selectedAttributeId = context.values[0];

          // Load and update condition
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];

          if (!condition) {
            throw new Error('Condition not found');
          }

          // Initialize config if needed
          if (!condition.config) {
            condition.config = { comparison: 'gte', target: 'current', value: 0 };
          }
          condition.config.attributeId = selectedAttributeId;

          await saveSafariContent(allSafariContent);
          console.log(`‚úÖ SUCCESS: condition_attr_select - selected ${selectedAttributeId}`);

          // Refresh UI
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_attr_target_')) {
      // Handle target selection (current/max/percent)
      return ButtonHandlerFactory.create({
        id: 'condition_attr_target',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_attr_target - user ${context.userId}`);

          // Parse custom_id: condition_attr_target_actionId_conditionIndex_currentPage_TARGET
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // condition
          customIdParts.shift(); // attr
          customIdParts.shift(); // target
          const targetType = customIdParts.pop(); // current, max, or percent
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          // Load and update condition
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];

          if (!condition?.config) {
            throw new Error('Condition config not found');
          }

          condition.config.target = targetType;
          await saveSafariContent(allSafariContent);
          console.log(`‚úÖ SUCCESS: condition_attr_target - set to ${targetType}`);

          // Refresh UI
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_attr_comp_')) {
      // Handle comparison operator selection (gte/lte/eq/gt/lt)
      return ButtonHandlerFactory.create({
        id: 'condition_attr_comp',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: condition_attr_comp - user ${context.userId}`);

          // Parse custom_id: condition_attr_comp_actionId_conditionIndex_currentPage_OPERATOR
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // condition
          customIdParts.shift(); // attr
          customIdParts.shift(); // comp
          const compOperator = customIdParts.pop(); // gte, lte, eq, gt, lt
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          // Load and update condition
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];

          if (!condition?.config) {
            throw new Error('Condition config not found');
          }

          condition.config.comparison = compOperator;
          await saveSafariContent(allSafariContent);
          console.log(`‚úÖ SUCCESS: condition_attr_comp - set to ${compOperator}`);

          // Refresh UI
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_attr_value_')) {
      // Open modal for value input
      return ButtonHandlerFactory.create({
        id: 'condition_attr_value',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: condition_attr_value - opening modal`);

          // Parse custom_id: condition_attr_value_actionId_conditionIndex_currentPage
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); // condition
          customIdParts.shift(); // attr
          customIdParts.shift(); // value
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          // Get current condition to show current value
          const { loadSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          const currentValue = condition?.config?.value || 0;
          const isPercent = condition?.config?.target === 'percent';

          const modal = new ModalBuilder()
            .setCustomId(`modal_condition_attr_value_${actionId}_${conditionIndex}_${currentPage}`)
            .setTitle(isPercent ? 'Set Percentage Value' : 'Set Attribute Value');

          const valueInput = new TextInputBuilder()
            .setCustomId('attr_value')
            .setLabel(isPercent ? 'Percentage (0-100)' : 'Value')
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMaxLength(10)
            .setValue(String(currentValue))
            .setPlaceholder(isPercent ? 'e.g. 50' : 'e.g. 20');

          modal.addComponents(new ActionRowBuilder().addComponents(valueInput));

          console.log(`‚úÖ SUCCESS: condition_attr_value - showing modal`);
          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_attr_itembonuses_')) {
      // Toggle include item bonuses for attribute_check
      return ButtonHandlerFactory.create({
        id: 'condition_attr_itembonuses',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_attr_itembonuses
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition?.config) throw new Error('Condition config not found');

          condition.config.includeItemBonuses = !condition.config.includeItemBonuses;
          await saveSafariContent(allSafariContent);

          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    // ========== ATTRIBUTE COMPARE CONDITION HANDLERS ==========

    } else if (custom_id.startsWith('condition_attrcomp_left_')) {
      // Handle left attribute selection for attribute_compare
      return ButtonHandlerFactory.create({
        id: 'condition_attrcomp_left',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_attrcomp_left
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          const selectedAttributeId = context.values[0];

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition) throw new Error('Condition not found');
          if (!condition.config) condition.config = { comparison: 'gte', leftTarget: 'current', rightTarget: 'current' };
          condition.config.leftAttributeId = selectedAttributeId;

          await saveSafariContent(allSafariContent);
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_attrcomp_lefttarget_')) {
      // Handle left target selection (current/max/percent)
      return ButtonHandlerFactory.create({
        id: 'condition_attrcomp_lefttarget',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_attrcomp_lefttarget
          const targetType = customIdParts.pop();
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition?.config) throw new Error('Condition config not found');
          condition.config.leftTarget = targetType;

          await saveSafariContent(allSafariContent);
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_attrcomp_comp_')) {
      // Handle comparison operator selection
      return ButtonHandlerFactory.create({
        id: 'condition_attrcomp_comp',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_attrcomp_comp
          const compOperator = customIdParts.pop();
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition?.config) throw new Error('Condition config not found');
          condition.config.comparison = compOperator;

          await saveSafariContent(allSafariContent);
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_attrcomp_right_')) {
      // Handle right attribute selection
      return ButtonHandlerFactory.create({
        id: 'condition_attrcomp_right',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_attrcomp_right
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          const selectedAttributeId = context.values[0];

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition?.config) throw new Error('Condition config not found');
          condition.config.rightAttributeId = selectedAttributeId;

          await saveSafariContent(allSafariContent);
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_attrcomp_righttarget_')) {
      // Handle right target selection (current/max/percent)
      return ButtonHandlerFactory.create({
        id: 'condition_attrcomp_righttarget',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_attrcomp_righttarget
          const targetType = customIdParts.pop();
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition?.config) throw new Error('Condition config not found');
          condition.config.rightTarget = targetType;

          await saveSafariContent(allSafariContent);
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_attrcomp_itembonuses_')) {
      // Toggle include item bonuses for attribute_compare
      return ButtonHandlerFactory.create({
        id: 'condition_attrcomp_itembonuses',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_attrcomp_itembonuses
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition?.config) throw new Error('Condition config not found');

          condition.config.includeItemBonuses = !condition.config.includeItemBonuses;
          await saveSafariContent(allSafariContent);

          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    // ========== MULTI-ATTRIBUTE CONDITION HANDLERS ==========

    } else if (custom_id.startsWith('condition_multiattr_mode_')) {
      // Handle mode selection (all/any/sum/average)
      return ButtonHandlerFactory.create({
        id: 'condition_multiattr_mode',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_multiattr_mode
          const modeValue = customIdParts.pop();
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition?.config) throw new Error('Condition config not found');
          condition.config.mode = modeValue;

          await saveSafariContent(allSafariContent);
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_multiattr_attrs_')) {
      // Handle attribute selection (multi-select)
      return ButtonHandlerFactory.create({
        id: 'condition_multiattr_attrs',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_multiattr_attrs
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');
          const selectedAttributes = context.values; // Array of selected values

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition?.config) throw new Error('Condition config not found');
          condition.config.attributes = selectedAttributes;

          await saveSafariContent(allSafariContent);
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_multiattr_comp_')) {
      // Handle comparison operator selection
      return ButtonHandlerFactory.create({
        id: 'condition_multiattr_comp',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_multiattr_comp
          const compOperator = customIdParts.pop();
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition?.config) throw new Error('Condition config not found');
          condition.config.comparison = compOperator;

          await saveSafariContent(allSafariContent);
          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_multiattr_value_')) {
      // Open modal for value input
      return ButtonHandlerFactory.create({
        id: 'condition_multiattr_value',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_multiattr_value
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          const { loadSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          const currentValue = condition?.config?.value || 0;

          const modal = new ModalBuilder()
            .setCustomId(`modal_condition_multiattr_value_${actionId}_${conditionIndex}_${currentPage}`)
            .setTitle('Set Multi-Attribute Threshold');

          const valueInput = new TextInputBuilder()
            .setCustomId('multiattr_value')
            .setLabel('Threshold Value')
            .setStyle(1) // Short
            .setRequired(true)
            .setMaxLength(10)
            .setValue(String(currentValue))
            .setPlaceholder('e.g. 50 for sum, 10 for all/any');

          modal.addComponents(new ActionRowBuilder().addComponents(valueInput));

          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_multiattr_itembonuses_')) {
      // Toggle include item bonuses for multi_attribute_check
      return ButtonHandlerFactory.create({
        id: 'condition_multiattr_itembonuses',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const customIdParts = context.customId.split('_');
          customIdParts.shift(); customIdParts.shift(); customIdParts.shift(); // condition_multiattr_itembonuses
          const currentPage = parseInt(customIdParts.pop() || '0');
          const conditionIndex = parseInt(customIdParts.pop() || '0');
          const actionId = customIdParts.join('_');

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const condition = allSafariContent[context.guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
          if (!condition?.config) throw new Error('Condition config not found');

          condition.config.includeItemBonuses = !condition.config.includeItemBonuses;
          await saveSafariContent(allSafariContent);

          const { showConditionEditor } = await import('./customActionUI.js');
          await showConditionEditor({ res, actionId, conditionIndex, guildId: context.guildId, currentPage });
          return;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('condition_item_select_')) {
      // Handle item selection for condition
      const selectedItemId = data.values[0];
      
      // Parse custom_id: condition_item_select_actionId_conditionIndex_currentPage
      const customIdParts = custom_id.split('_');
      customIdParts.shift(); // Remove 'condition'
      customIdParts.shift(); // Remove 'item'
      customIdParts.shift(); // Remove 'select'
      const currentPage = parseInt(customIdParts.pop() || '0');
      const conditionIndex = parseInt(customIdParts.pop() || '0');
      const actionId = customIdParts.join('_');
      
      // Handle search trigger
      if (selectedItemId === 'search_items') {
        console.log(`üîç SEARCH: condition_item_select - showing search modal`);
        
        const { ModalBuilder, TextInputBuilder, ActionRowBuilder } = await import('discord.js');
        
        const modal = new ModalBuilder()
          .setCustomId(`condition_item_search_modal_${actionId}_${conditionIndex}_${currentPage}`)
          .setTitle('Search Items');
        
        const searchInput = new TextInputBuilder()
          .setCustomId('search_term')
          .setLabel('Search for items...')
          .setStyle(1) // Short
          .setPlaceholder('Enter item name')
          .setRequired(true);
        
        modal.addComponents(new ActionRowBuilder().addComponents(searchInput));
        
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal.toJSON()
        });
      }
      
      // Handle no results (matching Safari behavior)
      if (selectedItemId === 'no_results') {
        console.log(`‚ÑπÔ∏è INFO: condition_item_select - user selected no_results, ignoring gracefully`);
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            components: [] // Keep existing message but remove components
          }
        });
      }
      
      // Load and update condition
      const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
      const allSafariContent = await loadSafariContent();
      const condition = allSafariContent[req.body.guild_id]?.buttons?.[actionId]?.conditions?.[conditionIndex];
      
      if (!condition) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Condition not found.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
      // Update item ID
      condition.itemId = selectedItemId;
      
      // Save changes
      await saveSafariContent(allSafariContent);
      
      console.log(`‚úÖ SUCCESS: condition_item_select - selected item ${selectedItemId}`);
      
      // Refresh condition editor
      const { showConditionEditor } = await import('./customActionUI.js');
      await showConditionEditor({
        res,
        actionId,
        conditionIndex,
        guildId: req.body.guild_id,
        currentPage
      });
      
    } else if (custom_id.startsWith('condition_role_select_')) {
      // Handle role selection for condition
      const selectedRoleId = data.values[0];
      
      // Parse custom_id: condition_role_select_actionId_conditionIndex_currentPage
      const customIdParts = custom_id.split('_');
      customIdParts.shift(); // Remove 'condition'
      customIdParts.shift(); // Remove 'role'
      customIdParts.shift(); // Remove 'select'
      const currentPage = parseInt(customIdParts.pop() || '0');
      const conditionIndex = parseInt(customIdParts.pop() || '0');
      const actionId = customIdParts.join('_');
      
      // Load and update condition
      const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
      const allSafariContent = await loadSafariContent();
      const condition = allSafariContent[req.body.guild_id]?.buttons?.[actionId]?.conditions?.[conditionIndex];
      
      if (!condition) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Condition not found.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
      // Update role ID
      condition.roleId = selectedRoleId;
      
      // Save changes
      await saveSafariContent(allSafariContent);
      
      console.log(`‚úÖ SUCCESS: condition_role_select - selected role ${selectedRoleId}`);
      
      // Refresh condition editor
      const { showConditionEditor } = await import('./customActionUI.js');
      await showConditionEditor({
        res,
        actionId,
        conditionIndex,
        guildId: req.body.guild_id,
        currentPage
      });
      
    } else if (custom_id.startsWith('entity_action_coords_')) {
      // Handle coordinates configuration button
      return ButtonHandlerFactory.create({
        id: 'entity_action_coords',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: entity_action_coords - user ${context.userId}`);
          
          const actionId = context.customId.replace('entity_action_coords_', '');
          const { createCoordinateManagementUI } = await import('./customActionUI.js');
          
          const ui = await createCoordinateManagementUI({
            guildId: context.guildId,
            actionId
          });
          
          console.log(`‚úÖ SUCCESS: entity_action_coords - showing coordinate management UI`);
          return ui;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('entity_action_post_channel_select_')) {
      // Channel select handler: post custom action button to selected channel
      try {
        const guildId = req.body.guild_id;
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to post actions.')) return;

        const actionId = custom_id.replace('entity_action_post_channel_select_', '');
        const selectedChannelId = req.body.data.values[0];

        const { loadSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const action = safariData[guildId]?.buttons?.[actionId];

        if (!action) {
          return res.send({ type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE, data: { content: '‚ùå Action not found.', flags: InteractionResponseFlags.EPHEMERAL } });
        }

        // Build channel card: Container with action info + button
        const channelCard = {
          type: 17, // Container
          accent_color: 0x3498db,
          components: [
            { type: 10, content: `## ${action.emoji || '‚ö°'} ${action.name || action.label || 'Custom Action'}` },
            { type: 14 },
            {
              type: 1, // Action Row
              components: [{
                type: 2, // Button
                custom_id: `safari_${guildId}_${actionId}`,
                label: action.name || action.label || 'Activate',
                style: (() => {
                  const styleMap = { 'Primary': 1, 'Secondary': 2, 'Success': 3, 'Danger': 4 };
                  return styleMap[action.trigger?.button?.style] || action.style || 1;
                })(),
                ...(action.emoji ? { emoji: { name: action.emoji } } : {})
              }]
            }
          ]
        };

        await DiscordRequest(`channels/${selectedChannelId}/messages`, {
          method: 'POST',
          body: { flags: (1 << 15), components: [channelCard] }
        });

        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            flags: (1 << 15),
            components: [{
              type: 17,
              accent_color: 0x27ae60, // Green
              components: [
                { type: 10, content: `## ‚úÖ Action Posted!\n\n**${action.emoji || '‚ö°'} ${action.name || action.label}** has been posted to <#${selectedChannelId}>.` },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: `entity_action_coords_${actionId}`, label: '‚Üê Back', style: 2 }] }
              ]
            }]
          }
        });
      } catch (error) {
        console.error('Error posting custom action to channel:', error);
        return res.send({ type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE, data: { content: '‚ùå Error posting action. Please try again.', flags: InteractionResponseFlags.EPHEMERAL } });
      }

    } else if (custom_id.startsWith('entity_action_post_channel_')) {
      // Show channel select UI for posting custom action button
      return ButtonHandlerFactory.create({
        id: 'entity_action_post_channel',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const actionId = context.customId.replace('entity_action_post_channel_', '');
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const action = safariData[context.guildId]?.buttons?.[actionId];

          if (!action) return { content: '‚ùå Action not found.' };

          return {
            flags: (1 << 15),
            components: [{
              type: 17,
              accent_color: 0x3498db,
              components: [
                { type: 10, content: `## Post to Channel\n\n**${action.emoji || '‚ö°'} ${action.name || action.label || 'Custom Action'}**\n\nSelect a channel to post this action button to.` },
                { type: 14 },
                { type: 1, components: [{ type: 8, custom_id: `entity_action_post_channel_select_${actionId}`, placeholder: 'Select channel...', channel_types: [0, 5] }] },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: `entity_action_coords_${actionId}`, label: '‚Üê Back', style: 2 }] }
              ]
            }]
          };
        }
      })(req, res, client);

    } else if (custom_id.startsWith('menu_visibility_select_')) {
      // Handle menu visibility String Select for Custom Actions
      return ButtonHandlerFactory.create({
        id: 'menu_visibility_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const actionId = context.customId.replace('menu_visibility_select_', '');
          const selectedValue = req.body.data.values?.[0] || 'none';
          console.log(`üìã START: menu_visibility_select - user ${context.userId} setting action ${actionId} to ${selectedValue}`);

          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();

          // Get the action
          const action = safariData[context.guildId]?.buttons?.[actionId];
          if (!action) {
            return {
              content: '‚ùå Action not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }

          // Set the menuVisibility field
          action.menuVisibility = selectedValue;
          // Also clear legacy field to avoid confusion
          delete action.showInInventory;
          await saveSafariContent(safariData);

          // Count actions per menu type for warnings
          const allButtons = safariData[context.guildId]?.buttons || {};
          const playerMenuCount = Object.values(allButtons).filter(a => {
            const vis = a.menuVisibility || (a.showInInventory ? 'player_menu' : 'none');
            return vis === 'player_menu';
          }).length;
          const craftingMenuCount = Object.values(allButtons).filter(a => a.menuVisibility === 'crafting_menu').length;

          console.log(`‚úÖ SUCCESS: menu_visibility_select - action ${actionId} menuVisibility=${selectedValue} (${playerMenuCount} player menu, ${craftingMenuCount} crafting)`);

          // Refresh the coordinate management UI
          const { createCoordinateManagementUI } = await import('./customActionUI.js');
          const ui = await createCoordinateManagementUI({
            guildId: context.guildId,
            actionId
          });

          // Add warning if many actions enabled for a menu
          const warningCount = selectedValue === 'player_menu' ? playerMenuCount : craftingMenuCount;
          if (warningCount >= 10 && selectedValue !== 'none') {
            const menuName = selectedValue === 'player_menu' ? 'Player Menu' : 'Crafting';
            const container = ui.components[0];
            if (container?.components) {
              container.components.splice(2, 0, {
                type: 10,
                content: `‚ö†Ô∏è **Warning:** ${warningCount} actions enabled for ${menuName}. Some actions may not appear due to Discord's 40-component limit.`
              });
            }
          }

          return ui;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('safari_crafting_menu_')) {
      // Handle Crafting Menu button from Player Inventory
      return ButtonHandlerFactory.create({
        id: 'safari_crafting_menu',
        updateMessage: true,
        handler: async (context) => {
          const parts = context.customId.split('_');
          const guildId = parts[3];
          const userId = parts[4];
          console.log(`üõ†Ô∏è START: safari_crafting_menu - user ${context.userId} opening crafting menu`);

          const { createCraftingMenuUI } = await import('./safariManager.js');
          const ui = await createCraftingMenuUI(guildId, userId);

          console.log(`‚úÖ SUCCESS: safari_crafting_menu - showing crafting menu`);
          return ui;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('custom_action_editor_')) {
      // Handle back button from coordinate management to action editor
      return ButtonHandlerFactory.create({
        id: 'custom_action_editor',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: custom_action_editor - user ${context.userId}`);
          
          const actionId = context.customId.replace('custom_action_editor_', '');
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          
          const ui = await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId
          });
          
          console.log(`‚úÖ SUCCESS: custom_action_editor - showing action editor for ${actionId}`);
          return ui;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('custom_action_add_condition_')) {
      // Handle add condition button
      return ButtonHandlerFactory.create({
        id: 'custom_action_add_condition',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: custom_action_add_condition - user ${context.userId}`);
          
          const actionId = context.customId.replace('custom_action_add_condition_', '');
          
          // TODO: Implement add condition modal
          console.log(`‚úÖ SUCCESS: custom_action_add_condition - condition adding not yet implemented`);
          return {
            content: 'üöß **Add Condition**\n\nThis feature is coming soon! You\'ll be able to add conditions like "Has Item", "Has Currency", etc.',
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('custom_action_remove_condition_')) {
      // Handle remove condition button
      return ButtonHandlerFactory.create({
        id: 'custom_action_remove_condition',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: custom_action_remove_condition - user ${context.userId}`);
          
          const actionId = context.customId.replace('custom_action_remove_condition_', '');
          
          // TODO: Implement remove condition logic
          console.log(`‚úÖ SUCCESS: custom_action_remove_condition - condition removal not yet implemented`);
          return {
            content: 'üöß **Remove Condition**\n\nThis feature is coming soon!',
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('custom_action_test_')) {
      // Handle test action button with deferred response (actions can take >3s)
      return ButtonHandlerFactory.create({
        id: 'custom_action_test',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        deferred: true, // Required - executeButtonActions can run slow operations (calculate_results, calculate_attack, Discord API calls)
        handler: async (context) => {
          console.log(`üîç START: custom_action_test - user ${context.userId}`);
          
          const actionId = context.customId.replace('custom_action_test_', '');
          
          // Load the action/button data
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const button = safariData[context.guildId]?.buttons?.[actionId];
          
          if (!button) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }
          
          if (!button.actions || button.actions.length === 0) {
            return {
              content: '‚ùå This button has no actions configured yet.',
              ephemeral: true
            };
          }
          
          // Simulate the safari button click by creating a fake safari button custom_id
          const simulatedCustomId = `safari_${context.guildId}_${actionId}_${Date.now()}`;
          
          console.log(`üß™ Testing action ${actionId} with simulated custom_id: ${simulatedCustomId}`);
          
          // Process the safari button actions
          const { executeButtonActions } = await import('./safariManager.js');
          
          // Create a proper interaction object with token for follow-up messages
          const interactionData = {
            token: context.token,
            applicationId: context.applicationId,
            client: client,
            member: context.member, // Add member data for role operations
            channelName: context.channelName || 'Unknown' // Add channel name for logging
          };

          const result = await executeButtonActions(
            context.guildId,
            actionId,
            context.userId,
            interactionData, // Pass proper interaction data with token
            client
          );
          
          console.log(`‚úÖ SUCCESS: custom_action_test - tested ${actionId}`);
          
          // Return the result, ensuring it's ephemeral
          if (result) {
            return {
              ...result,
              flags: InteractionResponseFlags.EPHEMERAL
            };
          } else {
            return {
              content: '‚úÖ Test completed successfully!',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('custom_action_delete_confirm_')) {
      // Handle delete confirmation - actually delete the action
      return ButtonHandlerFactory.create({
        id: 'custom_action_delete_confirm',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        deferred: true, // Long-running operation with anchor updates
        handler: async (context) => {
          console.log(`üîç START: custom_action_delete_confirm - user ${context.userId}`);
          
          const actionId = context.customId.replace('custom_action_delete_confirm_', '');
          
          // Load and modify safari data
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const action = safariData[context.guildId]?.buttons?.[actionId];
          
          if (!action) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }
          
          const actionName = action.name || action.label || 'Unnamed Action';
          const coordinates = action.coordinates || [];
          
          // Remove action from all coordinate assignments
          const activeMapId = safariData[context.guildId]?.maps?.active;
          if (activeMapId && coordinates.length > 0) {
            for (const coord of coordinates) {
              const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
              if (coordData && coordData.buttons) {
                coordData.buttons = coordData.buttons.filter(buttonId => buttonId !== actionId);
              }
            }
          }
          
          // Clean up any follow-up button references to this action
          console.log(`üîç Scanning for follow-up references to ${actionId}...`);
          let cleanupCount = 0;
          const brokenReferences = [];
          
          // Scan all buttons for follow-up actions that reference the deleted button
          const allButtons = safariData[context.guildId]?.buttons || {};
          Object.entries(allButtons).forEach(([buttonId, button]) => {
            if (button.actions && Array.isArray(button.actions)) {
              button.actions.forEach((action, index) => {
                if (action.type === 'follow_up_button' && 
                    action.config?.buttonId === actionId) {
                  console.log(`üîß Converting broken follow-up reference in button ${buttonId} action ${index}`);
                  
                  // Track where this broken reference is
                  const buttonName = button.name || button.label || buttonId;
                  const buttonCoords = button.coordinates || [];
                  brokenReferences.push({
                    buttonName,
                    buttonId,
                    coordinates: buttonCoords
                  });
                  
                  // Convert to error text display
                  button.actions[index] = {
                    type: 'display_text',
                    config: {
                      content: `‚ö†Ô∏è Referenced action "${actionName}" was deleted\n\n**To fix this:**\n1. Go to üìç Location Actions\n2. Click ‚ö° Custom Actions\n3. Delete this broken action`,
                      title: 'Broken Follow-Up - Please Delete'
                    }
                  };
                  cleanupCount++;
                }
              });
            }
          });
          
          if (cleanupCount > 0) {
            console.log(`‚úÖ Cleaned up ${cleanupCount} follow-up references`);
          }
          
          // Delete the action itself
          delete safariData[context.guildId].buttons[actionId];
          
          // Save changes
          await saveSafariContent(safariData);
          
          // Update anchor messages for affected coordinates
          if (coordinates.length > 0) {
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            for (const coord of coordinates) {
              try {
                await safeUpdateAnchorMessage(context.guildId, coord, context.client);
                console.log(`üìç Updated anchor message for ${coord} after deleting action`);
              } catch (error) {
                console.error(`Error updating anchor for ${coord}:`, error);
              }
            }
          }
          
          console.log(`‚úÖ SUCCESS: custom_action_delete_confirm - deleted ${actionId} from ${coordinates.length} coordinates, cleaned ${cleanupCount} follow-up references`);
          
          let successMessage = `‚úÖ **Action Deleted Successfully!**\n\n**"${actionName}"** has been removed from all locations and deleted permanently.`;
          
          if (cleanupCount > 0) {
            successMessage += `\n\n‚ö†Ô∏è **Follow-up References Found and Fixed:**\n`;
            successMessage += `${cleanupCount} broken follow-up action${cleanupCount > 1 ? 's' : ''} ${cleanupCount > 1 ? 'have' : 'has'} been converted to warning text.\n\n`;
            
            // Add specific locations of broken references
            successMessage += `**To complete the cleanup:**\n`;
            brokenReferences.forEach((ref, index) => {
              const coordsText = ref.coordinates.length > 0 ? ref.coordinates.join(', ') : 'No locations';
              successMessage += `‚Ä¢ **"${ref.buttonName}"** (at ${coordsText})\n`;
            });
            successMessage += `\nGo to üìç Location Actions ‚Üí ‚ö° Custom Actions ‚Üí Delete the broken action(s)`;
          }
          
          return {
            content: successMessage,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('custom_action_delete_cancel_')) {
      // Handle delete cancellation - return to editor
      return ButtonHandlerFactory.create({
        id: 'custom_action_delete_cancel',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const actionId = context.customId.replace('custom_action_delete_cancel_', '');
          
          // Return to the Custom Action Editor
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          const ui = await createCustomActionEditorUI({
            guildId: context.guildId,
            actionId: actionId
          });
          
          return ui;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('custom_action_up_')) {
      return ButtonHandlerFactory.create({
        id: 'custom_action_up',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: custom_action_up - user ${context.userId}`);
          const { guildId, userId } = context;

          // Extract actionId and actionIndex: custom_action_up_{actionId}_{actionIndex}
          const prefix = 'custom_action_up_';
          const remaining = context.customId.replace(prefix, '');
          const parts = remaining.split('_');
          const actionIndex = parseInt(parts.pop()); // Get index from end
          const actionId = parts.join('_'); // Join remaining as actionId

          console.log(`üîç DEBUG: Moving action up - Button: ${actionId}, Index: ${actionIndex}`);

          // Load Safari content
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const guildData = allSafariContent[guildId] || {};
          const button = guildData.buttons?.[actionId];

          if (!button || !button.actions || actionIndex < 0 || actionIndex >= button.actions.length) {
            return {
              content: '‚ùå Unable to reorder action.',
              ephemeral: true
            };
          }

          // Handle cycling: if first action, move to bottom
          if (actionIndex === 0) {
            // Move first action to the end
            const actionToMove = button.actions.shift();
            button.actions.push(actionToMove);
            console.log(`üîÑ DEBUG: Cycled first action to bottom`);
          } else {
            // Standard swap with previous action
            const temp = button.actions[actionIndex];
            button.actions[actionIndex] = button.actions[actionIndex - 1];
            button.actions[actionIndex - 1] = temp;
            console.log(`üîÑ DEBUG: Swapped action ${actionIndex} with ${actionIndex - 1}`);
          }

          await saveSafariContent(allSafariContent);

          console.log(`‚úÖ SUCCESS: custom_action_up - action reordered`);

          // Refresh Custom Action Editor UI
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          const ui = await createCustomActionEditorUI({
            guildId: guildId,
            actionId: actionId,
            coordinate: null,
            skipAutoSave: true
          });

          return ui;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('custom_action_delete_')) {
      // Handle delete action button with confirmation (MOST GENERAL - MUST BE LAST)
      return ButtonHandlerFactory.create({
        id: 'custom_action_delete',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: custom_action_delete - user ${context.userId}`);
          
          const actionId = context.customId.replace('custom_action_delete_', '');
          
          // Load the action data
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const action = safariData[context.guildId]?.buttons?.[actionId];
          
          if (!action) {
            return {
              content: '‚ùå Action not found.',
              ephemeral: true
            };
          }
          
          // Show confirmation dialog
          const actionName = action.name || action.label || 'Unnamed Action';
          const coordinateCount = action.coordinates?.length || 0;
          const confirmationText = `## ‚ö†Ô∏è Delete Custom Action\n\n**Action:** ${actionName}\n**Currently assigned to:** ${coordinateCount} location${coordinateCount !== 1 ? 's' : ''}\n\n**This action cannot be undone.** The action will be:\n‚Ä¢ Removed from all assigned locations\n‚Ä¢ Deleted permanently from the system\n‚Ä¢ Anchor messages will be updated\n\nAre you sure you want to continue?`;
          
          return {
            components: [{
              type: 17, // Container
              accent_color: 0xed4245, // Red for danger
              components: [
                {
                  type: 10, // Text Display
                  content: confirmationText
                },
                {
                  type: 1, // Action Row
                  components: [
                    {
                      type: 2, // Button
                      custom_id: `custom_action_delete_cancel_${actionId}`,
                      label: "Cancel",
                      style: 2, // Secondary
                      emoji: { name: "‚ùå" }
                    },
                    {
                      type: 2, // Button
                      custom_id: `custom_action_delete_confirm_${actionId}`,
                      label: "Yes, Delete Action",
                      style: 4, // Danger
                      emoji: { name: "üóëÔ∏è" }
                    }
                  ]
                }
              ]
            }],
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('remove_coord_')) {
      // Handle coordinate removal
      return ButtonHandlerFactory.create({
        id: 'remove_coord',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üîç START: remove_coord - user ${context.userId}`);
          
          try {
            // Parse: remove_coord_{actionId}_{coordinate}
            // Note: actionId can contain underscores, coordinate is always last part
            const parts = context.customId.replace('remove_coord_', '').split('_');
            const coordinate = parts[parts.length - 1]; // Last part is always coordinate
            const actionId = parts.slice(0, -1).join('_'); // Everything except last part is actionId
            console.log(`üîç DEBUG: remove_coord parsing - actionId: ${actionId}, coordinate: ${coordinate}`);
            
            // Load and update safari data
            const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
            const allSafariContent = await loadSafariContent();
            const guildData = allSafariContent[context.guildId] || {};
            const action = guildData.buttons?.[actionId];
            
            if (!action) {
              console.log(`‚ùå ERROR: remove_coord - action ${actionId} not found`);
              return {
                content: '‚ùå Action not found.',
                ephemeral: true
              };
            }
            
            console.log(`üîç DEBUG: remove_coord - action found, current coordinates: ${JSON.stringify(action.coordinates)}`);
            
            // Remove coordinate from action
            action.coordinates = (action.coordinates || []).filter(c => c !== coordinate);
            console.log(`üîç DEBUG: remove_coord - after filter, coordinates: ${JSON.stringify(action.coordinates)}`);
            
            // Also remove from map assignments
            for (const mapId in guildData.maps || {}) {
              const map = guildData.maps[mapId];
              if (map.coordinates?.[coordinate]?.buttons) {
                map.coordinates[coordinate].buttons = map.coordinates[coordinate].buttons.filter(b => b !== actionId);
                console.log(`üîç DEBUG: remove_coord - removed from map ${mapId} coord ${coordinate}`);
              }
            }
            
            console.log(`üîç DEBUG: remove_coord - saving safari content...`);
            await saveSafariContent(allSafariContent);
            console.log(`üîç DEBUG: remove_coord - safari content saved`);
            
            // Queue anchor message updates - update both the removed coordinate AND remaining coordinates
            try {
              const { queueActionCoordinateUpdates, queueAnchorUpdate } = await import('./anchorMessageManager.js');
              // Update the removed coordinate (won't be in action.coordinates anymore)
              queueAnchorUpdate(context.guildId, coordinate, { reason: 'action_removed', immediate: false });
              // Update remaining coordinates (if any)
              await queueActionCoordinateUpdates(context.guildId, actionId, 'coordinate_removed');
            } catch (error) {
              console.error('Error queueing anchor updates:', error);
            }
            
            // Return updated UI
            console.log(`üîç DEBUG: remove_coord - creating UI...`);
            const { createCoordinateManagementUI } = await import('./customActionUI.js');
            const ui = await createCoordinateManagementUI({
              guildId: context.guildId,
              actionId
            });
            console.log(`üîç DEBUG: remove_coord - UI created successfully`);
            
            console.log(`‚úÖ SUCCESS: remove_coord - removed ${coordinate} from action ${actionId}`);
            return ui;
          } catch (error) {
            console.error(`‚ùå ERROR: remove_coord failed:`, error);
            return {
              content: `‚ùå Error removing coordinate: ${error.message}`,
              ephemeral: true
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('add_coord_modal_')) {
      // Handle coordinate addition modal
      return ButtonHandlerFactory.create({
        id: 'add_coord_modal',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç START: add_coord_modal - user ${context.userId}`);
          
          const actionId = context.customId.replace('add_coord_modal_', '');
          
          // Return modal for coordinate input
          return {
            type: InteractionResponseType.MODAL,
            data: {
              custom_id: `add_coord_submit_${actionId}`,
              title: 'Add Coordinate',
              components: [{
                type: 1, // Action Row
                components: [{
                  type: 4, // Text Input
                  custom_id: 'coordinate',
                  label: 'Coordinate (e.g. A1, B3, D7)',
                  style: 1, // Short
                  required: true,
                  placeholder: 'Enter map coordinate...',
                  min_length: 2,
                  max_length: 10
                }]
              }]
            }
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('configure_modal_trigger_')) {
      // Handle modal trigger phrase configuration button
      try {
        const guildId = req.body.guild_id;
        const member = req.body.member;
        const actionId = custom_id.replace('configure_modal_trigger_', '');
        
        console.log(`üîç START: configure_modal_trigger - user ${member.user.id}`);
        
        // Check permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to configure actions.')) return;
        
        // Load current action data
        const { loadSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const action = safariData[guildId]?.buttons?.[actionId];
        
        if (!action) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Get current phrases
        const phrases = action.trigger?.phrases || [];
        
        console.log(`‚úÖ SUCCESS: configure_modal_trigger - showing modal for ${actionId}`);
        
        // Build first text input
        const firstInput = {
          type: 4, // Text Input
          custom_id: 'phrase_1',
          label: 'Secret Command Phrase',
          style: 1, // Short
          required: true,
          placeholder: 'Command required to activate the custom action',
          min_length: 1,
          max_length: 100
        };
        
        // Only add value if it exists
        if (phrases[0]) {
          firstInput.value = phrases[0];
        }
        
        // Send modal response directly
        return res.send({
          type: InteractionResponseType.MODAL,
          data: {
            custom_id: `modal_phrases_config_${actionId}`,
            title: 'Enter Secret Command Phrases',
            components: [
              {
                type: 1, // Action Row
                components: [firstInput]
              },
              {
                type: 1,
                components: [{
                  type: 4,
                  custom_id: 'phrase_2',
                  label: 'Alternative Command Phrase (Optional)',
                  style: 1,
                  required: false,
                  placeholder: 'Optional phrase that also activates the action',
                  ...(phrases[1] && { value: phrases[1] }),
                  max_length: 100
                }]
              },
              {
                type: 1,
                components: [{
                  type: 4,
                  custom_id: 'phrase_3',
                  label: 'Alternate Command Phrase 2 (Optional)',
                  style: 1,
                  required: false,
                  placeholder: 'Optional phrase that also activates the action',
                  ...(phrases[2] && { value: phrases[2] }),
                  max_length: 100
                }]
              },
              {
                type: 1,
                components: [{
                  type: 4,
                  custom_id: 'phrase_4',
                  label: 'Alternate Command Phrase 3 (Optional)',
                  style: 1,
                  required: false,
                  placeholder: 'Optional phrase that also activates the action',
                  ...(phrases[3] && { value: phrases[3] }),
                  max_length: 100
                }]
              },
              {
                type: 1,
                components: [{
                  type: 4,
                  custom_id: 'phrase_5',
                  label: 'Alternate Command Phrase 4 (Optional)',
                  style: 1,
                  required: false,
                  placeholder: 'Optional phrase that also activates the action',
                  ...(phrases[4] && { value: phrases[4] }),
                  max_length: 100
                }]
              }
            ]
          }
        });
        
      } catch (error) {
        console.error('Error in configure_modal_trigger handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error showing configuration modal.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('entity_edit_modal_')) {
      // Show modal for editing fields (legacy handler - should not be used)
      try {
        // Parse: entity_edit_modal_{entityType}_{entityId}_{fieldGroup}
        const withoutPrefix = custom_id.replace('entity_edit_modal_', '');
        const parts = withoutPrefix.split('_');
        const entityType = parts[0];
        const fieldGroup = parts[parts.length - 1]; // Last part is always fieldGroup
        const entityId = parts.slice(1, -1).join('_'); // Everything between is entityId
        const guildId = req.body.guild_id;
        
        console.log('üîç DEBUG: Modal handler - Type:', entityType, 'ID:', entityId, 'Group:', fieldGroup);
        
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES)) return;
        
        // Load current entity values
        const entity = await loadEntity(guildId, entityType, entityId);
        if (!entity) throw new Error('Entity not found');
        
        // Create modal
        const modal = createFieldGroupModal(entityType, entityId, fieldGroup, entity);
        if (!modal) {
          throw new Error('Invalid field group');
        }
        
        return res.send(modal);
        
      } catch (error) {
        console.error('Error showing edit modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error opening editor.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('entity_consumable_select_')) {
      // Handle consumable select for items
      try {
        const parts = custom_id.split('_');
        const entityType = parts[3];
        const entityId = parts.slice(4).join('_');
        const guildId = req.body.guild_id;
        const consumableValue = data.values[0];
        
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES)) return;
        
        // Update consumable field
        await updateEntityFields(guildId, entityType, entityId, {
          consumable: consumableValue
        });
        
        // Refresh UI
        const uiResponse = await createEntityManagementUI({
          entityType: entityType,
          guildId: guildId,
          selectedId: entityId,
          activeFieldGroup: null,
          searchTerm: '',
          mode: 'edit'
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: uiResponse
        });
        
      } catch (error) {
        console.error('Error updating consumable:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating consumable property.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('entity_defaultitem_select_')) {
      // Handle default item select for items
      try {
        const parts = custom_id.split('_');
        const entityType = parts[3];
        const entityId = parts.slice(4).join('_');
        const guildId = req.body.guild_id;
        const defaultItemValue = data.values[0];
        
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES)) return;
        
        // Use the Entity Manager to properly update the item
        const { updateEntityFields } = await import('./entityManager.js');
        
        // Update the metadata.defaultItem field
        const updates = {};
        if (defaultItemValue === 'Yes') {
          updates['metadata.defaultItem'] = 'Yes';
        } else {
          // To remove the field, we need to load and update the full entity
          const { loadEntity } = await import('./entityManager.js');
          const entity = await loadEntity(guildId, entityType, entityId);
          
          if (!entity) {
            throw new Error('Entity not found');
          }
          
          // Ensure metadata exists
          if (!entity.metadata) {
            entity.metadata = {};
          }
          
          // Remove the defaultItem field
          delete entity.metadata.defaultItem;
          
          // Use updateEntity to save the modified entity
          const { updateEntity } = await import('./entityManager.js');
          await updateEntity(guildId, entityType, entityId, entity);
        }
        
        // Only update if setting to Yes (for clean removal we handled above)
        if (defaultItemValue === 'Yes') {
          await updateEntityFields(guildId, entityType, entityId, updates);
        }
        
        // Refresh UI
        const { createEntityManagementUI } = await import('./entityManagementUI.js');
        const uiResponse = await createEntityManagementUI({
          entityType: entityType,
          guildId: guildId,
          selectedId: entityId,
          activeFieldGroup: null,
          searchTerm: '',
          mode: 'edit'
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: uiResponse
        });
        
      } catch (error) {
        console.error('Error updating default item:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating default item property.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('entity_delete_mode_')) {
      // Switch to delete confirmation mode (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'entity_delete_mode',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true, // Replace item editor with delete confirmation
        handler: async (context) => {
          const parts = context.customId.split('_');
          const entityType = parts[3];
          const entityId = parts.slice(4).join('_');
          
          console.log(`üóëÔ∏è DEBUG: Delete mode - Type: ${entityType}, ID: ${entityId}`);
          
          // Prevent deletion of map_cell entities
          if (entityType === 'map_cell') {
            return {
              content: '‚ùå Map cells cannot be deleted through this interface as they are tied to the grid system.',
              ephemeral: true
            };
          }
          
          const uiResponse = await createEntityManagementUI({
            entityType: entityType,
            guildId: context.guildId,
            selectedId: entityId,
            activeFieldGroup: null,
            searchTerm: '',
            mode: 'delete_confirm',
            userId: context.userId
          });
          
          return uiResponse;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('entity_confirm_delete_')) {
      // Confirm and execute deletion (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'entity_confirm_delete',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true, // Replace confirmation dialog with entity list
        handler: async (context) => {
          const parts = context.customId.split('_');
          const entityType = parts[3];
          const entityId = parts.slice(4).join('_');
          
          console.log(`üóëÔ∏è DEBUG: Deleting ${entityType} ${entityId}`);
          
          // Delete entity
          const success = await deleteEntity(context.guildId, entityType, entityId);
          
          if (!success) {
            throw new Error('Failed to delete entity');
          }
          
          // Return entity list to replace confirmation dialog
          const uiResponse = await createEntityManagementUI({
            entityType: entityType,
            guildId: context.guildId,
            selectedId: null,
            activeFieldGroup: null,
            searchTerm: '',
            mode: 'edit'
          });
          
          console.log(`‚úÖ DEBUG: Entity ${entityType} ${entityId} deleted successfully`);
          return uiResponse;
        }
      })(req, res, client);
      
    // ==================== END ENTITY MANAGEMENT HANDLERS ====================
    
    } else if (custom_id === 'safari_currency_reset_confirm') {
      // Handle confirmation to reset all currency (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_currency_reset_confirm',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        ephemeral: true,
        handler: async (context) => {
          console.log('üóëÔ∏è DEBUG: Currency reset confirmed');
          
          // Reset all currency
          const playerData = await loadPlayerData();
          const guildPlayers = playerData[context.guildId]?.players || {};
          
          let playersResetCount = 0;
          let totalCurrencyReset = 0;
          
          for (const [userId, player] of Object.entries(guildPlayers)) {
            if (player.safari?.currency !== undefined) {
              totalCurrencyReset += player.safari.currency;
              player.safari.currency = 0;
              player.safari.lastInteraction = Date.now();
              playersResetCount++;
            }
          }
          
          if (playersResetCount > 0) {
            await savePlayerData(playerData);
          }

          // Return Components V2 format for proper ephemeral support
          return {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17, // Container
              accent_color: 0x27ae60, // Green for success
              components: [
                {
                  type: 10, // Text Display
                  content: `‚úÖ **Currency Reset Complete!**\n\n**Players affected:** ${playersResetCount}\n**Total currency reset:** ${totalCurrencyReset} coins\n\nAll player balances have been set to 0.`
                }
              ]
            }]
          };
        }
      })(req, res, client);
    
    // ==================== MAP EXPLORER HANDLERS ====================
    
    } else if (custom_id === 'safari_map_explorer') {
      // Handle Map Explorer menu display - using Components V2 with Container (MIGRATED TO FACTORY)
      const shouldUpdateMessage = await shouldUpdateProductionMenuMessage(req.body.channel_id);

      return ButtonHandlerFactory.create({
        id: 'safari_map_explorer',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: shouldUpdateMessage,
        ephemeral: true,
        deferred: true,  // Enable deferred response for overlay generation
        handler: async (context) => {
          console.log(`üó∫Ô∏è DEBUG: Opening ephemeral Map Explorer interface for guild ${context.guildId}`);

          // Use extracted function to build response (ephemeral by default)
          const { buildMapExplorerResponse } = await import('./mapExplorer.js');
          return await buildMapExplorerResponse(context.guildId, context.userId, context.client, true);
        }
      })(req, res, client);

    } else if (custom_id === 'safari_shared_map') {
      // Handle Shared Map - creates NEW public (non-ephemeral) message (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_shared_map',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        // NO updateMessage: Creates NEW message instead of updating
        ephemeral: false,  // CRITICAL: Must be in config for deferred responses (line 2920 checks config.ephemeral)
        deferred: true,  // Enable deferred response for overlay generation
        handler: async (context) => {
          console.log(`üó∫Ô∏è DEBUG: Creating PUBLIC Shared Map for guild ${context.guildId}`);

          // Use extracted function to build response (isEphemeral: false for public)
          const { buildMapExplorerResponse } = await import('./mapExplorer.js');
          return await buildMapExplorerResponse(context.guildId, context.userId, context.client, false);
        }
      })(req, res, client);

    // MAP_CREATE HANDLER REMOVED - Use map_update instead which supports both create and update
    // } else if (custom_id === 'map_create') {
    //   // Handle Map Creation
    //   try {
    //     const guildId = req.body.guild_id;
    //     const userId = req.body.member?.user?.id || req.body.user?.id;
    //     const member = req.body.member;
    //     
    //     // Check admin permissions
    //     if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to create maps.')) return;
    //     
    //     console.log(`üèóÔ∏è DEBUG: Creating map for guild ${guildId}`);
    //     
    //     // Defer response for long operation
    //     await res.send({
    //       type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
    //       data: {
    //         flags: InteractionResponseFlags.EPHEMERAL
    //       }
    //     });
    //     
    //     // Get guild and create map
    //     const guild = await client.guilds.fetch(guildId);
    //     const { createMapGrid } = await import('./mapExplorer.js');
    //     const result = await createMapGrid(guild, userId);
    //     
    //     // Send followup with result
    //     const followupUrl = `https://discord.com/api/v10/webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
    //     
    //     await fetch(followupUrl, {
    //       method: 'PATCH',
    //       headers: {
    //         'Content-Type': 'application/json',
    //       },
    //       body: JSON.stringify({
    //         content: result.message,
    //         flags: InteractionResponseFlags.EPHEMERAL
    //       })
    //     });
    //     
    //   } catch (error) {
    //     console.error('Error in map_create handler:', error);
    //     
    //     // Try to send error as followup
    //     try {
    //       const followupUrl = `https://discord.com/api/v10/webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
    //       await fetch(followupUrl, {
    //         method: 'PATCH',
    //         headers: {
    //           'Content-Type': 'application/json',
    //         },
    //         body: JSON.stringify({
    //           content: `‚ùå Error creating map: ${error.message}`,
    //           flags: InteractionResponseFlags.EPHEMERAL
    //         })
    //       });
    //     } catch (followupError) {
    //       console.error('Error sending followup:', followupError);
    //     }
    //   }
    // 
    } else if (custom_id === 'map_update') {
      console.log('üéØ DEBUG: map_update button clicked!');
      // Handle Map Update - Show modal for Discord image URL
      return ButtonHandlerFactory.create({
        id: 'map_update',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîÑ START: map_update - user ${context.userId}`);
          
          // Create modal using ModalBuilder for consistency
          const { ModalBuilder, TextInputBuilder, ActionRowBuilder } = await import('discord.js');
          
          // Check if map exists to determine modal title
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const hasActiveMap = safariData[context.guildId]?.maps?.active;
          
          // Get existing map dimensions if updating
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const existingMap = activeMapId ? safariData[context.guildId]?.maps?.[activeMapId] : null;
          
          const modal = new ModalBuilder()
            .setCustomId('map_update_modal')
            .setTitle(hasActiveMap ? 'Update Map Image' : 'Create Map with Custom Image');
            
          const urlInput = new TextInputBuilder()
            .setCustomId('map_url')
            .setLabel('Discord Image URL')
            .setStyle(2) // Paragraph
            .setRequired(true)
            .setPlaceholder('Paste Discord CDN URL here (e.g., https://cdn.discordapp.com/attachments/...)')
            .setMinLength(20)
            .setMaxLength(500);
            
          // Add row input (height)
          const rowInput = new TextInputBuilder()
            .setCustomId('map_rows')
            .setLabel('Number of Map Rows')
            .setStyle(1) // Short
            .setRequired(true)
            .setPlaceholder('Enter how many rows you want in your map')
            .setValue(existingMap?.gridHeight?.toString() || existingMap?.gridSize?.toString() || '7')
            .setMinLength(1)
            .setMaxLength(3);
            
          // Add column input (width)
          const colInput = new TextInputBuilder()
            .setCustomId('map_columns')
            .setLabel('Number of Map Columns')
            .setStyle(1) // Short
            .setRequired(true)
            .setPlaceholder('Enter how many columns you want in your map')
            .setValue(existingMap?.gridWidth?.toString() || existingMap?.gridSize?.toString() || '7')
            .setMinLength(1)
            .setMaxLength(3);
            
          const actionRow1 = new ActionRowBuilder().addComponents(urlInput);
          const actionRow2 = new ActionRowBuilder().addComponents(rowInput);
          const actionRow3 = new ActionRowBuilder().addComponents(colInput);
          modal.addComponents(actionRow1, actionRow2, actionRow3);
          
          console.log(`‚úÖ SUCCESS: map_update - modal created`);
          
          // Return modal response for ButtonHandlerFactory to send
          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'map_delete') {
      // Handle Map Deletion - Show confirmation first
      return ButtonHandlerFactory.create({
        id: 'map_delete',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üóëÔ∏è START: map_delete - user ${context.userId}`);
          
          // Load map data to show what will be deleted
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const mapData = safariData[context.guildId]?.maps?.[activeMapId];
          
          if (!mapData) {
            return {
              content: '‚ùå No active map found to delete.',
              ephemeral: true
            };
          }
          
          // Count what will be deleted
          const coordinateCount = Object.keys(mapData.coordinates || {}).length;
          const actionCount = Object.keys(safariData[context.guildId]?.buttons || {}).length;
          
          const confirmationText = `## ‚ö†Ô∏è Delete Entire Map

**Map:** ${mapData.name || 'Adventure Map'}
**Grid Size:** ${mapData.gridWidth || mapData.gridSize || 7}x${mapData.gridHeight || mapData.gridSize || 7}
**Coordinates:** ${coordinateCount} locations
**Custom Actions:** ${actionCount} actions

**This action cannot be undone.** The following will be permanently deleted:
‚Ä¢ **All ${coordinateCount} Discord channels** (one for each map location)
‚Ä¢ All map coordinates and location data
‚Ä¢ All custom actions for this guild
‚Ä¢ All location content (stores, drops, etc.)
‚Ä¢ Map category and images

Are you sure you want to continue?`;
          
          return {
            components: [{
              type: 17, // Container
              accent_color: 0xed4245, // Red for danger
              components: [
                {
                  type: 10, // Text Display
                  content: confirmationText
                },
                {
                  type: 1, // Action Row
                  components: [
                    {
                      type: 2, // Button
                      custom_id: 'map_delete_cancel',
                      label: "Cancel",
                      style: 2, // Secondary
                      emoji: { name: "‚ùå" }
                    },
                    {
                      type: 2, // Button
                      custom_id: 'map_delete_confirm',
                      label: "Yes, Delete Everything",
                      style: 4, // Danger
                      emoji: { name: "üóëÔ∏è" }
                    }
                  ]
                }
              ]
            }],
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'map_delete_confirm') {
      // Check if we're deleting from within a map channel BEFORE creating handler
      const { loadSafariContent } = await import('./safariManager.js');
      const safariData = await loadSafariContent();
      const guildId = req.body.guild_id;
      const channelId = req.body.channel_id;
      const activeMapId = safariData[guildId]?.maps?.active;
      const mapData = safariData[guildId]?.maps?.[activeMapId];
      
      let isInMapChannel = false;
      if (mapData?.category) {
        // Check if current channel is in the map category
        const channel = await client.channels.fetch(channelId).catch(() => null);
        isInMapChannel = channel && channel.parentId === mapData.category;
      }
      
      // Handle confirmed map deletion - the actual deletion
      return ButtonHandlerFactory.create({
        id: 'map_delete_confirm',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        // Only use deferred if NOT in a map channel
        deferred: !isInMapChannel,
        ephemeral: true,
        handler: async (context) => {
          console.log(`üóëÔ∏è START: map_delete_confirm - user ${context.userId}, channel ${context.channelId}, isInMapChannel: ${isInMapChannel}`);
          
          if (isInMapChannel) {
            // If we're in a map channel, send immediate response before deletion
            // Schedule deletion to happen after response is sent
            setTimeout(async () => {
              try {
                const guild = await context.client.guilds.fetch(context.guildId);
                const { deleteMapGrid } = await import('./mapExplorer.js');
                await deleteMapGrid(guild);
                console.log(`‚úÖ Map deletion completed (from map channel)`);
              } catch (error) {
                console.error(`‚ùå Error during map deletion: ${error.message}`);
              }
            }, 1000); // 1 second delay to ensure response is sent
            
            return {
              content: 'üóëÔ∏è **Map deletion initiated!**\n\nThis channel will be deleted momentarily...',
              ephemeral: true
            };
          } else {
            // Not in a map channel, proceed normally with deferred response
            const guild = await context.client.guilds.fetch(context.guildId);
            const { deleteMapGrid } = await import('./mapExplorer.js');
            const result = await deleteMapGrid(guild);
            
            console.log(`‚úÖ SUCCESS: map_delete_confirm - deletion completed`);
            
            return {
              content: result.message,
              ephemeral: true
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id === 'map_delete_cancel') {
      // Handle cancelled map deletion - return to analytics_admin
      return ButtonHandlerFactory.create({
        id: 'map_delete_cancel',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          // Return to Reece Stuff menu (admin menu)
          const reeceMenuData = await createReeceStuffMenu(context.guildId, context.channelId);

          return {
            ...reeceMenuData,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'map_admin_blacklist') {
      // Handle blacklisted coordinates management
      return ButtonHandlerFactory.create({
        id: 'map_admin_blacklist',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const { handleMapAdminBlacklist } = await import('./safariMapAdmin.js');
          return await handleMapAdminBlacklist(context);
        }
      })(req, res, client);
      
    } else if (custom_id === 'map_admin_blacklist_modal') {
      // Handle blacklist modal submission
      return ButtonHandlerFactory.create({
        id: 'map_admin_blacklist_modal',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const { handleMapAdminBlacklistModal } = await import('./safariMapAdmin.js');
          return await handleMapAdminBlacklistModal(context, req);
        }
      })(req, res, client);
      
    } else if (custom_id === 'map_admin_refresh_anchors') {
      // Handle refresh anchors management
      return ButtonHandlerFactory.create({
        id: 'map_admin_refresh_anchors',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const { handleMapAdminRefreshAnchors } = await import('./safariMapAdmin.js');
          return await handleMapAdminRefreshAnchors(context);
        }
      })(req, res, client);
      
    } else if (custom_id === 'map_admin_refresh_anchors_modal') {
      // Handle refresh anchors modal submission
      return ButtonHandlerFactory.create({
        id: 'map_admin_refresh_anchors_modal',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const { handleMapAdminRefreshAnchorsModal } = await import('./safariMapAdmin.js');
          return await handleMapAdminRefreshAnchorsModal(context, req);
        }
      })(req, res, client);
      
    } else if (custom_id === 'map_player_locations') {
      // Handle player locations display
      return ButtonHandlerFactory.create({
        id: 'map_player_locations',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        ephemeral: true,
        deferred: true,  // Enable deferred response - fetches Discord members (network-bound, can exceed 3s timeout)
        handler: async (context) => {
          console.log(`üë• START: map_player_locations - user ${context.userId}`);
          
          const { getAllPlayerLocations, formatPlayerLocationDisplay, createPlayerLocationMap } = await import('./playerLocationManager.js');

          // Get all player locations with Discord client to fetch real-time display names
          const playerLocations = await getAllPlayerLocations(context.guildId, true, client);

          // Convert Map to array for display
          const playersArray = Array.from(playerLocations.values());

          // Create visual map display - pass pre-fetched playerLocations to avoid duplicate API call
          const mapDisplay = await createPlayerLocationMap(context.guildId, client, {
            showBlacklisted: true,
            playerLocations  // Reuse already-fetched data (eliminates 2+ minute duplicate fetch)
          });
          
          // Format detailed player list
          const detailedList = formatPlayerLocationDisplay(playersArray, {
            showStamina: true,
            showLastMove: true,
            showExplored: true,
            groupByLocation: true
          });
          
          // Build UI components
          const { ButtonBuilder, ActionRowBuilder } = await import('discord.js');
          
          // Navigation buttons
          const refreshButton = new ButtonBuilder()
            .setCustomId('map_player_locations_refresh')
            .setLabel('Refresh')
            .setStyle(2) // Secondary
            .setEmoji('üîÑ');
          
          const backButton = new ButtonBuilder()
            .setCustomId('safari_map_explorer')
            .setLabel('Back to Map Explorer')
            .setStyle(2) // Secondary
            .setEmoji('‚óÄÔ∏è');
          
          const adminButton = new ButtonBuilder()
            .setCustomId('safari_map_admin')
            .setLabel('Player Admin')
            .setStyle(4) // Danger
            .setEmoji('üß≠');
          
          const navigationRow = new ActionRowBuilder().addComponents([refreshButton, adminButton, backButton]);
          
          console.log(`‚úÖ SUCCESS: map_player_locations - found ${playerLocations.size} players`);
          
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2
            components: [{
              type: 17, // Container
              accent_color: 0x5865f2, // Discord blurple
              components: [
                mapDisplay,
                { type: 14 }, // Separator
                {
                  type: 10, // Text Display
                  content: `## üìä Player Details\n\n${detailedList || '_No players on the map_'}`
                },
                { type: 14 }, // Separator
                navigationRow.toJSON()
              ]
            }]
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'map_player_locations_refresh') {
      // Handle refresh button
      return ButtonHandlerFactory.create({
        id: 'map_player_locations_refresh',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        ephemeral: true,
        deferred: true,  // Enable deferred response - fetches Discord members (network-bound)
        handler: async (context) => {
          console.log(`üîÑ REFRESH: map_player_locations - user ${context.userId}`);
          
          // Reuse the same handler logic as map_player_locations
          const { getAllPlayerLocations, formatPlayerLocationDisplay, createPlayerLocationMap } = await import('./playerLocationManager.js');

          const playerLocations = await getAllPlayerLocations(context.guildId, true, client);
          const playersArray = Array.from(playerLocations.values());
          // Pass pre-fetched playerLocations to avoid duplicate API call
          const mapDisplay = await createPlayerLocationMap(context.guildId, client, {
            showBlacklisted: true,
            playerLocations  // Reuse already-fetched data
          });
          const detailedList = formatPlayerLocationDisplay(playersArray, {
            showStamina: true,
            showLastMove: true,
            showExplored: true,
            groupByLocation: true
          });
          
          const { ButtonBuilder, ActionRowBuilder } = await import('discord.js');
          
          const refreshButton = new ButtonBuilder()
            .setCustomId('map_player_locations_refresh')
            .setLabel('Refresh')
            .setStyle(2)
            .setEmoji('üîÑ');
          
          const backButton = new ButtonBuilder()
            .setCustomId('safari_map_explorer')
            .setLabel('Back to Map Explorer')
            .setStyle(2)
            .setEmoji('‚óÄÔ∏è');
          
          const adminButton = new ButtonBuilder()
            .setCustomId('safari_map_admin')
            .setLabel('Player Admin')
            .setStyle(4)
            .setEmoji('üß≠');
          
          const navigationRow = new ActionRowBuilder().addComponents([refreshButton, adminButton, backButton]);
          
          return {
            flags: (1 << 15),
            components: [{
              type: 17,
              accent_color: 0x5865f2,
              components: [
                mapDisplay,
                { type: 14 },
                {
                  type: 10,
                  content: `## üìä Player Details\n\n${detailedList || '_No players on the map_'}`
                },
                { type: 14 },
                navigationRow.toJSON()
              ]
            }]
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_location_actions_')) {
      // Handle Location Actions button
      return ButtonHandlerFactory.create({
        id: 'map_location_actions',
        ephemeral: true,
        handler: async (context) => {
          const coord = custom_id.replace('map_location_actions_', '');
          
          console.log(`üìç START: map_location_actions - user ${context.userId}, coord ${coord}`);
          
          // Check admin permissions and show appropriate UI
          if (!hasPermission(context.member, PermissionFlagsBits.ManageRoles)) {
            console.log(`üë§ Non-admin user ${context.userId} accessing location actions for ${coord}`);
            
            // Show player command interface
            const { ButtonBuilder, ActionRowBuilder } = await import('discord.js');
            
            // Get location name
            const { loadSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const activeMapId = safariData[context.guildId]?.maps?.active;
            const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
            const locationName = coordData?.baseContent?.title || `Location ${coord}`;
            
            // Create Enter Command button with joystick emoji
            const enterCommandButton = new ButtonBuilder()
              .setCustomId(`player_enter_command_${coord}`)
              .setLabel('Enter Command')
              .setEmoji('üïπÔ∏è')
              .setStyle(2); // Secondary
            
            // Create Navigate button
            const navigateButton = new ButtonBuilder()
              .setCustomId(`safari_navigate_${context.userId}_${coord}`)
              .setLabel('Navigate')
              .setEmoji('üó∫Ô∏è')
              .setStyle(2); // Secondary
            
            // Create Whisper button
            const whisperButton = new ButtonBuilder()
              .setCustomId(`safari_whisper_${coord}`)
              .setLabel('Whisper')
              .setEmoji('üí¨')
              .setStyle(2); // Secondary
            
            const buttonRow = new ActionRowBuilder().addComponents([navigateButton, enterCommandButton, whisperButton]);
            
            return {
              components: [{
                type: 17, // Container
                accent_color: 0x5865f2,
                components: [
                  {
                    type: 10, // Text Display
                    content: `## ${locationName} Actions\n\nInteract with this location by entering commands.`
                  },
                  { type: 14 }, // Separator
                  buttonRow.toJSON()
                ]
              }],
              flags: (1 << 15), // IS_COMPONENTS_V2
              ephemeral: true
            };
          }
          
          // Get map data
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (!coordData) {
            console.log(`‚ùå Location data not found for ${coord}`);
            return {
              content: '‚ùå Location data not found.',
              ephemeral: true
            };
          }
          
          // Create entity management UI for this coordinate
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            selectedId: coord,
            mode: 'edit'
          });
          
          // Add Navigate button to the action row containing Enter Command
          // Find the action row with Enter Command button and add Navigate to the left
          console.log(`üîç DEBUG: UI has ${ui.components?.length || 0} components`);
          
          if (ui.components && ui.components.length > 0) {
            let foundEnterCommand = false;
            for (let i = 0; i < ui.components.length; i++) {
              const component = ui.components[i];
              console.log(`üîç DEBUG: Component ${i}: type=${component.type}, has ${component.components?.length || 0} sub-components`);
              
              // Look for Container (type 17) first
              if (component.type === 17) { // Container
                console.log(`üîç DEBUG: Found Container with ${component.components?.length || 0} sub-components`);
                
                // Look through Container's components for Action Rows
                if (component.components && component.components.length > 0) {
                  for (let j = 0; j < component.components.length; j++) {
                    const subComponent = component.components[j];
                    console.log(`üîç DEBUG: Container sub-component ${j}: type=${subComponent.type}`);
                    
                    if (subComponent.type === 1) { // Action Row inside Container
                      const hasEnterCommand = subComponent.components?.some(btn => {
                        console.log(`üîç DEBUG: Button custom_id: ${btn.custom_id}`);
                        return btn.custom_id && btn.custom_id.startsWith('player_enter_command_');
                      });
                      
                      console.log(`üîç DEBUG: Container action row ${j} has Enter Command: ${hasEnterCommand}`);
                      
                      if (hasEnterCommand) {
                        foundEnterCommand = true;
                        console.log(`üîç DEBUG: Reordering buttons in container action row ${j} (before: ${subComponent.components.length} buttons)`);
                        
                        // Create Navigate button
                        const navigateButton = {
                          type: 2, // Button
                          style: 2, // Secondary (grey)
                          label: 'Navigate',
                          custom_id: `safari_navigate_${context.userId}_${coord}`,
                          emoji: { name: 'üó∫Ô∏è' }
                        };
                        
                        // Create Inventory button
                        const { getCustomTerms } = await import('./safariManager.js');
                        const customTerms = await getCustomTerms(context.guildId);
                        const inventoryButton = {
                          type: 2, // Button
                          style: 2, // Secondary (grey)
                          label: 'Inventory',
                          custom_id: 'safari_player_inventory',
                          emoji: { name: customTerms.inventoryEmoji || 'üß∞' }
                        };
                        
                        // Find existing buttons
                        const safariButton = subComponent.components.find(btn => btn.custom_id === 'prod_safari_menu');
                        const enterCommandButton = subComponent.components.find(btn => btn.custom_id && btn.custom_id.startsWith('player_enter_command_'));
                        const whisperButton = subComponent.components.find(btn => btn.custom_id && btn.custom_id.startsWith('safari_whisper_'));
                        
                        // Rebuild components in desired order: Safari, Navigate, Inventory, Enter Command, Whisper
                        subComponent.components = [];
                        if (safariButton) subComponent.components.push(safariButton);
                        subComponent.components.push(navigateButton);
                        subComponent.components.push(inventoryButton);
                        if (enterCommandButton) subComponent.components.push(enterCommandButton);
                        if (whisperButton) subComponent.components.push(whisperButton);
                        
                        console.log(`üîç DEBUG: Reordered buttons (after: ${subComponent.components.length} buttons)`);
                        break;
                      }
                    }
                  }
                }
              } else if (component.type === 1) { // Action Row at top level
                // Check if this row has Enter Command button
                const hasEnterCommand = component.components?.some(btn => {
                  console.log(`üîç DEBUG: Button custom_id: ${btn.custom_id}`);
                  return btn.custom_id && btn.custom_id.startsWith('player_enter_command_');
                });
                
                console.log(`üîç DEBUG: Top-level action row ${i} has Enter Command: ${hasEnterCommand}`);
                
                if (hasEnterCommand) {
                  foundEnterCommand = true;
                  console.log(`üîç DEBUG: Adding Navigate button to top-level action row ${i} (before: ${component.components.length} buttons)`);
                  
                  // Add Navigate button at the beginning of this action row
                  const navigateButton = {
                    type: 2, // Button
                    style: 2, // Secondary (grey)
                    label: 'Navigate',
                    custom_id: `safari_navigate_${context.userId}_${coord}`,
                    emoji: { name: 'üó∫Ô∏è' }
                  };
                  
                  // Insert Navigate button at the beginning
                  component.components.unshift(navigateButton);
                  console.log(`üîç DEBUG: Added Navigate button (after: ${component.components.length} buttons)`);
                  break;
                }
              }
              
              if (foundEnterCommand) break;
            }
            console.log(`üîç DEBUG: Found Enter Command row: ${foundEnterCommand}`);
          }
          
          console.log(`‚úÖ SUCCESS: map_location_actions - showing entity UI with admin buttons and Navigate for ${coord}`);
          
          return {
            ...ui,
            ephemeral: true
          };
        }
      })(req, res, client);
    
    } else if (custom_id.startsWith('map_location_display_')) {
      // Handle Location button display (shows anchor message content)
      return ButtonHandlerFactory.create({
        id: 'map_location_display',
        ephemeral: true, // Default to ephemeral
        handler: async (context) => {
          // Extract coordinate and check for _prod suffix
          const customIdParts = context.customId.replace('map_location_display_', '');
          const isFromProdMenu = customIdParts.endsWith('_prod');
          const coord = isFromProdMenu ? customIdParts.replace('_prod', '') : customIdParts;
          
          console.log(`‚öì START: map_location_display - user ${context.userId}, coord ${coord}, prod=${isFromProdMenu}`);
          
          // Check if we have a valid coordinate
          if (coord === 'none') {
            return {
              content: '‚ùå You are not currently in a map location.',
              ephemeral: true
            };
          }
          
          // Load location data
          const { createAnchorMessageComponents } = await import('./safariButtonHelper.js');
          const { loadSafariContent } = await import('./safariManager.js');
          
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          
          if (!activeMapId) {
            return {
              content: '‚ùå No active map found in this server.',
              ephemeral: true
            };
          }
          
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (!coordData) {
            console.log(`‚ùå Location data not found for ${coord}`);
            return {
              content: `‚ùå Location data not found for ${coord}.`,
              ephemeral: true
            };
          }
          
          // Get fog map URL if available
          const fogMapUrl = coordData.fogMapUrl || null;
          
          // Generate anchor message components
          const components = await createAnchorMessageComponents(coordData, context.guildId, coord, fogMapUrl);
          
          console.log(`‚úÖ SUCCESS: map_location_display - showing anchor content for ${coord}, ephemeral=${!isFromProdMenu}`);
          
          return {
            components,
            flags: (1 << 15) | (isFromProdMenu ? 0 : (1 << 6)) // IS_COMPONENTS_V2 + ephemeral unless from prod menu
          };
        }
      })(req, res, client);
    
    } else if (custom_id === 'player_enter_command_global') {
      // Handle global command entry button (coordinate-less)
      return ButtonHandlerFactory.create({
        id: 'player_enter_command_global',
        handler: async (context) => {
          console.log(`‚å®Ô∏è START: player_enter_command_global - user ${context.userId}`);

          // Show modal for global command input
          return {
            type: InteractionResponseType.MODAL,
            data: {
              custom_id: 'player_command_modal_global',
              title: 'Enter Command',
              components: [{
                type: 1, // Action Row
                components: [{
                  type: 4, // Text Input
                  custom_id: 'command',
                  label: 'Command',
                  style: 1, // Short
                  required: true,
                  placeholder: 'Enter command you want to try, e.g. hello, claude, sendmea, tomato',
                  min_length: 1,
                  max_length: 100
                }]
              }]
            }
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('player_enter_command_')) {
      // Handle player command entry button
      return ButtonHandlerFactory.create({
        id: 'player_enter_command',
        handler: async (context) => {
          const coord = context.customId.replace('player_enter_command_', '');
          
          console.log(`‚å®Ô∏è START: player_enter_command - user ${context.userId}, coord ${coord}`);
          
          // Show modal for command input
          return {
            type: InteractionResponseType.MODAL,
            data: {
              custom_id: `player_command_modal_${coord}`,
              title: 'Enter Command',
              components: [{
                type: 1, // Action Row
                components: [{
                  type: 4, // Text Input
                  custom_id: 'command',
                  label: 'Command',
                  style: 1, // Short
                  required: true,
                  placeholder: 'Enter command you want to try, e.g. climb vines, check rock',
                  min_length: 1,
                  max_length: 100
                }]
              }]
            }
          };
        }
      })(req, res, client);
    
    } else if (custom_id.startsWith('admin_test_command_')) {
      // Handle admin command testing button
      return ButtonHandlerFactory.create({
        id: 'admin_test_command',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const coord = context.customId.replace('admin_test_command_', '');
          
          console.log(`üîß START: admin_test_command - user ${context.userId}, coord ${coord}`);
          
          // Get location name
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          const locationName = coordData?.baseContent?.title || `Location ${coord}`;
          
          // Show modal for command input (identical to player modal)
          return {
            type: InteractionResponseType.MODAL,
            data: {
              custom_id: `admin_command_modal_${coord}`,
              title: 'Test Command (Admin)',
              components: [{
                type: 1, // Action Row
                components: [{
                  type: 4, // Text Input
                  custom_id: 'command',
                  label: 'Command',
                  style: 1, // Short
                  required: true,
                  placeholder: 'Enter command you want to test, e.g. climb vines, check rock',
                  min_length: 1,
                  max_length: 100
                }]
              }]
            }
          };
        }
      })(req, res, client);
    
    } else if (custom_id.startsWith('map_stores_select_')) {
      // Handle store selection for map coordinate
      return ButtonHandlerFactory.create({
        id: 'map_stores_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const coord = context.customId.replace('map_stores_select_', '');
          const selectedStores = context.values || [];
          
          console.log(`üè™ START: map_stores_select - coord ${coord}, stores: ${selectedStores.join(', ')}`);
          
          // Load and update safari data
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          
          if (!activeMapId || !safariData[context.guildId].maps[activeMapId].coordinates[coord]) {
            return {
              content: '‚ùå Location data not found.',
              ephemeral: true
            };
          }
          
          // Update stores for this coordinate
          safariData[context.guildId].maps[activeMapId].coordinates[coord].stores = selectedStores;
          
          // Remove stores from buttons array (cleanup)
          const coordData = safariData[context.guildId].maps[activeMapId].coordinates[coord];
          if (coordData.buttons) {
            coordData.buttons = coordData.buttons.filter(buttonId => 
              !selectedStores.includes(buttonId) && 
              !Object.keys(safariData[context.guildId]?.stores || {}).includes(buttonId)
            );
          }
          
          await saveSafariContent(safariData);
          
          // Update anchor message
          const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
          await safeUpdateAnchorMessage(context.guildId, coord, client);
          
          // Return to entity management UI
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            selectedId: coord,
            mode: 'edit'
          });
          
          console.log(`‚úÖ SUCCESS: map_stores_select - updated stores for ${coord}`);
          
          return {
            ...ui,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_coord_store_')) {
      // Handle store button click from anchor message ‚Äî uses shared paginated store display
      return ButtonHandlerFactory.create({
        id: 'map_coord_store',
        handler: async (context) => {
          // Parse: map_coord_store_{coord}_{storeId}
          const parts = context.customId.replace('map_coord_store_', '').split('_');
          const coord = parts[0];
          const storeId = parts.slice(1).join('_');

          // Check if user is in the correct channel
          const { loadSafariContent, createStoreBrowseDisplay } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];

          if (!coordData || coordData.channelId !== context.channelId) {
            return {
              components: [{
                type: 17,
                components: [{ type: 10, content: '> You can only access this store from its location!' }]
              }],
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
            };
          }

          // Use shared paginated store display (consistent inventory button across all store types)
          const result = await createStoreBrowseDisplay(
            context.guildId, storeId, context.userId, 0
          );
          result.flags = (1 << 15) | InteractionResponseFlags.EPHEMERAL;
          return result;
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_add_item_drop_')) {
      // Show item selection for drop configuration with custom map context
      return ButtonHandlerFactory.create({
        id: 'map_add_item_drop',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        ephemeral: true,
        handler: async (context) => {
          const coord = context.customId.replace('map_add_item_drop_', '');
          
          console.log(`üì¶ START: map_add_item_drop - coord ${coord}, user ${context.userId}`);
          
          // Create custom item selection UI with map-specific custom_id
          const uiResponse = await createEntityManagementUI({
            entityType: 'item',
            guildId: context.guildId,
            selectedId: null,
            activeFieldGroup: null,
            searchTerm: '',
            mode: 'edit'
          });
          
          // Replace the entity_select_item custom_id with our map-specific one
          if (uiResponse.components?.[0]?.components) {
            for (const component of uiResponse.components[0].components) {
              if (component.type === 1 && component.components?.[0]?.custom_id === 'entity_select_item') {
                component.components[0].custom_id = `map_item_drop_select_${coord}`;
                component.components[0].placeholder = `Select item to add to ${coord}...`;
              }
            }
          }
          
          console.log(`‚úÖ SUCCESS: map_add_item_drop - showing item selection UI for ${coord}`);
          return {
            ...uiResponse,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_item_search_')) {
      // Handle item search button for map locations
      return ButtonHandlerFactory.create({
        id: 'map_item_search',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const coord = context.customId.replace('map_item_search_', '');
          
          console.log(`üîç START: map_item_search - coord ${coord}, user ${context.userId}`);
          
          // Show search modal
          const { ModalBuilder, TextInputBuilder, ActionRowBuilder } = await import('discord.js');
          
          const modal = new ModalBuilder()
            .setCustomId(`map_item_search_modal_${coord}`)
            .setTitle(`Search Items for ${coord}`);

          const searchInput = new TextInputBuilder()
            .setCustomId('search_term')
            .setLabel('Search for items...')
            .setStyle(1) // Short
            .setPlaceholder('Enter item name or description')
            .setRequired(false);

          modal.addComponents(new ActionRowBuilder().addComponents(searchInput));

          console.log(`‚úÖ SUCCESS: map_item_search - showing search modal for ${coord}`);
          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_add_currency_drop_')) {
      // Show currency drop configuration modal
      return ButtonHandlerFactory.create({
        id: 'map_add_currency_drop',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const coord = context.customId.replace('map_add_currency_drop_', '');
          
          console.log(`ü™ô START: map_add_currency_drop - coord ${coord}`);
          
          // Show modal for currency configuration
          const modal = new ModalBuilder()
            .setCustomId(`map_currency_drop_modal_${coord}`)
            .setTitle(`Configure Currency Drop for ${coord}`);
            
          const amountInput = new TextInputBuilder()
            .setCustomId('amount')
            .setLabel('Currency Amount')
            .setStyle(TextInputStyle.Short)
            .setPlaceholder('100')
            .setRequired(true)
            .setMinLength(1)
            .setMaxLength(10);
            
          const buttonTextInput = new TextInputBuilder()
            .setCustomId('buttonText')
            .setLabel('Button Text')
            .setStyle(TextInputStyle.Short)
            .setValue('Collect Coins')
            .setRequired(true)
            .setMaxLength(80);
            
          const buttonEmojiInput = new TextInputBuilder()
            .setCustomId('buttonEmoji')
            .setLabel('Button Emoji')
            .setStyle(TextInputStyle.Short)
            .setValue('ü™ô')
            .setRequired(false)
            .setMaxLength(100);
            
          modal.addComponents(
            new ActionRowBuilder().addComponents(amountInput),
            new ActionRowBuilder().addComponents(buttonTextInput),
            new ActionRowBuilder().addComponents(buttonEmojiInput)
          );
          
          console.log(`‚úÖ SUCCESS: map_add_currency_drop - showing modal for ${coord}`);
          
          return res.send({
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          });
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_item_drop_config_')) {
      // Handle item drop configuration button
      return ButtonHandlerFactory.create({
        id: 'map_item_drop_config',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          try {
            const parts = context.customId.replace('map_item_drop_config_', '').split('_');
            const coord = parts[0];
            const itemId = parts.slice(1).join('_'); // Handle item IDs that might contain underscores
            
            console.log(`üì¶ START: map_item_drop_config - coord ${coord}, item ${itemId}`);
            
            // Load current data to check for existing drop
            const { loadSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const activeMapId = safariData[context.guildId]?.maps?.active;
            const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
            const item = safariData[context.guildId]?.items?.[itemId];
            
            if (!coordData || !item) {
              console.log(`‚ùå FAILED: map_item_drop_config - location or item not found`);
              return {
                content: '‚ùå Location or item data not found.',
                ephemeral: true
              };
            }
            
            // Check if this item already has a drop at this location
            const existingDropIndex = coordData.itemDrops?.findIndex(drop => drop.itemId === itemId);
            
            // Show configuration interface
            const dropConfig = existingDropIndex >= 0 ? coordData.itemDrops[existingDropIndex] : {
              itemId: itemId,
              buttonText: `Open ${item.name}`,
              buttonEmoji: item.emoji || 'üì¶',
              buttonStyle: 2,
              dropType: 'once_per_player',
              claimedBy: []
            };
            
            console.log(`‚úÖ SUCCESS: map_item_drop_config - showing config for ${itemId} at ${coord}`);
            
            return {
              components: [{
                type: 17, // Container
                components: [
                  {
                    type: 10, // Text Display
                    content: `# Configure ${item.emoji || 'üì¶'} ${item.name} Drop\n\n**Location:** ${coord}`
                  },
                  { type: 14 }, // Separator
                  {
                    type: 10, // Text Display - Preview
                    content: `**Button Preview:**\n${dropConfig.buttonEmoji} ${dropConfig.buttonText}\n\n**Current Setting:** ${dropConfig.dropType === 'once_per_player' ? 'One per player' : 'One per entire season'}`
                  },
                  { type: 14 }, // Separator
                  {
                    type: 1, // Action Row - Button style select
                    components: [{
                      type: 3, // String Select
                      custom_id: `map_drop_style_${coord}_${itemId}`,
                      placeholder: 'Select button style...',
                      options: [
                        { label: 'Primary (Blue)', value: '1', default: dropConfig.buttonStyle === 1 },
                        { label: 'Secondary (Grey)', value: '2', default: dropConfig.buttonStyle === 2 },
                        { label: 'Success (Green)', value: '3', default: dropConfig.buttonStyle === 3 },
                        { label: 'Danger (Red)', value: '4', default: dropConfig.buttonStyle === 4 }
                      ]
                    }]
                  },
                  {
                    type: 1, // Action Row - Drop type select
                    components: [{
                      type: 3, // String Select
                      custom_id: `map_drop_type_${coord}_${itemId}`,
                      placeholder: 'How many are available?',
                      options: [
                        { 
                          label: 'One per player', 
                          value: 'once_per_player',
                          description: 'Each player can claim this item once',
                          default: dropConfig.dropType === 'once_per_player'
                        },
                        { 
                          label: 'One per entire season', 
                          value: 'once_per_season',
                          description: 'Only one player can claim this item',
                          default: dropConfig.dropType === 'once_per_season'
                        }
                      ]
                    }]
                  },
                  { type: 14 }, // Separator
                  {
                    type: 1, // Action Row - Actions
                    components: [
                      {
                        type: 2, // Button
                        custom_id: `map_drop_text_${coord}_${itemId}`,
                        label: 'Set Button Text',
                        style: 2, // Secondary
                        emoji: { name: '‚úèÔ∏è' }
                      },
                      {
                        type: 2, // Button
                        custom_id: `map_drop_save_${coord}_${itemId}`,
                        label: existingDropIndex >= 0 ? 'Update Item' : 'Add Item',
                        style: 3, // Success
                        emoji: { name: '‚úÖ' }
                      },
                      existingDropIndex >= 0 ? {
                        type: 2, // Button
                        custom_id: `map_drop_remove_${coord}_${itemId}`,
                        label: 'Remove Item',
                        style: 4, // Danger
                        emoji: { name: 'üóëÔ∏è' }
                      } : null,
                      {
                        type: 2, // Button
                        custom_id: `map_drop_reset_${coord}_${itemId}`,
                        label: 'Reset Item',
                        style: 2, // Secondary
                        emoji: { name: 'üîÉ' }
                      }
                    ].filter(Boolean)
                  }
                ]
              }],
              flags: (1 << 15), // IS_COMPONENTS_V2
              ephemeral: true
            };
          } catch (error) {
            console.error(`‚ùå ERROR: map_item_drop_config - ${error.message}`);
            return {
              content: '‚ùå Error configuring item drop. Please try again.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_item_drop_select_')) {
      // Handle item selection for drop configuration (from select menu)
      return ButtonHandlerFactory.create({
        id: 'map_item_drop_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          try {
            const coord = context.customId.replace('map_item_drop_select_', '');
            const itemId = context.values?.[0];
            
            if (!itemId) {
              console.log(`‚ùå FAILED: map_item_drop_select - no item selected`);
              return {
                content: '‚ùå No item selected.',
                ephemeral: true
              };
            }
            
            console.log(`üì¶ START: map_item_drop_select - coord ${coord}, item ${itemId}`);
            
            // Handle special values
            if (itemId === 'search_entities') {
              console.log(`üîç SEARCH: map_item_drop_select - showing all items for ${coord}`);
              
              // Load all items and show with Discord's built-in search
              const { loadSafariContent } = await import('./safariManager.js');
              const safariData = await loadSafariContent();
              const allItems = safariData[context.guildId]?.items || {};
              
              // Create simple options for ALL items
              const itemOptions = Object.entries(allItems).map(([itemId, item]) => {
                const label = item.name || 'Unnamed Item';
                
                return {
                  label: label.substring(0, 100),
                  value: itemId,
                  description: item.description?.substring(0, 100) || 'No description',
                  emoji: { name: 'üì¶' } // Consistent emoji to avoid parsing issues
                };
              });
              
              // Sort alphabetically
              itemOptions.sort((a, b) => a.label.localeCompare(b.label));
              
              // Limit to 25
              const limitedOptions = itemOptions.slice(0, 25);
              
              console.log(`‚úÖ SUCCESS: map_item_drop_select - showing ${limitedOptions.length} items for search`);
              
              return {
                components: [{
                  type: 17, // Container
                  accent_color: 0x2ecc71, // Green for map actions
                  components: [
                    {
                      type: 10, // Text Display
                      content: `## Select Item for ${coord}\n\n*Showing ${limitedOptions.length} of ${itemOptions.length} items. Start typing to search.*`
                    },
                    { type: 14 }, // Separator
                    {
                      type: 1, // Action Row
                      components: [{
                        type: 3, // String Select
                        custom_id: `map_item_drop_select_${coord}`,
                        placeholder: `üîç Type to search ${itemOptions.length} items...`,
                        options: limitedOptions
                      }]
                    }
                  ]
                }],
                flags: (1 << 15), // IS_COMPONENTS_V2
                ephemeral: true
              };
            }
            
            // Load current data to check for existing drop
            const { loadSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const activeMapId = safariData[context.guildId]?.maps?.active;
            const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
            const item = safariData[context.guildId]?.items?.[itemId];
            
            if (!coordData || !item) {
              console.log(`‚ùå FAILED: map_item_drop_select - location or item not found`);
              return {
                content: '‚ùå Location or item data not found.',
                ephemeral: true
              };
            }
            
            // Check if this item already has a drop at this location
            const existingDropIndex = coordData.itemDrops?.findIndex(drop => drop.itemId === itemId);
            
            // Show configuration interface
            const dropConfig = existingDropIndex >= 0 ? coordData.itemDrops[existingDropIndex] : {
              itemId: itemId,
              buttonText: `Open ${item.name}`,
              buttonEmoji: item.emoji || 'üì¶',
              buttonStyle: 2,
              dropType: 'once_per_player',
              claimedBy: []
            };
            
            console.log(`‚úÖ SUCCESS: map_item_drop_select - showing config for ${itemId} at ${coord}`);
            
            return {
              components: [{
                type: 17, // Container
                components: [
                  {
                    type: 10, // Text Display
                    content: `# Configure ${item.emoji || 'üì¶'} ${item.name} Drop\n\n**Location:** ${coord}`
                  },
                  { type: 14 }, // Separator
                  {
                    type: 10, // Text Display - Preview
                    content: `**Button Preview:**\n${dropConfig.buttonEmoji} ${dropConfig.buttonText}\n\n**Current Setting:** ${dropConfig.dropType === 'once_per_player' ? 'One per player' : 'One per entire season'}`
                  },
                  { type: 14 }, // Separator
                  {
                    type: 1, // Action Row - Button style select
                    components: [{
                      type: 3, // String Select
                      custom_id: `map_drop_style_${coord}_${itemId}`,
                      placeholder: 'Select button style...',
                      options: [
                        { label: 'Primary (Blue)', value: '1', default: dropConfig.buttonStyle === 1 },
                        { label: 'Secondary (Grey)', value: '2', default: dropConfig.buttonStyle === 2 },
                        { label: 'Success (Green)', value: '3', default: dropConfig.buttonStyle === 3 },
                        { label: 'Danger (Red)', value: '4', default: dropConfig.buttonStyle === 4 }
                      ]
                    }]
                  },
                  {
                    type: 1, // Action Row - Drop type select
                    components: [{
                      type: 3, // String Select
                      custom_id: `map_drop_type_${coord}_${itemId}`,
                      placeholder: 'How many are available?',
                      options: [
                        { 
                          label: 'One per player', 
                          value: 'once_per_player',
                          description: 'Each player can claim this item once',
                          default: dropConfig.dropType === 'once_per_player'
                        },
                        { 
                          label: 'One per entire season', 
                          value: 'once_per_season',
                          description: 'Only one player can claim this item',
                          default: dropConfig.dropType === 'once_per_season'
                        }
                      ]
                    }]
                  },
                  { type: 14 }, // Separator
                  {
                    type: 1, // Action Row - Actions
                    components: [
                      {
                        type: 2, // Button
                        custom_id: `map_drop_text_${coord}_${itemId}`,
                        label: 'Set Button Text',
                        style: 2, // Secondary
                        emoji: { name: '‚úèÔ∏è' }
                      },
                      {
                        type: 2, // Button
                        custom_id: `map_drop_save_${coord}_${itemId}`,
                        label: existingDropIndex >= 0 ? 'Update Item' : 'Add Item',
                        style: 3, // Success
                        emoji: { name: '‚úÖ' }
                      },
                      existingDropIndex >= 0 ? {
                        type: 2, // Button
                        custom_id: `map_drop_remove_${coord}_${itemId}`,
                        label: 'Remove Item',
                        style: 4, // Danger
                        emoji: { name: 'üóëÔ∏è' }
                      } : null,
                      {
                        type: 2, // Button
                        custom_id: `map_drop_reset_${coord}_${itemId}`,
                        label: 'Reset Item',
                        style: 2, // Secondary
                        emoji: { name: 'üîÉ' }
                      }
                    ].filter(Boolean)
                  }
                ]
              }],
              flags: (1 << 15), // IS_COMPONENTS_V2
              ephemeral: true
            };
          } catch (error) {
            console.error(`‚ùå ERROR: map_item_drop_select - ${error.message}`);
            return {
              content: '‚ùå Error configuring item drop. Please try again.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_item_drop_') && !custom_id.includes('_select_')) {
      // Handle item drop button click from players
      return ButtonHandlerFactory.create({
        id: 'map_item_drop_player',
        ephemeral: true,
        handler: async (context) => {
          // Parse: map_item_drop_{coord}_{index}
          const parts = context.customId.replace('map_item_drop_', '').split('_');
          const coord = parts[0];
          const dropIndex = parseInt(parts[1]);
          
          console.log(`üì¶ START: map_item_drop_player - user ${context.userId}, coord ${coord}, index ${dropIndex}`);
          
          // Load safari data
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          const drop = coordData?.itemDrops?.[dropIndex];
          
          if (!drop) {
            return {
              content: '‚ùå Item drop not found.',
              ephemeral: true
            };
          }
          
          // Check if already claimed
          if (drop.dropType === 'once_per_player') {
            if (drop.claimedBy?.includes(context.userId)) {
              console.log(`‚ùå User ${context.userId} already claimed item at ${coord}`);
              return {
                content: '‚ùå You have already taken this item!',
                ephemeral: true
              };
            }
          } else if (drop.dropType === 'once_per_season') {
            if (drop.claimedBy) {
              console.log(`‚ùå Item at ${coord} already claimed by ${drop.claimedBy}`);
              return {
                content: '‚ùå This item has already been taken by someone else!',
                ephemeral: true
              };
            }
          }
          
          // Give item to player
          const item = safariData[context.guildId]?.items?.[drop.itemId];
          if (!item) {
            return {
              content: '‚ùå Item configuration not found.',
              ephemeral: true
            };
          }
          
          // Update player inventory  
          const playerData = await loadPlayerData();
          const guildPlayerData = playerData[context.guildId]?.players?.[context.userId]?.safari || {};
          
          if (!guildPlayerData.inventory) guildPlayerData.inventory = {};
          guildPlayerData.inventory[drop.itemId] = (guildPlayerData.inventory[drop.itemId] || 0) + 1;
          
          // Save the data
          if (!playerData[context.guildId]) playerData[context.guildId] = { players: {} };
          if (!playerData[context.guildId].players[context.userId]) playerData[context.guildId].players[context.userId] = {};
          playerData[context.guildId].players[context.userId].safari = guildPlayerData;
          
          await savePlayerData(playerData);
          
          // Mark as claimed
          if (drop.dropType === 'once_per_player') {
            if (!drop.claimedBy) drop.claimedBy = [];
            drop.claimedBy.push(context.userId);
          } else {
            drop.claimedBy = context.userId;
          }
          
          await saveSafariContent(safariData);
          
          // Update anchor message if needed
          if (drop.dropType === 'once_per_season') {
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            await safeUpdateAnchorMessage(context.guildId, coord, client);
          }
          
          console.log(`‚úÖ SUCCESS: map_item_drop_player - gave ${drop.itemId} to ${context.userId}`);
          
          // Get config for display names
          const config = safariData[context.guildId]?.safariConfig || {};
          const inventoryName = config.inventoryName || 'Inventory';
          
          return {
            content: `‚úÖ You found **${item.emoji || 'üì¶'} ${item.name}**!\n\nIt has been added to your ${inventoryName}.`,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_drop_config_')) {
      // Handle currency drop configuration button
      return ButtonHandlerFactory.create({
        id: 'map_currency_drop_config',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          try {
            const parts = context.customId.replace('map_currency_drop_config_', '').split('_');
            const coord = parts[0];
            const dropIndex = parseInt(parts[1]);
            
            console.log(`üí∞ START: map_currency_drop_config - coord ${coord}, index ${dropIndex}`);
            
            // Load current data
            const { loadSafariContent } = await import('./safariManager.js');
            const safariData = await loadSafariContent();
            const activeMapId = safariData[context.guildId]?.maps?.active;
            const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
            const dropConfig = coordData?.currencyDrops?.[dropIndex];
            
            if (!coordData || !dropConfig) {
              console.log(`‚ùå FAILED: map_currency_drop_config - location or drop not found`);
              return {
                content: '‚ùå Location or currency drop not found.',
                ephemeral: true
              };
            }
            
            // Get currency config
            const config = safariData[context.guildId]?.safariConfig || {};
            const currencyEmoji = config.currencyEmoji || 'ü™ô';
            const currencyName = config.currencyName || 'coins';
            
            console.log(`‚úÖ SUCCESS: map_currency_drop_config - showing config for drop ${dropIndex} at ${coord}`);
            
            return {
              components: [{
                type: 17, // Container
                components: [
                  {
                    type: 10, // Text Display
                    content: `# Configure ${currencyEmoji} Currency Drop\n\n**Location:** ${coord}\n**Amount:** ${dropConfig.amount} ${currencyName}`
                  },
                  { type: 14 }, // Separator
                  {
                    type: 10, // Text Display - Preview
                    content: `**Button Preview:**\n${dropConfig.buttonEmoji} ${dropConfig.buttonText}\n\n**Current Setting:** ${dropConfig.dropType === 'once_per_player' ? 'One per player' : 'One per entire season'}`
                  },
                  { type: 14 }, // Separator
                  {
                    type: 1, // Action Row - Button style select
                    components: [{
                      type: 3, // String Select
                      custom_id: `map_currency_drop_style_${coord}_${dropIndex}`,
                      placeholder: 'Select button style...',
                      options: [
                        { label: 'Primary (Blue)', value: '1', default: dropConfig.buttonStyle === 1 },
                        { label: 'Secondary (Grey)', value: '2', default: dropConfig.buttonStyle === 2 },
                        { label: 'Success (Green)', value: '3', default: dropConfig.buttonStyle === 3 },
                        { label: 'Danger (Red)', value: '4', default: dropConfig.buttonStyle === 4 }
                      ]
                    }]
                  },
                  {
                    type: 1, // Action Row - Drop type select
                    components: [{
                      type: 3, // String Select
                      custom_id: `map_currency_drop_type_${coord}_${dropIndex}`,
                      placeholder: 'How many are available?',
                      options: [
                        { 
                          label: 'One per player', 
                          value: 'once_per_player',
                          description: 'Each player can collect once',
                          default: dropConfig.dropType === 'once_per_player'
                        },
                        { 
                          label: 'One per entire season', 
                          value: 'once_per_season',
                          description: 'Only one player can collect',
                          default: dropConfig.dropType === 'once_per_season'
                        }
                      ]
                    }]
                  },
                  { type: 14 }, // Separator
                  {
                    type: 1, // Action Row - Actions
                    components: [
                      {
                        type: 2, // Button
                        custom_id: `map_currency_edit_${coord}_${dropIndex}`,
                        label: 'Edit Amount/Text',
                        style: 2,
                        emoji: { name: '‚úèÔ∏è' }
                      },
                      {
                        type: 2, // Button
                        custom_id: `map_currency_drop_save_${coord}_${dropIndex}`,
                        label: 'Save Drop',
                        style: 3,
                        emoji: { name: '‚úÖ' }
                      },
                      {
                        type: 2, // Button
                        custom_id: `map_currency_drop_remove_${coord}_${dropIndex}`,
                        label: 'Remove Drop',
                        style: 4,
                        emoji: { name: 'üóëÔ∏è' }
                      }
                    ]
                  },
                  {
                    type: 1, // Action Row - Back button
                    components: [{
                      type: 2, // Button
                      custom_id: `entity_field_group_map_cell_${coord}_items`,
                      label: 'Back to Drops',
                      style: 2,
                      emoji: { name: '‚¨ÖÔ∏è' }
                    }]
                  }
                ]
              }],
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
            };
          } catch (error) {
            console.error(`‚ùå Error in map_currency_drop_config:`, error);
            return {
              content: '‚ùå Error configuring currency drop.',
              ephemeral: true
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_drop_') && 
                !custom_id.includes('_modal_') && 
                !custom_id.startsWith('map_currency_drop_config_') &&
                !custom_id.startsWith('map_currency_drop_style_') &&
                !custom_id.startsWith('map_currency_drop_type_') &&
                !custom_id.startsWith('map_currency_drop_save_') &&
                !custom_id.startsWith('map_currency_drop_remove_')) {
      // Handle currency drop button click from players
      return ButtonHandlerFactory.create({
        id: 'map_currency_drop_player',
        ephemeral: true,
        handler: async (context) => {
          // Parse: map_currency_drop_{coord}_{index}
          const parts = context.customId.replace('map_currency_drop_', '').split('_');
          const coord = parts[0];
          const dropIndex = parseInt(parts[1]);
          
          console.log(`ü™ô START: map_currency_drop_player - user ${context.userId}, coord ${coord}, index ${dropIndex}`);
          
          // Load safari data
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          const drop = coordData?.currencyDrops?.[dropIndex];
          
          if (!drop) {
            return {
              content: '‚ùå Currency drop not found.',
              ephemeral: true
            };
          }
          
          // Check if already claimed
          if (drop.dropType === 'once_per_player') {
            if (drop.claimedBy?.includes(context.userId)) {
              console.log(`‚ùå User ${context.userId} already claimed currency at ${coord}`);
              return {
                content: '‚ùå You have already collected this currency!',
                ephemeral: true
              };
            }
          } else if (drop.dropType === 'once_per_season') {
            if (drop.claimedBy) {
              console.log(`‚ùå Currency at ${coord} already claimed by ${drop.claimedBy}`);
              return {
                content: '‚ùå This currency has already been collected by someone else!',
                ephemeral: true
              };
            }
          }
          
          // Give currency to player
          const playerData = await loadPlayerData();
          const guildPlayerData = playerData[context.guildId]?.players?.[context.userId]?.safari || {};
          
          guildPlayerData.currency = (guildPlayerData.currency || 0) + drop.amount;
          
          // Save the data
          if (!playerData[context.guildId]) playerData[context.guildId] = { players: {} };
          if (!playerData[context.guildId].players[context.userId]) playerData[context.guildId].players[context.userId] = {};
          playerData[context.guildId].players[context.userId].safari = guildPlayerData;
          
          await savePlayerData(playerData);
          
          // Mark as claimed
          if (drop.dropType === 'once_per_player') {
            if (!drop.claimedBy) drop.claimedBy = [];
            drop.claimedBy.push(context.userId);
          } else {
            drop.claimedBy = context.userId;
          }
          
          await saveSafariContent(safariData);
          
          // Update anchor message if needed
          if (drop.dropType === 'once_per_season') {
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            await safeUpdateAnchorMessage(context.guildId, coord, client);
          }
          
          console.log(`‚úÖ SUCCESS: map_currency_drop_player - gave ${drop.amount} currency to ${context.userId}`);
          
          // Get config for display names
          const config = safariData[context.guildId]?.safariConfig || {};
          const currencyName = config.currencyName || 'coins';
          const currencyEmoji = config.currencyEmoji || 'ü™ô';
          
          return {
            content: `‚úÖ You collected **${drop.amount} ${currencyEmoji} ${currencyName}**!\n\nYour balance: ${guildPlayerData.currency} ${currencyEmoji}`,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_drop_style_')) {
      // Handle currency drop style selection
      return ButtonHandlerFactory.create({
        id: 'map_currency_drop_style',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const parts = context.customId.replace('map_currency_drop_style_', '').split('_');
          const coord = parts[0];
          const dropIndex = parseInt(parts[1]);
          const selectedStyle = parseInt(context.values[0]);
          
          // Update drop style
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (coordData?.currencyDrops?.[dropIndex]) {
            coordData.currencyDrops[dropIndex].buttonStyle = selectedStyle;
            await saveSafariContent(safariData);
            
            // Update anchor message
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            await safeUpdateAnchorMessage(context.guildId, coord, client);
          }
          
          // Show updated configuration
          const config = safariData[context.guildId]?.safariConfig || {};
          const currencyEmoji = config.currencyEmoji || 'ü™ô';
          const currencyName = config.currencyName || 'coins';
          const dropConfig = coordData.currencyDrops[dropIndex];
          
          return {
            components: [{
              type: 17, // Container
              components: [
                {
                  type: 10, // Text Display
                  content: `# Configure ${currencyEmoji} Currency Drop\n\n**Location:** ${coord}\n**Amount:** ${dropConfig.amount} ${currencyName}`
                },
                { type: 14 }, // Separator
                {
                  type: 10, // Text Display - Preview
                  content: `**Button Preview:**\n${dropConfig.buttonEmoji} ${dropConfig.buttonText}\n\n**Current Setting:** ${dropConfig.dropType === 'once_per_player' ? 'One per player' : 'One per entire season'}`
                },
                { type: 14 }, // Separator
                {
                  type: 1, // Action Row - Button style select
                  components: [{
                    type: 3, // String Select
                    custom_id: `map_currency_drop_style_${coord}_${dropIndex}`,
                    placeholder: 'Select button style...',
                    options: [
                      { label: 'Primary (Blue)', value: '1', default: dropConfig.buttonStyle === 1 },
                      { label: 'Secondary (Grey)', value: '2', default: dropConfig.buttonStyle === 2 },
                      { label: 'Success (Green)', value: '3', default: dropConfig.buttonStyle === 3 },
                      { label: 'Danger (Red)', value: '4', default: dropConfig.buttonStyle === 4 }
                    ]
                  }]
                },
                {
                  type: 1, // Action Row - Drop type select
                  components: [{
                    type: 3, // String Select
                    custom_id: `map_currency_drop_type_${coord}_${dropIndex}`,
                    placeholder: 'How many are available?',
                    options: [
                      { 
                        label: 'One per player', 
                        value: 'once_per_player',
                        description: 'Each player can collect once',
                        default: dropConfig.dropType === 'once_per_player'
                      },
                      { 
                        label: 'One per entire season', 
                        value: 'once_per_season',
                        description: 'Only one player can collect',
                        default: dropConfig.dropType === 'once_per_season'
                      }
                    ]
                  }]
                },
                { type: 14 }, // Separator
                {
                  type: 1, // Action Row - Actions
                  components: [
                    {
                      type: 2, // Button
                      custom_id: `map_currency_edit_${coord}_${dropIndex}`,
                      label: 'Edit Amount/Text',
                      style: 2,
                      emoji: { name: '‚úèÔ∏è' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `map_currency_drop_save_${coord}_${dropIndex}`,
                      label: 'Save Drop',
                      style: 3,
                      emoji: { name: '‚úÖ' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `map_currency_drop_remove_${coord}_${dropIndex}`,
                      label: 'Remove Drop',
                      style: 4,
                      emoji: { name: 'üóëÔ∏è' }
                    }
                  ]
                },
                {
                  type: 1, // Action Row - Back button
                  components: [{
                    type: 2, // Button
                    custom_id: `entity_field_group_map_cell_${coord}_items`,
                    label: 'Back to Drops',
                    style: 2,
                    emoji: { name: '‚¨ÖÔ∏è' }
                  }]
                }
              ]
            }],
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_drop_type_')) {
      // Handle currency drop type selection
      return ButtonHandlerFactory.create({
        id: 'map_currency_drop_type',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const parts = context.customId.replace('map_currency_drop_type_', '').split('_');
          const coord = parts[0];
          const dropIndex = parseInt(parts[1]);
          const dropType = context.values[0];
          
          // Update drop type
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (coordData?.currencyDrops?.[dropIndex]) {
            coordData.currencyDrops[dropIndex].dropType = dropType;
            // Reset claims when changing type
            coordData.currencyDrops[dropIndex].claimedBy = dropType === 'once_per_player' ? [] : null;
            await saveSafariContent(safariData);
            
            // Update anchor message
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            await safeUpdateAnchorMessage(context.guildId, coord, client);
          }
          
          // Show updated configuration
          const config = safariData[context.guildId]?.safariConfig || {};
          const currencyEmoji = config.currencyEmoji || 'ü™ô';
          const currencyName = config.currencyName || 'coins';
          const dropConfig = coordData.currencyDrops[dropIndex];
          
          return {
            components: [{
              type: 17, // Container
              components: [
                {
                  type: 10, // Text Display
                  content: `# Configure ${currencyEmoji} Currency Drop\n\n**Location:** ${coord}\n**Amount:** ${dropConfig.amount} ${currencyName}`
                },
                { type: 14 }, // Separator
                {
                  type: 10, // Text Display - Preview
                  content: `**Button Preview:**\n${dropConfig.buttonEmoji} ${dropConfig.buttonText}\n\n**Current Setting:** ${dropConfig.dropType === 'once_per_player' ? 'One per player' : 'One per entire season'}`
                },
                { type: 14 }, // Separator
                {
                  type: 1, // Action Row - Button style select
                  components: [{
                    type: 3, // String Select
                    custom_id: `map_currency_drop_style_${coord}_${dropIndex}`,
                    placeholder: 'Select button style...',
                    options: [
                      { label: 'Primary (Blue)', value: '1', default: dropConfig.buttonStyle === 1 },
                      { label: 'Secondary (Grey)', value: '2', default: dropConfig.buttonStyle === 2 },
                      { label: 'Success (Green)', value: '3', default: dropConfig.buttonStyle === 3 },
                      { label: 'Danger (Red)', value: '4', default: dropConfig.buttonStyle === 4 }
                    ]
                  }]
                },
                {
                  type: 1, // Action Row - Drop type select
                  components: [{
                    type: 3, // String Select
                    custom_id: `map_currency_drop_type_${coord}_${dropIndex}`,
                    placeholder: 'How many are available?',
                    options: [
                      { 
                        label: 'One per player', 
                        value: 'once_per_player',
                        description: 'Each player can collect once',
                        default: dropConfig.dropType === 'once_per_player'
                      },
                      { 
                        label: 'One per entire season', 
                        value: 'once_per_season',
                        description: 'Only one player can collect',
                        default: dropConfig.dropType === 'once_per_season'
                      }
                    ]
                  }]
                },
                { type: 14 }, // Separator
                {
                  type: 1, // Action Row - Actions
                  components: [
                    {
                      type: 2, // Button
                      custom_id: `map_currency_edit_${coord}_${dropIndex}`,
                      label: 'Edit Amount/Text',
                      style: 2,
                      emoji: { name: '‚úèÔ∏è' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `map_currency_drop_save_${coord}_${dropIndex}`,
                      label: 'Save Drop',
                      style: 3,
                      emoji: { name: '‚úÖ' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `map_currency_drop_remove_${coord}_${dropIndex}`,
                      label: 'Remove Drop',
                      style: 4,
                      emoji: { name: 'üóëÔ∏è' }
                    }
                  ]
                },
                {
                  type: 1, // Action Row - Back button
                  components: [{
                    type: 2, // Button
                    custom_id: `entity_field_group_map_cell_${coord}_items`,
                    label: 'Back to Drops',
                    style: 2,
                    emoji: { name: '‚¨ÖÔ∏è' }
                  }]
                }
              ]
            }],
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_drop_style_')) {
      // Handle item drop style selection
      return ButtonHandlerFactory.create({
        id: 'map_drop_style',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const parts = context.customId.replace('map_drop_style_', '').split('_');
          const coord = parts[0];
          const itemId = parts.slice(1).join('_');
          const selectedStyle = parseInt(context.values[0]);
          
          // Update drop style
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          // Initialize itemDrops if needed
          if (!coordData.itemDrops) {
            coordData.itemDrops = [];
          }
          
          let dropIndex = coordData.itemDrops.findIndex(drop => drop.itemId === itemId);
          
          // Create drop if it doesn't exist
          if (dropIndex === -1) {
            const item = safariData[context.guildId]?.items?.[itemId];
            if (!item) {
              return {
                content: '‚ùå Item not found.',
                ephemeral: true
              };
            }
            
            const newDrop = {
              itemId: itemId,
              buttonText: `Open ${item.name}`,
              buttonEmoji: item.emoji || 'üì¶',
              buttonStyle: selectedStyle,
              dropType: 'once_per_player',
              claimedBy: []
            };
            
            coordData.itemDrops.push(newDrop);
            dropIndex = coordData.itemDrops.length - 1;
          } else {
            // Update existing drop
            coordData.itemDrops[dropIndex].buttonStyle = selectedStyle;
          }
          
          await saveSafariContent(safariData);
          
          // Update anchor message
          const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
          await safeUpdateAnchorMessage(context.guildId, coord, client);
          
          // Return to the drop configuration interface
          const item = safariData[context.guildId]?.items?.[itemId];
          const updatedDrop = coordData.itemDrops[dropIndex];
          
          return {
            components: [{
              type: 17, // Container
              components: [
                {
                  type: 10, // Text Display
                  content: `# Configure ${item.emoji || 'üì¶'} ${item.name} Drop\n\n**Location:** ${coord}`
                },
                { type: 14 }, // Separator
                {
                  type: 10, // Text Display - Preview
                  content: `**Button Preview:**\n${updatedDrop.buttonEmoji} ${updatedDrop.buttonText}\n\n**Current Setting:** ${updatedDrop.dropType === 'once_per_player' ? 'One per player' : 'One per entire season'}`
                },
                { type: 14 }, // Separator
                {
                  type: 1, // Action Row - Button style select
                  components: [{
                    type: 3, // String Select
                    custom_id: `map_drop_style_${coord}_${itemId}`,
                    placeholder: 'Select button style...',
                    options: [
                      { label: 'Primary (Blue)', value: '1', default: updatedDrop.buttonStyle === 1 },
                      { label: 'Secondary (Grey)', value: '2', default: updatedDrop.buttonStyle === 2 },
                      { label: 'Success (Green)', value: '3', default: updatedDrop.buttonStyle === 3 },
                      { label: 'Danger (Red)', value: '4', default: updatedDrop.buttonStyle === 4 }
                    ]
                  }]
                },
                {
                  type: 1, // Action Row - Drop type select
                  components: [{
                    type: 3, // String Select
                    custom_id: `map_drop_type_${coord}_${itemId}`,
                    placeholder: 'How many are available?',
                    options: [
                      { 
                        label: 'One per player', 
                        value: 'once_per_player',
                        description: 'Each player can claim this item once',
                        default: updatedDrop.dropType === 'once_per_player'
                      },
                      { 
                        label: 'One per entire season', 
                        value: 'once_per_season',
                        description: 'Only one player can claim this item',
                        default: updatedDrop.dropType === 'once_per_season'
                      }
                    ]
                  }]
                },
                {
                  type: 1, // Action Row - Configuration buttons
                  components: [
                    {
                      type: 2, // Button
                      custom_id: `map_drop_text_${coord}_${itemId}`,
                      label: 'Edit Button Text',
                      style: 2,
                      emoji: { name: '‚úèÔ∏è' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `map_item_drop_save_${coord}_${itemId}`,
                      label: 'Save Drop',
                      style: 3,
                      emoji: { name: '‚úÖ' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `map_item_drop_remove_${coord}_${itemId}`,
                      label: 'Remove Drop',
                      style: 4,
                      emoji: { name: 'üóëÔ∏è' }
                    }
                  ]
                },
                {
                  type: 1, // Action Row - Back button
                  components: [{
                    type: 2, // Button
                    custom_id: `entity_field_group_map_cell_${coord}_items`,
                    label: 'Back to Drops',
                    style: 2,
                    emoji: { name: '‚¨ÖÔ∏è' }
                  }]
                }
              ]
            }],
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_drop_type_')) {
      // Handle item drop type selection
      return ButtonHandlerFactory.create({
        id: 'map_drop_type',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const parts = context.customId.replace('map_drop_type_', '').split('_');
          const coord = parts[0];
          const itemId = parts.slice(1).join('_');
          const dropType = context.values[0];
          
          // Update drop type
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          const dropIndex = coordData?.itemDrops?.findIndex(drop => drop.itemId === itemId);
          if (dropIndex >= 0) {
            coordData.itemDrops[dropIndex].dropType = dropType;
            // Reset claims when changing type
            coordData.itemDrops[dropIndex].claimedBy = dropType === 'once_per_player' ? [] : null;
            await saveSafariContent(safariData);
            
            // Update anchor message
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            await safeUpdateAnchorMessage(context.guildId, coord, client);
          }
          
          // Return to the drop configuration interface
          const item = safariData[context.guildId]?.items?.[itemId];
          const updatedDrop = coordData.itemDrops[dropIndex];
          
          return {
            components: [{
              type: 17, // Container
              components: [
                {
                  type: 10, // Text Display
                  content: `# Configure ${item.emoji || 'üì¶'} ${item.name} Drop\n\n**Location:** ${coord}`
                },
                { type: 14 }, // Separator
                {
                  type: 10, // Text Display - Preview
                  content: `**Button Preview:**\n${updatedDrop.buttonEmoji} ${updatedDrop.buttonText}\n\n**Current Setting:** ${updatedDrop.dropType === 'once_per_player' ? 'One per player' : 'One per entire season'}`
                },
                { type: 14 }, // Separator
                {
                  type: 1, // Action Row - Button style select
                  components: [{
                    type: 3, // String Select
                    custom_id: `map_drop_style_${coord}_${itemId}`,
                    placeholder: 'Select button style...',
                    options: [
                      { label: 'Primary (Blue)', value: '1', default: updatedDrop.buttonStyle === 1 },
                      { label: 'Secondary (Grey)', value: '2', default: updatedDrop.buttonStyle === 2 },
                      { label: 'Success (Green)', value: '3', default: updatedDrop.buttonStyle === 3 },
                      { label: 'Danger (Red)', value: '4', default: updatedDrop.buttonStyle === 4 }
                    ]
                  }]
                },
                {
                  type: 1, // Action Row - Drop type select
                  components: [{
                    type: 3, // String Select
                    custom_id: `map_drop_type_${coord}_${itemId}`,
                    placeholder: 'How many are available?',
                    options: [
                      { 
                        label: 'One per player', 
                        value: 'once_per_player',
                        description: 'Each player can claim this item once',
                        default: updatedDrop.dropType === 'once_per_player'
                      },
                      { 
                        label: 'One per entire season', 
                        value: 'once_per_season',
                        description: 'Only one player can claim this item',
                        default: updatedDrop.dropType === 'once_per_season'
                      }
                    ]
                  }]
                },
                {
                  type: 1, // Action Row - Configuration buttons
                  components: [
                    {
                      type: 2, // Button
                      custom_id: `map_drop_text_${coord}_${itemId}`,
                      label: 'Edit Button Text',
                      style: 2,
                      emoji: { name: '‚úèÔ∏è' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `map_item_drop_save_${coord}_${itemId}`,
                      label: 'Save Drop',
                      style: 3,
                      emoji: { name: '‚úÖ' }
                    },
                    {
                      type: 2, // Button
                      custom_id: `map_item_drop_remove_${coord}_${itemId}`,
                      label: 'Remove Drop',
                      style: 4,
                      emoji: { name: 'üóëÔ∏è' }
                    }
                  ]
                },
                {
                  type: 1, // Action Row - Back button
                  components: [{
                    type: 2, // Button
                    custom_id: `entity_field_group_map_cell_${coord}_items`,
                    label: 'Back to Drops',
                    style: 2,
                    emoji: { name: '‚¨ÖÔ∏è' }
                  }]
                }
              ]
            }],
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_drop_save_')) {
      // Handle currency drop save button
      return ButtonHandlerFactory.create({
        id: 'map_currency_drop_save',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('map_currency_drop_save_', '').split('_');
          const coord = parts[0];
          const dropIndex = parseInt(parts[1]);
          
          console.log(`üíæ START: map_currency_drop_save - coord ${coord}, index ${dropIndex}`);
          
          // For now, just return to drops management since changes are saved immediately
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            selectedId: coord,
            activeFieldGroup: 'items',
            mode: 'edit'
          });
          
          console.log(`‚úÖ SUCCESS: map_currency_drop_save - returning to drops management`);
          
          return {
            ...ui,
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_drop_remove_')) {
      // Handle currency drop remove button
      return ButtonHandlerFactory.create({
        id: 'map_currency_drop_remove',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('map_currency_drop_remove_', '').split('_');
          const coord = parts[0];
          const dropIndex = parseInt(parts[1]);
          
          console.log(`üóëÔ∏è START: map_currency_drop_remove - coord ${coord}, index ${dropIndex}`);
          
          // Load and remove the currency drop
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (coordData?.currencyDrops && dropIndex >= 0 && dropIndex < coordData.currencyDrops.length) {
            coordData.currencyDrops.splice(dropIndex, 1);
            await saveSafariContent(safariData);
            
            // Update anchor message
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            await safeUpdateAnchorMessage(context.guildId, coord, client);
          }
          
          // Return to drops management interface
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            selectedId: coord,
            activeFieldGroup: 'items',
            mode: 'edit'
          });
          
          console.log(`‚úÖ SUCCESS: map_currency_drop_remove - drop removed`);
          
          return {
            ...ui,
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_drop_text_')) {
      // Show modal for item drop button text
      return ButtonHandlerFactory.create({
        id: 'map_drop_text',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('map_drop_text_', '').split('_');
          const coord = parts[0];
          const itemId = parts.slice(1).join('_');
          
          // Get current drop data
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          const drop = coordData?.itemDrops?.find(d => d.itemId === itemId);
          
          // Show modal
          const modal = new ModalBuilder()
            .setCustomId(`map_drop_text_modal_${coord}_${itemId}`)
            .setTitle(`Configure Button for ${coord}`);
            
          const buttonTextInput = new TextInputBuilder()
            .setCustomId('buttonText')
            .setLabel('Button Text')
            .setStyle(TextInputStyle.Short)
            .setValue(drop?.buttonText || 'Open')
            .setRequired(true)
            .setMaxLength(80);
            
          const buttonEmojiInput = new TextInputBuilder()
            .setCustomId('buttonEmoji')
            .setLabel('Button Emoji')
            .setStyle(TextInputStyle.Short)
            .setValue(drop?.buttonEmoji || 'üì¶')
            .setRequired(false)
            .setMaxLength(100);
            
          modal.addComponents(
            new ActionRowBuilder().addComponents(buttonTextInput),
            new ActionRowBuilder().addComponents(buttonEmojiInput)
          );
          
          return res.send({
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          });
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_drop_save_')) {
      // Save item drop configuration
      return ButtonHandlerFactory.create({
        id: 'map_drop_save',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('map_drop_save_', '').split('_');
          const coord = parts[0];
          const itemId = parts.slice(1).join('_');
          
          console.log(`üíæ START: map_drop_save - coord ${coord}, item ${itemId}`);
          
          // Load and save data
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (!coordData) {
            return {
              content: '‚ùå Location not found.',
              ephemeral: true
            };
          }
          
          // Initialize itemDrops if needed
          if (!coordData.itemDrops) {
            coordData.itemDrops = [];
          }
          
          // Check if drop already exists
          const dropIndex = coordData.itemDrops.findIndex(drop => drop.itemId === itemId);
          if (dropIndex === -1) {
            // Get item data for defaults
            const item = safariData[context.guildId]?.items?.[itemId];
            if (!item) {
              return {
                content: '‚ùå Item not found.',
                ephemeral: true
              };
            }
            
            // Add new drop with default values
            coordData.itemDrops.push({
              itemId: itemId,
              buttonText: `Open ${item.name}`,
              buttonEmoji: item.emoji || 'üì¶',
              buttonStyle: 2,
              dropType: 'once_per_player',
              claimedBy: []
            });
          }
          
          await saveSafariContent(safariData);
          
          // Update anchor message
          const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
          await safeUpdateAnchorMessage(context.guildId, coord, client);
          
          // Return to entity management UI
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            selectedId: coord,
            mode: 'edit'
          });
          
          console.log(`‚úÖ SUCCESS: map_drop_save - saved drop for ${itemId} at ${coord}`);
          
          return {
            ...ui,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_drop_remove_')) {
      // Remove item drop
      return ButtonHandlerFactory.create({
        id: 'map_drop_remove',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('map_drop_remove_', '').split('_');
          const coord = parts[0];
          const itemId = parts.slice(1).join('_');
          
          // Remove drop
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (coordData?.itemDrops) {
            coordData.itemDrops = coordData.itemDrops.filter(drop => drop.itemId !== itemId);
            await saveSafariContent(safariData);
            
            // Update anchor message
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            await safeUpdateAnchorMessage(context.guildId, coord, client);
          }
          
          // Return to entity management UI
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            selectedId: coord,
            mode: 'edit'
          });
          
          return {
            ...ui,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_drop_reset_')) {
      // Reset item drop claims
      return ButtonHandlerFactory.create({
        id: 'map_drop_reset',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('map_drop_reset_', '').split('_');
          const coord = parts[0];
          const itemId = parts.slice(1).join('_');
          
          // Reset claims
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          const dropIndex = coordData?.itemDrops?.findIndex(drop => drop.itemId === itemId);
          if (dropIndex >= 0) {
            const drop = coordData.itemDrops[dropIndex];
            drop.claimedBy = drop.dropType === 'once_per_player' ? [] : null;
            await saveSafariContent(safariData);
            
            // Update anchor message if needed
            if (drop.dropType === 'once_per_season') {
              const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
              await safeUpdateAnchorMessage(context.guildId, coord, client);
            }
          }
          
          return {
            content: '‚úÖ Drop claims have been reset. Players can now claim this item again.',
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_style_')) {
      // Handle currency drop style selection
      return ButtonHandlerFactory.create({
        id: 'map_currency_style',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const parts = context.customId.replace('map_currency_style_', '').split('_');
          const coord = parts[0];
          const dropIndex = parts.length > 1 ? parseInt(parts[1]) : 0; // Default to 0 for legacy support
          const selectedStyle = parseInt(context.values[0]);
          
          // Update style
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (coordData?.currencyDrops?.[dropIndex]) {
            coordData.currencyDrops[dropIndex].buttonStyle = selectedStyle;
            await saveSafariContent(safariData);
            
            // Update anchor message
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            await safeUpdateAnchorMessage(context.guildId, coord, client);
          }
          
          // Return to drop management interface
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            selectedId: coord,
            mode: 'edit',
            activeFieldGroup: 'items'
          });
          
          return {
            ...ui
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_type_')) {
      // Handle currency drop type selection
      return ButtonHandlerFactory.create({
        id: 'map_currency_type',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const parts = context.customId.replace('map_currency_type_', '').split('_');
          const coord = parts[0];
          const dropIndex = parts.length > 1 ? parseInt(parts[1]) : 0; // Default to 0 for legacy support
          const dropType = context.values[0];
          
          // Update type
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (coordData?.currencyDrops?.[dropIndex]) {
            coordData.currencyDrops[dropIndex].dropType = dropType;
            coordData.currencyDrops[dropIndex].claimedBy = dropType === 'once_per_player' ? [] : null;
            await saveSafariContent(safariData);
            
            // Update anchor message
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            await safeUpdateAnchorMessage(context.guildId, coord, client);
          }
          
          // Return to drop management interface
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            selectedId: coord,
            mode: 'edit',
            activeFieldGroup: 'items'
          });
          
          return {
            ...ui
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_edit_')) {
      // Show modal to edit currency amount/text
      return ButtonHandlerFactory.create({
        id: 'map_currency_edit',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('map_currency_edit_', '').split('_');
          const coord = parts[0];
          const dropIndex = parts.length > 1 ? parseInt(parts[1]) : 0; // Default to 0 for legacy support
          console.log(`üí∞ START: map_currency_edit - coord ${coord}, dropIndex ${dropIndex}`);
          
          // Load current drop data to pre-populate modal
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          const drop = coordData?.currencyDrops?.[dropIndex];
          
          // Create currency drop modal with current values
          const { ModalBuilder, TextInputBuilder, TextInputStyle, ActionRowBuilder } = await import('discord.js');
          const modal = new ModalBuilder()
            .setCustomId(`map_currency_drop_modal_${coord}_${dropIndex}`)
            .setTitle(`Edit Currency Drop for ${coord}`);
            
          const amountInput = new TextInputBuilder()
            .setCustomId('amount')
            .setLabel('Currency Amount')
            .setStyle(TextInputStyle.Short)
            .setValue(drop?.amount?.toString() || '100')
            .setPlaceholder('100')
            .setRequired(true)
            .setMinLength(1)
            .setMaxLength(10);
            
          const buttonTextInput = new TextInputBuilder()
            .setCustomId('button_text')
            .setLabel('Button Text')
            .setStyle(TextInputStyle.Short)
            .setValue(drop?.buttonText || 'Collect Coins')
            .setPlaceholder('Collect Coins')
            .setRequired(true)
            .setMaxLength(80);
            
          const buttonEmojiInput = new TextInputBuilder()
            .setCustomId('button_emoji')
            .setLabel('Button Emoji')
            .setStyle(TextInputStyle.Short)
            .setValue(drop?.buttonEmoji || 'ü™ô')
            .setPlaceholder('ü™ô or <:custom:123456>')
            .setRequired(false)
            .setMaxLength(100);
            
          modal.addComponents(
            new ActionRowBuilder().addComponents(amountInput),
            new ActionRowBuilder().addComponents(buttonTextInput),
            new ActionRowBuilder().addComponents(buttonEmojiInput)
          );
          
          console.log(`‚úÖ SUCCESS: map_currency_edit - showing modal for ${coord}`);
          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_remove_')) {
      // Remove currency drop
      return ButtonHandlerFactory.create({
        id: 'map_currency_remove',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('map_currency_remove_', '').split('_');
          const coord = parts[0];
          const dropIndex = parts.length > 1 ? parseInt(parts[1]) : 0; // Default to 0 for legacy support
          
          // Remove currency drop
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (coordData?.currencyDrops) {
            // Remove specific drop by index
            coordData.currencyDrops.splice(dropIndex, 1);
            await saveSafariContent(safariData);
            
            // Update anchor message
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            await safeUpdateAnchorMessage(context.guildId, coord, client);
          }
          
          // Return to entity management UI
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            selectedId: coord,
            mode: 'edit'
          });
          
          return {
            ...ui,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_currency_reset_')) {
      // Reset currency drop claims
      return ButtonHandlerFactory.create({
        id: 'map_currency_reset',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const parts = context.customId.replace('map_currency_reset_', '').split('_');
          const coord = parts[0];
          const dropIndex = parts.length > 1 ? parseInt(parts[1]) : 0; // Default to 0 for legacy support
          
          // Reset claims
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          const coordData = safariData[context.guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
          
          if (coordData?.currencyDrops?.[dropIndex]) {
            const drop = coordData.currencyDrops[dropIndex];
            drop.claimedBy = drop.dropType === 'once_per_player' ? [] : null;
            await saveSafariContent(safariData);
            
            // Update anchor message if needed
            if (drop.dropType === 'once_per_season') {
              const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
              await safeUpdateAnchorMessage(context.guildId, coord, client);
            }
          }
          
          return {
            content: '‚úÖ Currency claims have been reset. Players can now collect this currency again.',
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_grid_edit_')) {
      // Handle grid content editing
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        const coord = custom_id.replace('map_grid_edit_', '');
        
        console.log(`üîç DEBUG: Processing map_grid_edit for coord ${coord} by user ${userId}`);
        
        // Load safari content to get current data
        const { loadSafariContent } = await import('./mapExplorer.js');
        const safariData = await loadSafariContent();
        const activeMapId = safariData[guildId]?.maps?.active;
        const mapData = safariData[guildId]?.maps?.[activeMapId];
        const coordData = mapData?.coordinates?.[coord];
        
        if (!coordData) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Location not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Show edit modal
        const modal = new ModalBuilder()
          .setCustomId(`map_grid_edit_modal_${coord}`)
          .setTitle(`Edit Content for Location ${coord}`);
          
        const titleInput = new TextInputBuilder()
          .setCustomId('title')
          .setLabel('Location Title')
          .setStyle(TextInputStyle.Short)
          .setValue(coordData.baseContent?.title || `üìç Location ${coord}`)
          .setRequired(true)
          .setMaxLength(100);
          
        const descriptionInput = new TextInputBuilder()
          .setCustomId('description')
          .setLabel('Location Description')
          .setStyle(TextInputStyle.Paragraph)
          .setValue(coordData.baseContent?.description || '')
          .setRequired(true)
          .setMaxLength(1000);
          
        const imageInput = new TextInputBuilder()
          .setCustomId('image')
          .setLabel('Image URL (Discord CDN only)')
          .setPlaceholder('https://cdn.discordapp.com/...')
          .setStyle(TextInputStyle.Short)
          .setValue(coordData.baseContent?.image || '')
          .setRequired(false)
          .setMaxLength(500);
          
        const cluesInput = new TextInputBuilder()
          .setCustomId('clues')
          .setLabel('Clues (one per line)')
          .setStyle(TextInputStyle.Paragraph)
          .setValue((coordData.baseContent?.clues || []).join('\n'))
          .setRequired(false)
          .setMaxLength(500);
          
        const cellTypeInput = new TextInputBuilder()
          .setCustomId('cellType')
          .setLabel('Cell Type')
          .setPlaceholder('unexplored, village, forest, mountain, water, desert, special')
          .setStyle(TextInputStyle.Short)
          .setValue(coordData.cellType || 'unexplored')
          .setRequired(true)
          .setMaxLength(50);
          
        modal.addComponents(
          new ActionRowBuilder().addComponents(titleInput),
          new ActionRowBuilder().addComponents(descriptionInput),
          new ActionRowBuilder().addComponents(imageInput),
          new ActionRowBuilder().addComponents(cluesInput),
          new ActionRowBuilder().addComponents(cellTypeInput)
        );
        
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal.toJSON()
        });
        
      } catch (error) {
        console.error('Error in map_grid_edit handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå An error occurred. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('map_grid_view_')) {
      // Handle grid content viewing
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        const coord = custom_id.replace('map_grid_view_', '');
        
        console.log(`üîç DEBUG: Processing map_grid_view for coord ${coord} by user ${userId}`);
        
        // Load safari content to get current data
        const { loadSafariContent } = await import('./mapExplorer.js');
        const safariData = await loadSafariContent();
        const activeMapId = safariData[guildId]?.maps?.active;
        const mapData = safariData[guildId]?.maps?.[activeMapId];
        const coordData = mapData?.coordinates?.[coord];
        
        if (!coordData) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Location not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Build Components V2 container for content display
        const containerComponents = [];
        
        // Build content text
        let contentParts = [`# ${coordData.baseContent?.title || `üìç Location ${coord}`}`];
        
        if (coordData.baseContent?.description) {
          contentParts.push(`\n${coordData.baseContent.description}`);
        }
        
        contentParts.push(`\n**Cell Type:** ${coordData.cellType || 'unexplored'}`);
        
        if (coordData.baseContent?.clues && coordData.baseContent.clues.length > 0) {
          contentParts.push('\n**Clues:**');
          coordData.baseContent.clues.forEach(clue => {
            contentParts.push(`‚Ä¢ ${clue}`);
          });
        }
        
        // Navigation info
        contentParts.push('\n**Navigation:**');
        const navDirs = ['north', 'east', 'south', 'west'];
        navDirs.forEach(dir => {
          const nav = coordData.navigation?.[dir];
          if (nav) {
            contentParts.push(`‚Ä¢ ${dir.charAt(0).toUpperCase() + dir.slice(1)}: ${nav.to} ${nav.blocked ? '(blocked)' : ''}`);
          }
        });
        
        // Add text display component
        containerComponents.push({
          type: 10, // Text Display
          content: contentParts.join('\n')
        });
        
        // Add image as media gallery if present
        if (coordData.baseContent?.image) {
          containerComponents.push({
            type: 14 // Thin separator
          });
          containerComponents.push({
            type: 12, // Media Gallery
            items: [
              {
                media: {
                  url: coordData.baseContent.image
                }
              }
            ]
          });
        }
        
        // Create container
        const container = {
          type: 17, // Container
          accent_color: 0x5865f2, // Discord blue
          components: containerComponents
        };
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: ' ', // Discord requires content or embeds
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
            components: [container]
          }
        });
        
      } catch (error) {
        console.error('Error in map_grid_view handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå An error occurred. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_map_init_player') {
      return ButtonHandlerFactory.create({
        id: 'safari_map_init_player',
        deferred: true, // REQUIRED: This operation takes >3 seconds
        ephemeral: true,
        handler: async (context) => {
          console.log(`üó∫Ô∏è START: safari_map_init_player - user ${context.userId}`);
          
          // Import functions  
          const { initializePlayerOnMap } = await import('./safariMapAdmin.js');
          const { loadSafariContent } = await import('./safariManager.js');
          
          // Get active map
          const safariData = await loadSafariContent();
          const activeMapId = safariData[context.guildId]?.maps?.active;
          
          if (!activeMapId) {
            return {
              content: '‚ùå No active map found. Please create a map first.',
              ephemeral: true
            };
          }
          
          // Check if player is already initialized (must have currentLocation, not just startingLocation stub)
          const { loadPlayerData } = await import('./storage.js');
          const playerData = await loadPlayerData();
          const playerMapData = playerData[context.guildId]?.players?.[context.userId]?.safari?.mapProgress?.[activeMapId];

          if (playerMapData?.currentLocation) {
            return {
              content: `‚ùå You're already on the map at coordinate **${playerMapData.currentLocation}**!\n\nUse the movement interface in that channel to continue exploring.`,
              ephemeral: true
            };
          }
          
          // Determine starting coordinate: player-specific > server default > A1
          const playerStartingLoc = playerData[context.guildId]?.players?.[context.userId]?.safari?.mapProgress?.[activeMapId]?.startingLocation;
          let startingCoordinate;
          if (playerStartingLoc) {
            startingCoordinate = playerStartingLoc;
            console.log(`üìç Self-init using player-specific starting location: ${startingCoordinate}`);
          } else {
            const { getStaminaConfig } = await import('./safariManager.js');
            const staminaConfig = await getStaminaConfig(context.guildId);
            startingCoordinate = staminaConfig.defaultStartingCoordinate || 'A1';
            console.log(`üìç Self-init using server default starting location: ${startingCoordinate}`);
          }

          await initializePlayerOnMap(context.guildId, context.userId, startingCoordinate, context.client);

          // Activity log entry is added atomically inside initializePlayerOnMap

          // Get channel info for response
          const mapData = safariData[context.guildId].maps[activeMapId];
          const channelId = mapData.coordinates[startingCoordinate]?.channelId;

          console.log(`‚úÖ SUCCESS: safari_map_init_player - player initialized at ${startingCoordinate}`);
          return {
            content: `‚úÖ **Welcome to the Safari Map!**\n\nYou've been initialized at coordinate **${startingCoordinate}** with **1 stamina**.\n\nHead to <#${channelId}> to start exploring! Your movement options are waiting for you there.`,
            ephemeral: true
          };
        }
      })(req, res, client);
    // ==================== END MAP EXPLORER HANDLERS ====================
    
    // ==================== START MAP ADMIN HANDLERS ====================
    } else if (custom_id === 'safari_map_admin') {
      return ButtonHandlerFactory.create({
        id: 'safari_map_admin',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üõ°Ô∏è START: safari_map_admin - user ${context.userId}`);
          
          const { createMapAdminUI } = await import('./safariMapAdmin.js');
          
          const ui = await createMapAdminUI({
            guildId: context.guildId,
            mode: 'user_select'
          });
          
          console.log(`‚úÖ SUCCESS: safari_map_admin - showing user selection`);
          return {
            ...ui,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'safari_rounds_menu') {
      return ButtonHandlerFactory.create({
        id: 'safari_rounds_menu',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`‚è≥ START: safari_rounds_menu - user ${context.userId}`);
          
          // Load Safari data to get current round info
          const { loadSafariContent } = await import('./safariManager.js');
          const { loadPlayerData } = await import('./storage.js');
          const safariData = await loadSafariContent();
          const playerData = await loadPlayerData();
          
          const guildData = safariData[context.guildId] || {};
          const safariConfig = guildData.safariConfig || {};
          const currentRound = safariConfig.currentRound;
          const totalRounds = safariConfig.totalRounds || 3; // Default to 3 rounds
          
          // Count initialized players - those with safari data
          const guildPlayers = playerData[context.guildId]?.players || {};
          const initializedPlayers = Object.values(guildPlayers).filter(p => p.safari).length;
          
          // Dynamic button label for Round Results
          let roundResultsLabel;
          if (!currentRound || currentRound === 0) {
            roundResultsLabel = 'Start Game';
          } else if (currentRound >= 1 && currentRound <= totalRounds) {
            roundResultsLabel = `Reveal Round ${currentRound} Results`;
          } else if (currentRound > totalRounds) {
            roundResultsLabel = 'Reset Game';
          } else {
            roundResultsLabel = 'Reveal Results';
          }
          
          // Import Discord.js components
          const { ButtonBuilder, ActionRowBuilder, ButtonStyle } = await import('discord.js');
          
          // Get global stores count
          const globalStores = safariData[context.guildId]?.globalStores || [];
          
          // Round Management buttons (first row)
          const roundManagementButtons = [
            new ButtonBuilder()
              .setCustomId('safari_round_results')
              .setLabel(roundResultsLabel)
              .setStyle(ButtonStyle.Primary) // Blue
              .setEmoji('üé≤'),
            new ButtonBuilder()
              .setCustomId('safari_schedule_results')
              .setLabel('Schedule Results')
              .setStyle(ButtonStyle.Secondary)
              .setEmoji('üìÖ'),
            new ButtonBuilder()
              .setCustomId('safari_result_ordering')
              .setLabel('Result Ordering')
              .setStyle(ButtonStyle.Secondary) // Grey
              .setEmoji('üìä'),
            new ButtonBuilder()
              .setCustomId('safari_player_status')
              .setLabel('Player Status')
              .setStyle(ButtonStyle.Secondary) // Grey
              .setEmoji('üèãÔ∏è')
          ];
          
          const roundManagementRow = new ActionRowBuilder().addComponents(roundManagementButtons);
          
          // Additional management buttons (second row)
          const additionalButtons = [
            new ButtonBuilder()
              .setCustomId('safari_restock_players')
              .setLabel('Restock Players')
              .setStyle(ButtonStyle.Success) // Green
              .setEmoji('ü™£'),
            new ButtonBuilder()
              .setCustomId('safari_configure_rounds')
              .setLabel('Configure Rounds')
              .setStyle(ButtonStyle.Secondary) // Grey
              .setEmoji('‚öôÔ∏è')
          ];
          
          const additionalRow = new ActionRowBuilder().addComponents(additionalButtons);
          
          // Back button
          const backButton = new ButtonBuilder()
            .setCustomId('prod_menu_back')
            .setLabel('‚Üê Menu')
            .setStyle(ButtonStyle.Secondary);
          
          const backRow = new ActionRowBuilder().addComponents([backButton]);
          
          // Build Components V2 response
          const containerComponents = [
            {
              type: 10, // Text Display
              content: `## üèÉ‚Äç‚ôÄÔ∏è Challenges`
            },
            {
              type: 10, // Text Display
              content: `Use CastBot features to add turn-based elements to your Challenges or Safari. Run challenges in multiple rounds over 24 hour cycles, combining with the Actions feature, or as part of a more elaborate Safari Design system.\n\nRounds will allow items which have yields to accrue currency, and player attacks / defence actions to be executed when Round Results are revealed.`
            },
            { type: 14 }, // Separator
            {
              type: 10, // Text Display
              content: currentRound > totalRounds 
                ? `**Status:** Round ${totalRounds} Complete - Ready to reset | **Total Rounds:** ${totalRounds} | **Global Stores:** ${globalStores.length}`
                : (!currentRound || currentRound === 0)
                ? `**Status:** Game Not Started | **Total Rounds:** ${totalRounds} | **Players Initialized:** ${initializedPlayers} | **Global Stores:** ${globalStores.length}`
                : `**Current Round:** ${currentRound} of ${totalRounds} | **Players Initialized:** ${initializedPlayers} | **Global Stores:** ${globalStores.length}`
            },
            { type: 14 }, // Separator
            {
              type: 10, // Text Display
              content: `> **\`üéÆ Round Management\`**`
            },
            roundManagementRow.toJSON(),
            additionalRow.toJSON(),
            { type: 14 }, // Separator
            backRow.toJSON()
          ];
          
          console.log(`‚úÖ SUCCESS: safari_rounds_menu - displayed`);
          
          return {
            flags: (1 << 15) | 64, // IS_COMPONENTS_V2 | EPHEMERAL
            components: [{
              type: 17, // Container
              accent_color: 0x3498DB, // Blue
              components: containerComponents
            }]
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'safari_configure_rounds') {
      // Handle Configure Rounds button - shows modal for setting total rounds
      return ButtonHandlerFactory.create({
        id: 'safari_configure_rounds',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`‚öôÔ∏è START: safari_configure_rounds - user ${context.userId}`);
          MenuBuilder.trackLegacyMenu('safari_configure_rounds', 'Safari rounds configuration modal');
          
          // Load current config
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const safariConfig = safariData[context.guildId]?.safariConfig || {};
          const currentTotalRounds = safariConfig.totalRounds || 3;
          
          // Create and send modal
          const { InteractionResponseType } = await import('discord-interactions');
          const { ActionRowBuilder, ModalBuilder, TextInputBuilder, TextInputStyle } = await import('discord.js');
          
          const modal = new ModalBuilder()
            .setCustomId('safari_rounds_config_modal')
            .setTitle('Configure Number of Rounds');
          
          const roundsInput = new TextInputBuilder()
            .setCustomId('total_rounds_input')
            .setLabel('Number of Rounds')
            .setPlaceholder('Enter number of rounds per game (minimum 1)')
            .setValue(currentTotalRounds.toString())
            .setStyle(TextInputStyle.Short)
            .setRequired(true)
            .setMinLength(1)
            .setMaxLength(3);
          
          const firstActionRow = new ActionRowBuilder().addComponents(roundsInput);
          modal.addComponents(firstActionRow);
          
          console.log(`‚úÖ SUCCESS: safari_configure_rounds - showing modal`);
          
          return {
            type: InteractionResponseType.MODAL,
            data: modal.toJSON()
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'safari_result_ordering') {
      // Handle result ordering configuration
      return ButtonHandlerFactory.create({
        id: 'safari_result_ordering',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üìä START: safari_result_ordering - user ${context.userId}`);
          
          // Get all server roles
          const guild = await client.guilds.fetch(context.guildId);
          const roles = await guild.roles.fetch();
          
          // Filter out @everyone and bot roles
          const selectableRoles = roles.filter(role => 
            role.id !== context.guildId && // Not @everyone
            !role.managed && // Not bot-managed
            role.name !== '@everyone'
          ).sort((a, b) => b.position - a.position); // Sort by position (highest first)
          
          // Load current priority roles configuration
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const priorityRoles = safariData[context.guildId]?.priorityRoles || [];
          
          // Create role options for select menu
          const roleOptions = Array.from(selectableRoles.values()).slice(0, 25).map(role => ({
            label: role.name,
            value: role.id,
            default: priorityRoles.includes(role.id)
          }));
          
          if (roleOptions.length === 0) {
            return {
              content: '‚ùå No selectable roles found in this server.',
              ephemeral: true
            };
          }
          
          const { StringSelectMenuBuilder, ActionRowBuilder, ButtonBuilder, ButtonStyle } = await import('discord.js');
          
          const selectMenu = new StringSelectMenuBuilder()
            .setCustomId('safari_result_ordering_select')
            .setPlaceholder('Select roles for priority ordering...')
            .setMinValues(0)
            .setMaxValues(Math.min(roleOptions.length, 25))
            .addOptions(roleOptions);
            
          const selectRow = new ActionRowBuilder().addComponents(selectMenu);
          
          // Create save/cancel buttons
          const saveButton = new ButtonBuilder()
            .setCustomId('safari_result_ordering_save')
            .setLabel('Save')
            .setStyle(ButtonStyle.Success)
            .setEmoji('‚úÖ');
            
          const cancelButton = new ButtonBuilder()
            .setCustomId('safari_result_ordering_cancel')
            .setLabel('Cancel')
            .setStyle(ButtonStyle.Secondary)
            .setEmoji('‚ùå');
            
          const buttonRow = new ActionRowBuilder().addComponents(saveButton, cancelButton);
          
          // Store selected values in context for save handler
          context.selectedRoles = [];
          
          // Create container
          const container = {
            type: 17, // Container
            accent_color: 0x3498db,
            components: [
              {
                type: 10, // Text Display
                content: `## üìä Result Ordering Configuration\n\nSelect roles to prioritize in round results.\nPlayers with these roles will appear first, grouped by role.\n\n**Currently selected:** ${priorityRoles.length} role${priorityRoles.length !== 1 ? 's' : ''}`
              },
              { type: 14 }, // Separator
              selectRow.toJSON(),
              buttonRow.toJSON()
            ]
          };
          
          console.log(`‚úÖ SUCCESS: safari_result_ordering - displayed configuration UI`);
          
          return {
            flags: (1 << 15) | 64, // IS_COMPONENTS_V2 | EPHEMERAL
            components: [container]
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'safari_result_ordering_select') {
      // Update the message to reflect the selected roles
      const selectedRoles = req.body.data.values || [];
      console.log(`üìä DEBUG: safari_result_ordering_select - ${selectedRoles.length} roles selected`);
      
      // Get the existing message components
      const message = req.body.message;
      const messageComponents = message?.components || [];
      
      // Update the select menu options to reflect the new selection
      if (messageComponents[0]?.type === 17) {
        const containerComponents = messageComponents[0].components || [];
        
        // Find and update the select menu
        for (let i = 0; i < containerComponents.length; i++) {
          const comp = containerComponents[i];
          if (comp.type === 1 && comp.components?.[0]?.type === 3) {
            // Update the default property for all options
            const selectMenu = comp.components[0];
            if (selectMenu.options) {
              selectMenu.options.forEach(option => {
                option.default = selectedRoles.includes(option.value);
              });
            }
            break;
          }
        }
        
        // Return the updated message
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            components: messageComponents
          }
        });
      }
      
      // Fallback if structure not found
      return res.send({
        type: InteractionResponseType.DEFERRED_UPDATE_MESSAGE
      });
      
    } else if (custom_id === 'safari_result_ordering_save') {
      // Save the role ordering configuration
      return ButtonHandlerFactory.create({
        id: 'safari_result_ordering_save',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üíæ START: safari_result_ordering_save - user ${context.userId}`);
          
          // Get selected roles from the message components
          const messageComponents = context.message?.components || [];
          let selectedRoles = [];
          
          // Find the select menu and get its selected values
          if (messageComponents[0]?.type === 17) {
            const containerComponents = messageComponents[0].components || [];
            const selectRow = containerComponents.find(comp => comp.type === 1 && comp.components?.[0]?.type === 3);
            
            if (selectRow?.components?.[0]?.options) {
              selectedRoles = selectRow.components[0].options
                .filter(opt => opt.default)
                .map(opt => opt.value);
            }
          }
          
          // Load and update safari data
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          
          if (!safariData[context.guildId]) {
            safariData[context.guildId] = {};
          }
          
          // Update priority roles
          safariData[context.guildId].priorityRoles = selectedRoles;
          await saveSafariContent(safariData);
          
          console.log(`‚úÖ SUCCESS: safari_result_ordering_save - saved ${selectedRoles.length} priority roles`);
          
          // Get role names for confirmation
          const guild = await client.guilds.fetch(context.guildId);
          const roles = await guild.roles.fetch();
          const roleNames = selectedRoles.map(roleId => {
            const role = roles.get(roleId);
            return role ? `@${role.name}` : roleId;
          }).join('\n');
          
          // Return success message
          const container = {
            type: 17, // Container
            accent_color: 0x27ae60, // Green for success
            components: [
              {
                type: 10, // Text Display
                content: `## ‚úÖ Result Ordering Updated\n\n**${selectedRoles.length} role${selectedRoles.length !== 1 ? 's' : ''} configured:**\n${roleNames || '*(Default chronological ordering)*'}\n\nRound results will now display players in these roles first.`
              }
            ]
          };
          
          return {
            components: [container]
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'safari_result_ordering_cancel') {
      // Cancel the ordering configuration
      return ButtonHandlerFactory.create({
        id: 'safari_result_ordering_cancel',
        updateMessage: true,
        handler: async (context) => {
          console.log(`‚ùå START: safari_result_ordering_cancel - user ${context.userId}`);
          
          const container = {
            type: 17, // Container
            accent_color: 0x95a5a6, // Grey for cancelled
            components: [
              {
                type: 10, // Text Display
                content: '## ‚ùå Result Ordering Cancelled\n\nNo changes were made to the result ordering configuration.'
              }
            ]
          };
          
          console.log(`‚úÖ SUCCESS: safari_result_ordering_cancel - configuration cancelled`);
          
          return {
            components: [container]
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'safari_player_status') {
      // Display all player balances grouped by priority roles
      return ButtonHandlerFactory.create({
        id: 'safari_player_status',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        deferResponse: true, // Defer the response to handle longer processing
        handler: async (context) => {
          console.log(`üèãÔ∏è START: safari_player_status - user ${context.userId}`);
          
          // Load all necessary data
          const { loadSafariContent, sortPlayersForResults } = await import('./safariManager.js');
          const { loadPlayerData } = await import('./storage.js');
          const safariData = await loadSafariContent();
          const playerData = await loadPlayerData();
          
          const guildId = context.guildId;
          const guildPlayers = playerData[guildId]?.players || {};
          const priorityRoles = safariData[guildId]?.priorityRoles || [];
          const customTerms = safariData[guildId]?.safariConfig?.customTerms || {};
          const currencyEmoji = customTerms.currencyEmoji || 'ü™ô';
          const currencyName = customTerms.currencyName || 'coins';
          
          // Get all initialized players (those with safari data)
          const initializedPlayers = [];
          
          // Collect all user IDs first
          const userIds = [];
          for (const [userId, data] of Object.entries(guildPlayers)) {
            if (data.safari) {
              userIds.push(userId);
            }
          }
          
          // Batch fetch all members at once
          const guild = await client.guilds.fetch(guildId);
          let members = new Map();
          try {
            // Fetch all members in one go - much faster than individual fetches
            const fetchedMembers = await guild.members.fetch({ user: userIds });
            members = fetchedMembers;
          } catch (e) {
            console.log(`‚ö†Ô∏è DEBUG: Batch member fetch failed, will use stored data`);
          }
          
          // Now process each player with the fetched member data
          for (const [userId, data] of Object.entries(guildPlayers)) {
            if (data.safari) {
              let playerName = `Player ${userId.slice(-4)}`;
              
              // Try to get from batch-fetched members first
              const member = members.get(userId);
              if (member) {
                playerName = member.displayName || member.user?.globalName || member.user?.username || playerName;
              } else {
                // Fallback to stored data if not in batch fetch
                playerName = data.globalName || data.displayName || data.username || playerName;
              }
              
              initializedPlayers.push({
                userId,
                playerName,
                currency: data.safari.currency || 0
              });
            }
          }
          
          if (initializedPlayers.length === 0) {
            return {
              content: '‚ùå No players have been initialized in Safari yet.',
              ephemeral: true
            };
          }
          
          // Sort players by priority roles if configured
          const sortedData = await sortPlayersForResults(initializedPlayers, priorityRoles, client, guildId);
          
          // Build the display content
          let content = '# Player Balances\n\n';
          
          // Helper function to get status emoji based on currency
          const getStatusEmoji = (currency) => {
            if (currency <= 10) return '‚úÖ';
            if (currency <= 25) return '‚ÅâÔ∏è';
            return '‚ùå';
          };
          
          if (sortedData.groups) {
            // Display by role groups
            for (const [roleId, roleData] of Object.entries(sortedData.groups.roleGroups)) {
              content += `## <@&${roleId}>\n`;
              for (const player of roleData.players) {
                const emoji = getStatusEmoji(player.currency);
                content += `* ${emoji} ${player.playerName} - ${currencyEmoji} ${player.currency} ${currencyName}\n`;
              }
              content += '\n';
            }
            
            // Display unassigned players if any
            if (sortedData.groups.unassigned && sortedData.groups.unassigned.length > 0) {
              content += `## Other Players\n`;
              for (const player of sortedData.groups.unassigned) {
                const emoji = getStatusEmoji(player.currency);
                content += `* ${emoji} ${player.playerName} - ${currencyEmoji} ${player.currency} ${currencyName}\n`;
              }
            }
          } else {
            // No priority roles configured - display all players
            for (const player of sortedData.sorted) {
              const emoji = getStatusEmoji(player.currency);
              content += `* ${emoji} ${player.playerName} - ${currencyEmoji} ${player.currency} ${currencyName}\n`;
            }
          }
          
          console.log(`‚úÖ SUCCESS: safari_player_status - displayed ${initializedPlayers.length} players`);
          
          // Return non-ephemeral Components V2 response
          return {
            flags: (1 << 15), // IS_COMPONENTS_V2 (non-ephemeral)
            components: [{
              type: 17, // Container
              accent_color: 0x3498db, // Blue
              components: [
                {
                  type: 10, // Text Display
                  content: content
                }
              ]
            }]
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'safari_location_editor') {
      return ButtonHandlerFactory.create({
        id: 'safari_location_editor',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        ephemeral: true,
        handler: async (context) => {
          console.log(`üîç START: safari_location_editor - user ${context.userId}`);
          
          const { createEntityManagementUI } = await import('./entityManagementUI.js');
          
          const ui = await createEntityManagementUI({
            entityType: 'map_cell',
            guildId: context.guildId,
            mode: 'edit'
          });
          
          console.log(`‚úÖ SUCCESS: safari_location_editor - opened map location actions`);
          return {
            ...ui,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'safari_action_editor') {
      return ButtonHandlerFactory.create({
        id: 'safari_action_editor',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        ephemeral: true,
        handler: async (context) => {
          console.log(`üîç START: safari_action_editor - user ${context.userId}`);
          
          const { createCustomActionSelectionUI } = await import('./customActionUI.js');
          
          const ui = await createCustomActionSelectionUI({
            guildId: context.guildId
            // No coordinate or mapId - this will trigger global mode
          });
          
          console.log(`‚úÖ SUCCESS: safari_action_editor - opened global action editor`);
          return {
            ...ui,
            ephemeral: true
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('custom_action_search_again_')) {
      // Handle search again for custom actions
      return ButtonHandlerFactory.create({
        id: 'custom_action_search_again',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üîç DEBUG: Search again clicked for custom actions`);
          
          // Parse coordinate and mapId if present
          let coordinate = null;
          let mapId = null;
          
          if (context.customId !== 'custom_action_search_again_global') {
            // Parse: custom_action_search_again_{coordinate}_{mapId}
            const parts = context.customId.replace('custom_action_search_again_', '').split('_');
            coordinate = parts[0];
            mapId = parts[1];
          }
          
          const modalCustomId = coordinate ? 
            `custom_action_search_modal_${coordinate}_${mapId}` : 
            'custom_action_search_modal_global';
          
          // Show search modal
          return {
            type: InteractionResponseType.MODAL,
            data: {
              title: 'Search Custom Actions',
              custom_id: modalCustomId,
              components: [{
                type: 1, // ActionRow
                components: [{
                  type: 4, // Text Input
                  custom_id: 'search_term',
                  label: 'Search Term',
                  style: 1, // Short
                  placeholder: 'Enter action name or description...',
                  required: true,
                  max_length: 50
                }]
              }]
            }
          };
        }
      })(req, res, client);
      
    } else if (custom_id === 'map_admin_user_select') {
      // Handle user selection for map admin
      console.log(`üõ°Ô∏è START: map_admin_user_select handler`);
      try {
        const guildId = req.body.guild_id;
        const selectedUserId = req.body.data.values[0];
        
        console.log(`üõ°Ô∏è Processing map admin user selection: ${selectedUserId}`);
        
        const { createMapAdminUI } = await import('./safariMapAdmin.js');
        
        const ui = await createMapAdminUI({
          guildId,
          userId: selectedUserId,
          mode: 'player_view'
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: ui
        });
        
      } catch (error) {
        console.error('Error in map_admin_user_select:', error);
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            content: '‚ùå An error occurred. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id === 'map_admin_select_new') {
      // Return to user selection
      try {
        const guildId = req.body.guild_id;
        
        const { createMapAdminUI } = await import('./safariMapAdmin.js');
        
        const ui = await createMapAdminUI({
          guildId,
          mode: 'user_select'
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: ui
        });
        
      } catch (error) {
        console.error('Error in map_admin_select_new:', error);
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            content: '‚ùå An error occurred. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('safari_init_player_')) {
      // Initialize player in Safari system (works with or without maps)
      return ButtonHandlerFactory.create({
        id: 'safari_init_player',
        deferred: true,
        ephemeral: true,
        handler: async (context) => {
          const targetUserId = context.customId.split('_').pop();
          console.log(`üõ°Ô∏è START: safari_init_player for user ${targetUserId}`);

          const { initializePlayerOnMap, createMapAdminUI } = await import('./safariMapAdmin.js');
          const { getStaminaConfig, loadSafariContent } = await import('./safariManager.js');
          const { loadPlayerData } = await import('./storage.js');

          try {
            // Check for per-player starting location first
            const playerData = await loadPlayerData();
            const safariData = await loadSafariContent();
            const activeMapId = safariData[context.guildId]?.maps?.active;
            const playerStartingLocation = playerData[context.guildId]?.players?.[targetUserId]?.safari?.mapProgress?.[activeMapId]?.startingLocation;

            // Priority: player-specific > server default > A1
            let startingCoordinate;
            if (playerStartingLocation) {
              startingCoordinate = playerStartingLocation;
              console.log(`üìç Using player-specific starting location: ${startingCoordinate}`);
            } else {
              const staminaConfig = await getStaminaConfig(context.guildId);
              startingCoordinate = staminaConfig.defaultStartingCoordinate || 'A1';
              console.log(`üìç Using server default starting location: ${startingCoordinate}`);
            }

            await initializePlayerOnMap(context.guildId, targetUserId, startingCoordinate, context.client);
            
            // Return updated player view
            const ui = await createMapAdminUI({
              guildId: context.guildId,
              userId: targetUserId,
              mode: 'player_view'
            });
            
            console.log(`‚úÖ SUCCESS: safari_init_player - initialized user ${targetUserId}`);
            return ui;
            
          } catch (error) {
            console.error('Error initializing player:', error);
            return {
              content: `‚ùå Error: ${error.message}`,
              ephemeral: true
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('safari_deinit_player_')) {
      // Show de-initialization warning dialog
      return ButtonHandlerFactory.create({
        id: 'safari_deinit_player',
        updateMessage: true,
        handler: async (context) => {
          try {
            const targetUserId = context.customId.split('_').pop();
            console.log(`üõ¨ START: safari_deinit_player warning for user ${targetUserId}`);
            
            const { createDeinitWarningUI, getDeinitializationInfo } = await import('./safariDeinitialization.js');
            const { loadSafariContent } = await import('./safariManager.js');
            // Check if player can be de-initialized
            const info = await getDeinitializationInfo(context.guildId, targetUserId);
            if (!info.canDeinit) {
              return {
                content: `‚ùå ${info.reason}`,
                flags: InteractionResponseFlags.EPHEMERAL
              };
            }
            
            // Get player name for display
            const guild = await context.client.guilds.fetch(context.guildId);
            const member = await guild.members.fetch(targetUserId);
            const playerName = member.displayName || member.user?.username || 'Unknown Player';
            
            // Check if there's an active map
            const safariData = await loadSafariContent();
            const hasMap = !!safariData[context.guildId]?.maps?.active;
            
            // Return warning dialog
            return createDeinitWarningUI(context.guildId, targetUserId, playerName, hasMap);
            
          } catch (error) {
            console.error('Error showing de-init warning:', error);
            return {
              content: `‚ùå Error: ${error.message}`,
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('safari_deinit_confirm_')) {
      // Confirm and execute de-initialization
      return ButtonHandlerFactory.create({
        id: 'safari_deinit_confirm',
        updateMessage: true,
        handler: async (context) => {
          try {
            const targetUserId = context.customId.split('_').pop();
            console.log(`‚ö†Ô∏è CONFIRMED: Executing safari_deinit for user ${targetUserId}`);
            
            const { deinitializePlayer, createDeinitSuccessUI } = await import('./safariDeinitialization.js');
            // Get player name before deletion
            const guild = await context.client.guilds.fetch(context.guildId);
            const member = await guild.members.fetch(targetUserId);
            const playerName = member.displayName || member.user?.username || 'Unknown Player';
            
            // Log admin activity before de-initialization (player data will be destroyed)
            try {
              const { addActivityEntryAndSave, ACTIVITY_TYPES } = await import('./activityLogger.js');
              await addActivityEntryAndSave(context.guildId, targetUserId, ACTIVITY_TYPES.admin, `[ADMIN] Player de-initialized`);
            } catch (e) { console.error('Activity log error:', e); }

            // Execute de-initialization
            const result = await deinitializePlayer(context.guildId, targetUserId, context.client);

            if (result.success) {
              console.log(`‚úÖ SUCCESS: De-initialized player ${targetUserId}`);
              return createDeinitSuccessUI(targetUserId, playerName, result.backup);
            } else {
              return {
                content: `‚ùå De-initialization failed: ${result.message}`,
                flags: InteractionResponseFlags.EPHEMERAL
              };
            }
            
          } catch (error) {
            console.error('Error during de-initialization:', error);
            return {
              content: `‚ùå Critical error: ${error.message}`,
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('safari_map_admin_player_')) {
      // Return to player admin view (used as cancel from de-init warning)
      return ButtonHandlerFactory.create({
        id: 'safari_map_admin_player',
        updateMessage: true,
        handler: async (context) => {
          const targetUserId = context.customId.split('_').pop();
          console.log(`üîô Returning to player admin view for ${targetUserId}`);
          
          const { createMapAdminUI } = await import('./safariMapAdmin.js');
          
          try {
            const ui = await createMapAdminUI({
              guildId: context.guildId,
              userId: targetUserId,
              mode: 'player_view'
            });
            
            return ui;
            
          } catch (error) {
            console.error('Error returning to player admin:', error);
            return {
              content: `‚ùå Error: ${error.message}`,
              flags: InteractionResponseFlags.EPHEMERAL
            };
          }
        }
      })(req, res, client);
      
    // === ACTIVITY LOG HANDLERS ===

    } else if (custom_id.startsWith('admin_view_logs_')) {
      // Admin viewing a player's activity log
      return ButtonHandlerFactory.create({
        id: 'admin_view_logs',
        updateMessage: true,
        handler: async (context) => {
          const targetUserId = context.customId.replace('admin_view_logs_', '');
          console.log(`üìú START: admin_view_logs for user ${targetUserId}`);
          const { createActivityLogUI } = await import('./activityLogger.js');
          const guild = await context.client.guilds.fetch(context.guildId);
          let playerName = 'Unknown';
          try { const m = await guild.members.fetch(targetUserId); playerName = m.displayName; } catch {}
          return createActivityLogUI({ guildId: context.guildId, userId: targetUserId, playerName, page: 1, mode: 'admin' });
        }
      })(req, res, client);

    } else if (custom_id === 'player_view_logs') {
      // Player viewing own activity log
      return ButtonHandlerFactory.create({
        id: 'player_view_logs',
        updateMessage: true,
        handler: async (context) => {
          console.log(`üìú START: player_view_logs for user ${context.userId}`);
          const { createActivityLogUI } = await import('./activityLogger.js');
          const guild = await context.client.guilds.fetch(context.guildId);
          let playerName = 'Unknown';
          try { const m = await guild.members.fetch(context.userId); playerName = m.displayName; } catch {}
          return createActivityLogUI({ guildId: context.guildId, userId: context.userId, playerName, page: 1, mode: 'player' });
        }
      })(req, res, client);

    } else if (custom_id.startsWith('activity_log_prev_')) {
      // Activity log previous page
      return ButtonHandlerFactory.create({
        id: 'activity_log_prev',
        updateMessage: true,
        handler: async (context) => {
          const { createActivityLogUI } = await import('./activityLogger.js');
          const parts = context.customId.replace('activity_log_prev_', '').split('_');
          const isAdmin = parts[0] !== 'self';
          const targetUserId = isAdmin ? parts[0] : context.userId;
          const page = parseInt(parts[parts.length - 1]) || 1;
          const guild = await context.client.guilds.fetch(context.guildId);
          let playerName = 'Unknown';
          try { const m = await guild.members.fetch(targetUserId); playerName = m.displayName; } catch {}
          return createActivityLogUI({ guildId: context.guildId, userId: targetUserId, playerName, page, mode: isAdmin ? 'admin' : 'player' });
        }
      })(req, res, client);

    } else if (custom_id.startsWith('activity_log_next_')) {
      // Activity log next page
      return ButtonHandlerFactory.create({
        id: 'activity_log_next',
        updateMessage: true,
        handler: async (context) => {
          const { createActivityLogUI } = await import('./activityLogger.js');
          const parts = context.customId.replace('activity_log_next_', '').split('_');
          const isAdmin = parts[0] !== 'self';
          const targetUserId = isAdmin ? parts[0] : context.userId;
          const page = parseInt(parts[parts.length - 1]) || 1;
          const guild = await context.client.guilds.fetch(context.guildId);
          let playerName = 'Unknown';
          try { const m = await guild.members.fetch(targetUserId); playerName = m.displayName; } catch {}
          return createActivityLogUI({ guildId: context.guildId, userId: targetUserId, playerName, page, mode: isAdmin ? 'admin' : 'player' });
        }
      })(req, res, client);

    } else if (custom_id.startsWith('activity_log_back_')) {
      // Activity log back button
      return ButtonHandlerFactory.create({
        id: 'activity_log_back',
        updateMessage: true,
        handler: async (context) => {
          const suffix = context.customId.replace('activity_log_back_', '');
          if (suffix === 'self') {
            // Return to player menu
            const { createPlayerManagementUI, PlayerManagementMode } = await import('./playerManagement.js');
            const { loadPlayerData } = await import('./storage.js');
            const playerData = await loadPlayerData();
            const guild = await context.client.guilds.fetch(context.guildId);
            const member = await guild.members.fetch(context.userId);
            return createPlayerManagementUI({
              mode: PlayerManagementMode.PLAYER,
              targetMember: member,
              playerData,
              guildId: context.guildId,
              userId: context.userId,
              client: context.client
            });
          } else {
            // Return to admin player management panel
            const targetUserId = suffix;
            const { createPlayerManagementUI, PlayerManagementMode } = await import('./playerManagement.js');
            const { loadPlayerData } = await import('./storage.js');
            const playerData = await loadPlayerData();
            const guild = await context.client.guilds.fetch(context.guildId);
            let targetMember;
            try { targetMember = await guild.members.fetch(targetUserId); } catch { return { content: '‚ùå Player not found.' }; }
            return createPlayerManagementUI({
              mode: PlayerManagementMode.ADMIN,
              targetMember,
              playerData,
              guildId: context.guildId,
              userId: context.userId,
              client: context.client
            });
          }
        }
      })(req, res, client);

    } else if (custom_id === 'admin_populate_logs') {
      // Admin backfill activity logs from existing data
      return ButtonHandlerFactory.create({
        id: 'admin_populate_logs',
        updateMessage: true,
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          console.log(`üìú START: admin_populate_logs for guild ${context.guildId}`);
          const { backfillFromExistingData } = await import('./activityLogger.js');
          const { loadPlayerData, savePlayerData } = await import('./storage.js');
          const { loadSafariContent } = await import('./safariManager.js');
          const playerData = await loadPlayerData();
          const safariData = await loadSafariContent();
          const players = playerData[context.guildId]?.players || {};
          let totalEntries = 0;
          let playerCount = 0;
          for (const [uid, player] of Object.entries(players)) {
            if (!player.safari) continue;
            const count = backfillFromExistingData(playerData, safariData, context.guildId, uid);
            if (count > 0) { totalEntries += count; playerCount++; }
          }
          await savePlayerData(playerData);
          console.log(`‚úÖ SUCCESS: admin_populate_logs - ${totalEntries} entries for ${playerCount} players`);
          return {
            flags: (1 << 15),
            components: [{
              type: 17,
              accent_color: 0x2ecc71,
              components: [
                { type: 10, content: `## ‚úÖ Activity Logs Populated\n\nBackfilled **${totalEntries}** entries across **${playerCount}** initialized players from existing store and movement history.` },
                { type: 14 },
                { type: 1, components: [{ type: 2, style: 2, label: '‚Üê Back', custom_id: 'prod_menu_back' }] }
              ]
            }]
          };
        }
      })(req, res, client);

    // === END ACTIVITY LOG HANDLERS ===

    } else if (custom_id.startsWith('safari_pause_player_')) {
      // Pause a single player
      return ButtonHandlerFactory.create({
        id: 'safari_pause_player',
        updateMessage: true,
        handler: async (context) => {
          try {
            const targetUserId = context.customId.split('_').pop();
            console.log(`‚è∏Ô∏è START: safari_pause_player for user ${targetUserId}`);
            
            const { pauseSinglePlayer } = await import('./pausedPlayersManager.js');
            
            // Pause the player
            const result = await pauseSinglePlayer(context.guildId, targetUserId, context.client);
            
            if (result.success) {
              console.log(`‚úÖ SUCCESS: Paused player ${targetUserId} at ${result.location}`);
              
              // Return updated Player Admin UI with new button state
              const { createMapAdminUI } = await import('./safariMapAdmin.js');
              const updatedUI = await createMapAdminUI({
                guildId: context.guildId,
                userId: targetUserId,
                mode: 'player_view'
              });
              
              // Remove flags for UPDATE_MESSAGE
              delete updatedUI.flags;
              delete updatedUI.ephemeral;
              
              return updatedUI;
            } else {
              return {
                components: [{
                  type: 17, // Container
                  accent_color: 0xed4245, // Red for error
                  components: [{
                    type: 10, // Text Display
                    content: `‚ùå **Failed to pause player**: ${result.message}`
                  }]
                }]
              };
            }
          } catch (error) {
            console.error('Error in safari_pause_player handler:', error);
            return {
              components: [{
                type: 17, // Container
                accent_color: 0xed4245,
                components: [{
                  type: 10, // Text Display
                  content: '‚ùå An error occurred while pausing the player.'
                }]
              }]
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('safari_unpause_player_')) {
      // Unpause a single player
      return ButtonHandlerFactory.create({
        id: 'safari_unpause_player',
        updateMessage: true,
        handler: async (context) => {
          try {
            const targetUserId = context.customId.split('_').pop();
            console.log(`‚èØÔ∏è START: safari_unpause_player for user ${targetUserId}`);
            
            const { unpauseSinglePlayer } = await import('./pausedPlayersManager.js');
            
            // Unpause the player
            const result = await unpauseSinglePlayer(context.guildId, targetUserId, context.client);
            
            if (result.success) {
              console.log(`‚úÖ SUCCESS: Unpaused player ${targetUserId} at ${result.location}`);
              
              // Return updated Player Admin UI with new button state
              const { createMapAdminUI } = await import('./safariMapAdmin.js');
              const updatedUI = await createMapAdminUI({
                guildId: context.guildId,
                userId: targetUserId,
                mode: 'player_view'
              });
              
              // Remove flags for UPDATE_MESSAGE
              delete updatedUI.flags;
              delete updatedUI.ephemeral;
              
              return updatedUI;
            } else {
              return {
                components: [{
                  type: 17, // Container
                  accent_color: 0xed4245, // Red for error
                  components: [{
                    type: 10, // Text Display
                    content: `‚ùå **Failed to unpause player**: ${result.message}`
                  }]
                }]
              };
            }
          } catch (error) {
            console.error('Error in safari_unpause_player handler:', error);
            return {
              components: [{
                type: 17, // Container
                accent_color: 0xed4245,
                components: [{
                  type: 10, // Text Display
                  content: '‚ùå An error occurred while unpausing the player.'
                }]
              }]
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('safari_starting_info_')) {
      // Show Starting Info modal (starting location + future: starting gold)
      try {
        const targetUserId = custom_id.split('_').pop();
        const guildId = req.body.guild_id;

        const { loadPlayerData } = await import('./storage.js');
        const { loadSafariContent } = await import('./safariManager.js');
        const playerData = await loadPlayerData();
        const safariData = await loadSafariContent();
        const activeMapId = safariData[guildId]?.maps?.active;
        const playerMapData = playerData[guildId]?.players?.[targetUserId]?.safari?.mapProgress?.[activeMapId];
        const currentStartingLocation = playerMapData?.startingLocation || '';

        const { createStartingInfoModal } = await import('./safariMapAdmin.js');
        const modal = await createStartingInfoModal(targetUserId, currentStartingLocation);

        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal
        });

      } catch (error) {
        console.error('Error showing starting info modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå An error occurred. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

    } else if (custom_id.startsWith('map_admin_move_player_')) {
      // Show location modal (move player)
      try {
        const targetUserId = custom_id.split('_').pop();
        const guildId = req.body.guild_id;

        const { loadPlayerData } = await import('./storage.js');
        const { loadSafariContent } = await import('./safariManager.js');
        const playerData = await loadPlayerData();
        const safariData = await loadSafariContent();
        const activeMapId = safariData[guildId]?.maps?.active;
        const playerMapData = playerData[guildId]?.players?.[targetUserId]?.safari?.mapProgress?.[activeMapId];
        const currentLocation = playerMapData?.currentLocation || '';

        const { createCoordinateModal } = await import('./safariMapAdmin.js');
        const modal = await createCoordinateModal(targetUserId, currentLocation);

        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal
        });

      } catch (error) {
        console.error('Error showing coordinate modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå An error occurred. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('map_admin_grant_stamina_')) {
      // Show stamina grant modal
      try {
        const targetUserId = custom_id.split('_').pop();
        
        const { createStaminaModal } = await import('./safariMapAdmin.js');
        const modal = await createStaminaModal(targetUserId);
        
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal.toJSON()
        });
        
      } catch (error) {
        console.error('Error showing stamina modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå An error occurred. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('map_admin_reset_explored_')) {
      // Reset player's explored coordinates
      return ButtonHandlerFactory.create({
        id: 'map_admin_reset_explored',
        deferred: true,
        ephemeral: true,
        handler: async (context) => {
          const targetUserId = context.customId.split('_').pop();
          console.log(`üõ°Ô∏è START: map_admin_reset_explored for user ${targetUserId}`);
          
          const { resetPlayerExploration, createMapAdminUI } = await import('./safariMapAdmin.js');
          
          try {
            await resetPlayerExploration(context.guildId, targetUserId);
            
            // Return updated player view
            const ui = await createMapAdminUI({
              guildId: context.guildId,
              userId: targetUserId,
              mode: 'player_view'
            });
            
            console.log(`‚úÖ SUCCESS: map_admin_reset_explored - reset for user ${targetUserId}`);
            return ui;
            
          } catch (error) {
            console.error('Error resetting exploration:', error);
            return {
              content: `‚ùå Error: ${error.message}`,
              ephemeral: true
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_admin_view_inventory_')) {
      // Show player inventory directly (no user selection needed)
      return ButtonHandlerFactory.create({
        id: 'map_admin_view_inventory',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          try {
            const targetUserId = context.customId.split('_').pop();
            console.log(`üß∞ START: map_admin_view_inventory for user ${targetUserId}`);
            
            // Import inventory display function
            const { createPlayerInventoryDisplay } = await import('./safariManager.js');
            
            // Get the player member object
            const guild = await context.client.guilds.fetch(context.guildId);
            const member = await guild.members.fetch(targetUserId).catch(() => null);
            
            // Create inventory display directly
            const inventoryDisplay = await createPlayerInventoryDisplay(
              context.guildId,
              targetUserId,
              member,
              0 // Start at page 0
            );
            
            console.log(`‚úÖ SUCCESS: map_admin_view_inventory - showing inventory`);
            
            return inventoryDisplay;
          } catch (error) {
            console.error(`‚ùå ERROR: map_admin_view_inventory - ${error.message}`);
            return {
              content: `‚ùå Error viewing inventory: ${error.message}`,
              ephemeral: true
            };
          }
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_admin_edit_currency_')) {
      // Show currency edit modal
      try {
        const targetUserId = custom_id.split('_').pop();
        console.log(`üõ°Ô∏è START: map_admin_edit_currency for user ${targetUserId}`);
        
        // Get current currency amount
        const { loadPlayerData } = await import('./storage.js');
        const { getCustomTerms } = await import('./safariManager.js');
        const playerData = await loadPlayerData();
        const customTerms = await getCustomTerms(req.body.guild_id);
        
        const currentAmount = playerData[req.body.guild_id]?.players?.[targetUserId]?.safari?.currency || 0;
        
        const { createCurrencyModal } = await import('./safariMapAdmin.js');
        const modal = await createCurrencyModal(targetUserId, currentAmount, customTerms.currencyName);
        
        console.log(`‚úÖ SUCCESS: map_admin_edit_currency - showing modal`);
        
        // Send modal response directly
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal
        });
      } catch (error) {
        console.error('Error in map_admin_edit_currency:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error showing currency modal.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('map_admin_edit_items_')) {
      // Show player-centric item selector
      return ButtonHandlerFactory.create({
        id: 'map_admin_edit_items',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context) => {
          const targetUserId = context.customId.split('_').pop();
          console.log(`üì¶ START: map_admin_edit_items - player item selector for user ${targetUserId}`);

          // Import player item selector UI
          const { createPlayerItemSelectorUI } = await import('./entityManagementUI.js');

          // Create the UI
          const uiResponse = await createPlayerItemSelectorUI({
            guildId: context.guildId,
            targetUserId,
            searchTerm: '',
            selectedItemId: null
          });

          console.log(`‚úÖ SUCCESS: map_admin_edit_items - showing player item selector for user ${targetUserId}`);

          return uiResponse;
        }
      })(req, res, client);

    } else if (custom_id.startsWith('player_item_select_')) {
      // Handle player item selection - show quantity modal
      return ButtonHandlerFactory.create({
        id: 'player_item_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        handler: async (context, req) => {
          const targetUserId = context.customId.replace('player_item_select_', '');
          const selectedValue = req.body.data.values[0];

          console.log(`üì¶ START: player_item_select - user ${targetUserId}, selected ${selectedValue}`);

          // Handle special cases
          if (selectedValue === 'search_entities') {
            // Show search modal
            const { ModalBuilder, TextInputBuilder, ActionRowBuilder } = await import('discord.js');

            const modal = new ModalBuilder()
              .setCustomId(`player_item_search_modal_${targetUserId}`)
              .setTitle('Search Items');

            const searchInput = new TextInputBuilder()
              .setCustomId('search_term')
              .setLabel('Search Term')
              .setStyle(1) // Short
              .setPlaceholder('Enter item name or description...')
              .setRequired(true)
              .setMaxLength(100);

            const row = new ActionRowBuilder().addComponents(searchInput);
            modal.addComponents(row);

            return {
              type: 9, // Modal response
              data: modal.toJSON()
            };
          }

          if (selectedValue === 'no_items') {
            // Return to player admin with error message
            return {
              flags: (1 << 15), // IS_COMPONENTS_V2
              components: [{
                type: 17, // Container
                accent_color: 0xe74c3c, // Red for error
                components: [
                  {
                    type: 10, // Text Display
                    content: `## ‚ùå No Items Available\n\nNo items found in this server. Create some items first in **Safari ‚Üí Items** before managing player quantities.`
                  },
                  {
                    type: 1, // Action Row
                    components: [{
                      type: 2, // Button
                      style: 2, // Secondary
                      label: '‚Üê Player Admin',
                      custom_id: `map_admin_edit_items_${targetUserId}`,
                      emoji: { name: 'üë§' }
                    }]
                  }
                ]
              }],
              ephemeral: true
            };
          }

          // Regular item selection - redirect to existing quantity modal system
          const itemId = selectedValue;

          // Import necessary functions
          const { loadEntity } = await import('./entityManager.js');
          const { loadPlayerData } = await import('./storage.js');

          // Load item data to get item name
          const item = await loadEntity(context.guildId, 'item', itemId);
          const itemName = item?.name || 'Unknown Item';

          // Get current item quantity
          const playerData = await loadPlayerData();
          const inventory = playerData[context.guildId]?.players?.[targetUserId]?.safari?.inventory || {};
          const currentItem = inventory[itemId];

          let currentQuantity = '';
          let modalLabel = 'Qty';

          if (currentItem) {
            if (typeof currentItem === 'object') {
              currentQuantity = currentItem.quantity?.toString() || '0';
              modalLabel = item?.attackValue !== undefined && item.attackValue > 0 ? 'Qty (‚öîÔ∏è Attack Item)' : 'Qty';
            } else {
              currentQuantity = currentItem.toString();
            }
          }

          // Create quantity modal with player admin return context
          const { ModalBuilder, TextInputBuilder, ActionRowBuilder } = await import('discord.js');

          let modalTitle = `Set ${itemName} Quantity`;
          if (modalTitle.length > 45) {
            const maxItemNameLength = 45 - 16; // "Set " (4) + "... Quantity" (12) = 16
            modalTitle = `Set ${itemName.substring(0, maxItemNameLength)}... Quantity`;
          }

          const modal = new ModalBuilder()
            .setCustomId(`safari_item_qty_modal_${context.guildId}_${itemId}_${targetUserId}`)
            .setTitle(modalTitle);

          const quantityInput = new TextInputBuilder()
            .setCustomId('item_quantity')
            .setLabel(modalLabel)
            .setStyle(1) // Short
            .setRequired(true)
            .setMaxLength(10)
            .setPlaceholder('Enter quantity (0 or higher)');

          // Set current value if item exists
          if (currentQuantity !== '') {
            quantityInput.setValue(currentQuantity);
          }

          const row = new ActionRowBuilder().addComponents(quantityInput);
          modal.addComponents(row);

          console.log(`‚úÖ SUCCESS: player_item_select - showing quantity modal for ${itemName}`);

          return {
            type: 9, // Modal response
            data: modal.toJSON()
          };
        }
      })(req, res, client);

    } else if (custom_id.startsWith('map_admin_edit_items_DEPRECATED_')) {
      // DEPRECATED - Old comprehensive player inventory editor code
      return ButtonHandlerFactory.create({
        id: 'map_admin_edit_items_deprecated',
        handler: async (context) => {
          const targetUserId = context.customId.split('_').pop();
          console.log(`üõ°Ô∏è START: map_admin_edit_items_deprecated - comprehensive inventory editor for user ${targetUserId}`);
          
          // Import necessary functions
          const { loadSafariContent, getCustomTerms, getItemQuantity } = await import('./safariManager.js');
          const { loadPlayerData } = await import('./storage.js');
          
          // Load data
          const safariData = await loadSafariContent();
          const playerData = await loadPlayerData();
          const items = safariData[context.guildId]?.items || {};
          const customTerms = await getCustomTerms(context.guildId);
          
          // Get player inventory
          const playerSafari = playerData[context.guildId]?.players?.[targetUserId]?.safari || {};
          const inventory = playerSafari.inventory || {};
          const currency = playerSafari.currency || 0;
          
          // Get user info for display
          const guild = await context.client.guilds.fetch(context.guildId);
          const targetMember = await guild.members.fetch(targetUserId);
          const displayName = targetMember.displayName || targetMember.user.username;
          
          // Build inventory display with edit controls
          const components = [];
          
          // Header
          components.push({
            type: 10, // Text Display
            content: `## üì¶ Inventory Editor - ${displayName}\n\n**${customTerms.currencyEmoji} ${customTerms.currencyName}:** ${currency}`
          });
          
          // Current inventory section
          components.push({ type: 14 }); // Separator
          components.push({
            type: 10, // Text Display
            content: '### Current Inventory'
          });
          
          // List current items with quantities
          const inventoryList = [];
          let hasItems = false;
          
          for (const [itemId, itemData] of Object.entries(inventory)) {
            const quantity = getItemQuantity(itemData);
            if (quantity > 0) {
              hasItems = true;
              const item = items[itemId];
              if (item) {
                inventoryList.push(`${item.emoji || 'üì¶'} **${item.name}** - Qty: ${quantity}`);
              }
            }
          }
          
          components.push({
            type: 10, // Text Display
            content: hasItems ? inventoryList.join('\n') : '*No items in inventory*'
          });
          
          // Action buttons
          components.push({ type: 14 }); // Separator
          
          const actionButtons = [];
          
          // Back button (leftmost)
          actionButtons.push({
            type: 2, // Button
            style: 2, // Secondary
            label: 'Back',
            custom_id: `map_admin_user_select_continue_${targetUserId}`,
            emoji: { name: '‚¨ÖÔ∏è' }
          });
          
          // Add Item button
          actionButtons.push({
            type: 2, // Button
            style: 3, // Success
            label: 'Add Item',
            custom_id: `map_admin_add_item_${targetUserId}`,
            emoji: { name: '‚ûï' }
          });
          
          // Edit Quantities button (if has items)
          if (hasItems) {
            actionButtons.push({
              type: 2, // Button
              style: 1, // Primary
              label: 'Edit Quantities',
              custom_id: `map_admin_edit_quantities_${targetUserId}`,
              emoji: { name: 'üìù' }
            });
            
            // Clear All button
            actionButtons.push({
              type: 2, // Button
              style: 4, // Danger
              label: 'Clear All',
              custom_id: `map_admin_clear_inventory_${targetUserId}`,
              emoji: { name: 'üóëÔ∏è' }
            });
          }
          
          // Edit Currency button
          actionButtons.push({
            type: 2, // Button
            style: 2, // Secondary
            label: `Edit ${customTerms.currencyName}`,
            custom_id: `map_admin_edit_currency_${targetUserId}`,
            emoji: { name: customTerms.currencyEmoji || 'ü™ô' }
          });
          
          // Create action rows (max 5 buttons per row)
          const actionRows = [];
          for (let i = 0; i < actionButtons.length; i += 5) {
            actionRows.push({
              type: 1, // Action Row
              components: actionButtons.slice(i, i + 5)
            });
          }
          
          actionRows.forEach(row => components.push(row));
          
          console.log(`‚úÖ SUCCESS: map_admin_edit_items - showing comprehensive inventory editor`);
          
          return {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + ephemeral
            components: [{
              type: 17, // Container
              accent_color: 0x3498db, // Blue accent
              components: components
            }]
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_admin_item_select_')) {
      // Handle item selection for map admin - show quantity modal
      try {
        const targetUserId = custom_id.split('_').pop();
        const selectedValue = req.body.data.values[0];
        const [userId, itemId] = selectedValue.split('_');
        
        console.log(`üõ°Ô∏è Processing map admin item select: user=${userId}, item=${itemId}`);
        
        // Load item data to get item name
        const { loadEntity } = await import('./entityManager.js');
        const item = await loadEntity(req.body.guild_id, 'item', itemId);
        const itemName = item?.name || 'Unknown Item';
        
        // Get current item quantity
        const playerData = await loadPlayerData();
        const inventory = playerData[req.body.guild_id]?.players?.[userId]?.safari?.inventory || {};
        const currentItem = inventory[itemId];
        
        let currentQuantity = '';
        let modalLabel = 'Quantity';
        
        if (currentItem) {
          currentQuantity = currentItem.quantity?.toString() || '0';
          if (currentItem.numAttacksAvailable !== undefined) {
            modalLabel = `Quantity (Attacks Available: ${currentItem.numAttacksAvailable})`;
          }
        }
        
        // Get target user info
        const guild = await client.guilds.fetch(req.body.guild_id);
        const targetMember = await guild.members.fetch(userId);
        
        // Create quantity modal
        const modal = new ModalBuilder()
          .setCustomId(`map_admin_item_qty_modal_${req.body.guild_id}_${itemId}_${userId}`)
          .setTitle(`Set ${itemName} for ${targetMember.displayName}`);
        
        const quantityInput = new TextInputBuilder()
          .setCustomId('item_quantity')
          .setLabel(modalLabel)
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('Enter quantity (0 to remove)')
          .setValue(currentQuantity)
          .setRequired(true)
          .setMaxLength(4);
        
        const row = new ActionRowBuilder().addComponents(quantityInput);
        modal.addComponents(row);
        
        console.log(`‚úÖ SUCCESS: map_admin_item_select - showing quantity modal`);
        
        // Send modal response directly
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal
        });
      } catch (error) {
        console.error('Error in map_admin_item_select:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error showing item quantity modal.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('map_admin_add_item_')) {
      // Show item selection dropdown to add to player inventory
      return ButtonHandlerFactory.create({
        id: 'map_admin_add_item',
        updateMessage: true,
        handler: async (context) => {
          const targetUserId = context.customId.split('_').pop();
          console.log(`üõ°Ô∏è START: map_admin_add_item for user ${targetUserId}`);
          
          // Import necessary functions
          const { loadSafariContent } = await import('./safariManager.js');
          const { parseTextEmoji } = await import('./utils/emojiUtils.js');
          
          // Load items
          const safariData = await loadSafariContent();
          const items = safariData[context.guildId]?.items || {};
          
          if (Object.keys(items).length === 0) {
            return {
              content: '‚ùå No items have been created yet. Please create items first using Safari ‚Üí Manage Items.'
            };
          }
          
          // Create item selection dropdown
          const options = [];
          for (const [itemId, item] of Object.entries(items)) {
            const { cleanText, emoji } = parseTextEmoji(item.emoji || 'üì¶', 'üì¶');
            options.push({
              label: item.name || 'Unnamed Item',
              description: item.description?.substring(0, 100) || 'No description',
              value: itemId,
              emoji: emoji
            });
          }
          
          // Limit to 25 items for Discord's dropdown limit
          if (options.length > 25) {
            options.length = 25;
          }
          
          const selectRow = {
            type: 1, // Action Row
            components: [{
              type: 3, // String Select
              custom_id: `map_admin_add_item_select_${targetUserId}`,
              placeholder: 'Select an item to add...',
              options: options
            }]
          };
          
          const cancelButton = {
            type: 1, // Action Row
            components: [{
              type: 2, // Button
              style: 2, // Secondary
              label: 'Cancel',
              custom_id: `map_admin_edit_items_${targetUserId}`,
              emoji: { name: '‚ùå' }
            }]
          };
          
          console.log(`‚úÖ SUCCESS: map_admin_add_item - showing item selection`);
          
          return {
            content: `## ‚ûï Add Item\n\nSelect an item to add:`,
            components: [selectRow, cancelButton]
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_admin_add_item_select_')) {
      // Handle item selection to add - show quantity modal
      try {
        const targetUserId = custom_id.split('_').pop();
        const itemId = req.body.data.values[0];
        
        console.log(`üõ°Ô∏è Processing map admin add item select: user=${targetUserId}, item=${itemId}`);
        
        // Load item data to get item name
        const { loadEntity } = await import('./entityManager.js');
        const item = await loadEntity(req.body.guild_id, 'item', itemId);
        const itemName = item?.name || 'Unknown Item';
        
        // Get target user info
        const guild = await client.guilds.fetch(req.body.guild_id);
        const targetMember = await guild.members.fetch(targetUserId);
        
        // Create quantity modal
        const modal = new ModalBuilder()
          .setCustomId(`map_admin_add_item_qty_modal_${req.body.guild_id}_${itemId}_${targetUserId}`)
          .setTitle(`Add ${itemName} to ${targetMember.displayName}`);
        
        const quantityInput = new TextInputBuilder()
          .setCustomId('item_quantity')
          .setLabel('Quantity to Add')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('Enter quantity to add')
          .setValue('1')
          .setRequired(true)
          .setMaxLength(4);
        
        const row = new ActionRowBuilder().addComponents(quantityInput);
        modal.addComponents(row);
        
        console.log(`‚úÖ SUCCESS: map_admin_add_item_select - showing quantity modal`);
        
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal
        });
      } catch (error) {
        console.error('Error in map_admin_add_item_select:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error showing quantity modal.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('map_admin_edit_quantities_')) {
      // Show dropdown of current inventory items to edit
      return ButtonHandlerFactory.create({
        id: 'map_admin_edit_quantities',
        updateMessage: true,
        handler: async (context) => {
          const targetUserId = context.customId.split('_').pop();
          console.log(`üõ°Ô∏è START: map_admin_edit_quantities for user ${targetUserId}`);
          
          // Import necessary functions
          const { loadSafariContent, getItemQuantity } = await import('./safariManager.js');
          const { loadPlayerData } = await import('./storage.js');
          const { parseTextEmoji } = await import('./utils/emojiUtils.js');
          
          // Load data
          const safariData = await loadSafariContent();
          const playerData = await loadPlayerData();
          const items = safariData[context.guildId]?.items || {};
          
          // Get player inventory
          const inventory = playerData[context.guildId]?.players?.[targetUserId]?.safari?.inventory || {};
          
          // Create options for items in inventory
          const options = [];
          for (const [itemId, itemData] of Object.entries(inventory)) {
            const quantity = getItemQuantity(itemData);
            if (quantity > 0) {
              const item = items[itemId];
              if (item) {
                const { cleanText, emoji } = parseTextEmoji(item.emoji || 'üì¶', 'üì¶');
                options.push({
                  label: `${item.name} (Qty: ${quantity})`,
                  description: item.description?.substring(0, 100) || 'No description',
                  value: itemId,
                  emoji: emoji
                });
              }
            }
          }
          
          if (options.length === 0) {
            return {
              content: '‚ùå This player has no items in their inventory.'
            };
          }
          
          // Limit to 25 items for Discord's dropdown limit
          if (options.length > 25) {
            options.length = 25;
          }
          
          const selectRow = {
            type: 1, // Action Row
            components: [{
              type: 3, // String Select
              custom_id: `map_admin_edit_qty_select_${targetUserId}`,
              placeholder: 'Select an item to edit quantity...',
              options: options
            }]
          };
          
          const cancelButton = {
            type: 1, // Action Row
            components: [{
              type: 2, // Button
              style: 2, // Secondary
              label: 'Cancel',
              custom_id: `map_admin_edit_items_${targetUserId}`,
              emoji: { name: '‚ùå' }
            }]
          };
          
          console.log(`‚úÖ SUCCESS: map_admin_edit_quantities - showing item selection`);
          
          return {
            content: `## üìù Edit Item Quantities\n\nSelect an item to edit:`,
            components: [selectRow, cancelButton]
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_admin_edit_qty_select_')) {
      // Handle item selection for quantity edit - show modal with current quantity
      try {
        const targetUserId = custom_id.split('_').pop();
        const itemId = req.body.data.values[0];
        
        console.log(`üõ°Ô∏è Processing map admin edit qty select: user=${targetUserId}, item=${itemId}`);
        
        // Load item data to get item name
        const { loadEntity } = await import('./entityManager.js');
        const { loadPlayerData } = await import('./storage.js');
        const { getItemQuantity } = await import('./safariManager.js');
        
        const item = await loadEntity(req.body.guild_id, 'item', itemId);
        const itemName = item?.name || 'Unknown Item';
        
        // Get current quantity
        const playerData = await loadPlayerData();
        const inventory = playerData[req.body.guild_id]?.players?.[targetUserId]?.safari?.inventory || {};
        const currentQuantity = getItemQuantity(inventory[itemId] || 0);
        
        // Get target user info
        const guild = await client.guilds.fetch(req.body.guild_id);
        const targetMember = await guild.members.fetch(targetUserId);
        
        // Create quantity modal
        const modal = new ModalBuilder()
          .setCustomId(`map_admin_item_qty_modal_${req.body.guild_id}_${itemId}_${targetUserId}`)
          .setTitle(`Edit ${itemName} for ${targetMember.displayName}`);
        
        const quantityInput = new TextInputBuilder()
          .setCustomId('item_quantity')
          .setLabel('New Quantity')
          .setStyle(TextInputStyle.Short)
          .setPlaceholder('Enter new quantity (0 to remove)')
          .setValue(currentQuantity.toString())
          .setRequired(true)
          .setMaxLength(4);
        
        const row = new ActionRowBuilder().addComponents(quantityInput);
        modal.addComponents(row);
        
        console.log(`‚úÖ SUCCESS: map_admin_edit_qty_select - showing quantity modal`);
        
        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal
        });
      } catch (error) {
        console.error('Error in map_admin_edit_qty_select:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error showing quantity modal.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('map_admin_clear_inventory_')) {
      // Show clear inventory confirmation
      return ButtonHandlerFactory.create({
        id: 'map_admin_clear_inventory',
        updateMessage: true,
        handler: async (context) => {
          const targetUserId = context.customId.split('_').pop();
          console.log(`üõ°Ô∏è START: map_admin_clear_inventory confirmation for user ${targetUserId}`);
          
          // Get user info for display
          const guild = await context.client.guilds.fetch(context.guildId);
          const targetMember = await guild.members.fetch(targetUserId);
          const displayName = targetMember.displayName || targetMember.user.username;
          
          const confirmButton = {
            type: 2, // Button
            style: 4, // Danger
            label: 'Yes, Clear All',
            custom_id: `map_admin_clear_inventory_confirm_${targetUserId}`,
            emoji: { name: '‚ö†Ô∏è' }
          };
          
          const cancelButton = {
            type: 2, // Button
            style: 2, // Secondary
            label: 'Cancel',
            custom_id: `map_admin_edit_items_${targetUserId}`,
            emoji: { name: '‚ùå' }
          };
          
          console.log(`‚úÖ SUCCESS: map_admin_clear_inventory - showing confirmation`);
          
          return {
            content: `## ‚ö†Ô∏è Clear Inventory\n\nAre you sure you want to clear **ALL items** from ${displayName}'s inventory?\n\nThis action cannot be undone!`,
            components: [{
              type: 1, // Action Row
              components: [confirmButton, cancelButton]
            }]
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_admin_clear_inventory_confirm_')) {
      // Execute inventory clear
      return ButtonHandlerFactory.create({
        id: 'map_admin_clear_inventory_confirm',
        updateMessage: true,
        handler: async (context) => {
          const targetUserId = context.customId.split('_').pop();
          console.log(`üõ°Ô∏è START: map_admin_clear_inventory_confirm executing for user ${targetUserId}`);
          
          // Import necessary functions
          const { loadPlayerData, savePlayerData } = await import('./storage.js');
          
          // Load player data
          const playerData = await loadPlayerData();
          
          // Clear inventory
          if (!playerData[context.guildId]) playerData[context.guildId] = { players: {} };
          if (!playerData[context.guildId].players[targetUserId]) playerData[context.guildId].players[targetUserId] = { safari: {} };
          if (!playerData[context.guildId].players[targetUserId].safari) playerData[context.guildId].players[targetUserId].safari = {};
          
          playerData[context.guildId].players[targetUserId].safari.inventory = {};
          
          await savePlayerData(playerData);
          
          // Get user info for display
          const guild = await context.client.guilds.fetch(context.guildId);
          const targetMember = await guild.members.fetch(targetUserId);
          const displayName = targetMember.displayName || targetMember.user.username;
          
          console.log(`‚úÖ SUCCESS: map_admin_clear_inventory_confirm - inventory cleared`);
          
          return {
            content: `‚úÖ Successfully cleared all items from ${displayName}'s inventory.`,
            components: [{
              type: 1, // Action Row
              components: [{
                type: 2, // Button
                style: 2, // Secondary
                label: 'Back to Inventory',
                custom_id: `map_admin_edit_items_${targetUserId}`,
                emoji: { name: '‚¨ÖÔ∏è' }
              }]
            }]
          };
        }
      })(req, res, client);
      
    } else if (custom_id.startsWith('map_admin_user_select_continue_')) {
      // Handle back button to return to map admin menu
      return ButtonHandlerFactory.create({
        id: 'map_admin_user_select_continue',
        updateMessage: true,
        handler: async (context) => {
          const targetUserId = context.customId.split('_').pop();
          console.log(`üõ°Ô∏è START: map_admin_user_select_continue - returning to map admin menu for user ${targetUserId}`);
          
          const { createMapAdminUI } = await import('./safariMapAdmin.js');
          
          const ui = await createMapAdminUI({
            guildId: context.guildId,
            userId: targetUserId,
            mode: 'player_view'
          });
          
          console.log(`‚úÖ SUCCESS: map_admin_user_select_continue - returned to map admin menu`);
          
          return ui;
        }
      })(req, res, client);
      
    // ==================== START SAFARI HANDLERS ====================
    } else if (custom_id === 'safari_start_safari') {
      return ButtonHandlerFactory.create({
        id: 'safari_start_safari',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        handler: async (context) => {
          const { handleStartSafari } = await import('./safariStartSafari.js');
          return handleStartSafari(context);
        }
      })(req, res, client);

    } else if (custom_id === 'safari_start_user_select') {
      return ButtonHandlerFactory.create({
        id: 'safari_start_user_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        deferred: true,
        handler: async (context) => {
          const { handleUserSelect } = await import('./safariStartSafari.js');
          return handleUserSelect(context);
        }
      })(req, res, client);

    } else if (custom_id === 'safari_start_safari_go') {
      return ButtonHandlerFactory.create({
        id: 'safari_start_safari_go',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        deferred: true,
        handler: async (context) => {
          const { handleStartSafariGo } = await import('./safariStartSafari.js');
          return handleStartSafariGo(context);
        }
      })(req, res, client);

    } else if (custom_id === 'safari_remove_players') {
      return ButtonHandlerFactory.create({
        id: 'safari_remove_players',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        deferred: true,
        handler: async (context) => {
          const { handleRemovePlayers } = await import('./safariStartSafari.js');
          return handleRemovePlayers(context);
        }
      })(req, res, client);

    } else if (custom_id === 'safari_remove_user_select') {
      return ButtonHandlerFactory.create({
        id: 'safari_remove_user_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        deferred: true,
        handler: async (context) => {
          const { handleRemoveUserSelect } = await import('./safariStartSafari.js');
          return handleRemoveUserSelect(context);
        }
      })(req, res, client);

    } else if (custom_id === 'safari_remove_players_go') {
      return ButtonHandlerFactory.create({
        id: 'safari_remove_players_go',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true,
        deferred: true,
        handler: async (context) => {
          const { handleRemovePlayersGo } = await import('./safariStartSafari.js');
          return handleRemovePlayersGo(context);
        }
      })(req, res, client);

    // ==================== END SAFARI HANDLERS ====================

    // ==================== END MAP ADMIN HANDLERS ====================

    // ==================== START PAUSED PLAYERS HANDLERS ====================
    } else if (custom_id === 'safari_paused_players') {
      return ButtonHandlerFactory.create({
        id: 'safari_paused_players',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true, // Update instead of creating new message
        deferred: true,  // Enable deferred response - fetches Discord members (network-bound, can exceed 3s timeout)
        handler: async (context) => {
          console.log(`‚è∏Ô∏è START: safari_paused_players - user ${context.userId}`);
          
          const { createPausedPlayersUI } = await import('./pausedPlayersManager.js');
          const ui = await createPausedPlayersUI(context.guildId, context.client);
          
          console.log(`‚úÖ SUCCESS: safari_paused_players - showing paused players interface`);
          return ui;
        }
      })(req, res, client);
      
    } else if (custom_id === 'safari_pause_players_select') {
      // Handle the user select interaction for pausing/unpausing players
      return ButtonHandlerFactory.create({
        id: 'safari_pause_players_select',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        updateMessage: true, // Update the existing message
        handler: async (context) => {
          console.log(`‚è∏Ô∏è START: safari_pause_players_select - user ${context.userId}`);
          
          // Get selected user IDs from the interaction
          const selectedUserIds = context.values || [];
          console.log(`‚è∏Ô∏è Selected users to pause: ${selectedUserIds.length}`);
          
          // Update paused states
          const { updatePausedPlayers, createPausedPlayersUI } = await import('./pausedPlayersManager.js');
          const result = await updatePausedPlayers(context.guildId, selectedUserIds, context.client);
          
          if (result.success) {
            console.log(`‚úÖ SUCCESS: Paused ${result.paused}, Unpaused ${result.unpaused}`);
          } else {
            console.log(`‚ùå FAILED: ${result.message}`);
          }
          
          // Return updated interface with new paused states
          const ui = await createPausedPlayersUI(context.guildId, context.client);
          
          // Remove ephemeral and flags for UPDATE_MESSAGE response
          delete ui.ephemeral;
          delete ui.flags;
          
          return ui;
        }
      })(req, res, client);
    // ==================== END PAUSED PLAYERS HANDLERS ====================
    
    } else if (custom_id === 'prod_add_tribe_role_select') {
      // Step 2: After role selected, show castlist selection
      try {
        const guildId = req.body.guild_id;
        const selectedRoleIds = data.values || [];
        
        if (selectedRoleIds.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'Please select a tribe role.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const selectedRoleId = selectedRoleIds[0];
        
        // Get existing castlists
        const playerData = await loadPlayerData();
        const existingCastlists = new Set();
        
        if (playerData[guildId]?.tribes) {
          Object.values(playerData[guildId].tribes).forEach(tribe => {
            if (tribe.castlist && tribe.castlist !== 'default') {
              existingCastlists.add(tribe.castlist);
            }
          });
        }
        
        // Build string select options
        const options = [
          {
            label: 'Default Castlist',
            description: 'Recommended if you don\'t know what you\'re doing',
            value: 'default',
            emoji: { name: '‚úÖ' }
          }
        ];
        
        // Add existing custom castlists
        for (const castlistName of Array.from(existingCastlists).sort()) {
          options.push({
            label: castlistName.charAt(0).toUpperCase() + castlistName.slice(1),
            description: 'Existing custom castlist',
            value: castlistName,
            emoji: { name: 'üìÉ' }
          });
        }
        
        // Add "New Custom Castlist" option
        options.push({
          label: 'New Custom Castlist',
          description: 'Custom castlist, typically used for prod / winner / custom challenge teams',
          value: 'new_custom',
          emoji: { name: 'üìù' }
        });
        
        // Use Discord.js StringSelectMenuBuilder for better compatibility
        const stringSelect = new StringSelectMenuBuilder()
          .setCustomId(`prod_add_tribe_castlist_select_${selectedRoleId}`)
          .setPlaceholder('Select castlist')
          .setMinValues(1)
          .setMaxValues(1)
          .addOptions(options.slice(0, 25)); // Discord limit

        // Create ComponentsV2 container following LEAN Menu Design Standards
        const selectCastlistContainer = {
          type: 17, // Container (MANDATORY for ComponentsV2)
          accent_color: 0xE67E22, // Orange accent to match tribe management theme
          components: [
            {
              type: 10, // Text Display
              content: `## CastBot | Select Castlist`
            },
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display
              content: `**Role selected:** <@&${selectedRoleId}>\n\nNow choose which castlist to add this tribe to:`
            },
            {
              type: 14 // Separator
            },
            {
              type: 1, // ActionRow
              components: [{
                type: 3, // String Select
                custom_id: `prod_add_tribe_castlist_select_${selectedRoleId}`,
                placeholder: 'Select castlist',
                min_values: 1,
                max_values: 1,
                options: options.slice(0, 25) // Discord limit
              }]
            }
          ]
        };

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
            components: [selectCastlistContainer]
          }
        });
        
      } catch (error) {
        console.error('Error in add tribe role select:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error processing tribe role selection.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('prod_add_tribe_castlist_select_')) {
      // Step 3: After castlist selected, show modal for emoji input
      try {
        const roleId = custom_id.split('_').pop();
        const selectedCastlist = data.values?.[0];
        
        if (!selectedCastlist) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'Please select a castlist.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        let finalCastlist = selectedCastlist;
        
        // If "new_custom" was selected, we'll handle it in the modal submission
        // For now, show the modal
        
        const modal = {
          title: 'Add Tribe - Final Step',
          custom_id: `prod_add_tribe_modal_${roleId}_${selectedCastlist}`,
          components: [
            {
              type: 1, // Action Row
              components: [
                {
                  type: 4, // Text Input
                  custom_id: 'tribe_emoji',
                  label: 'Tribe Emoji (Optional)',
                  style: 1, // Short
                  min_length: 0,
                  max_length: 4000,
                  required: false,
                  placeholder: 'Emoji or custom emoji: ü¶Ö or <:BlackEagles:1393529844779974687>'
                }
              ]
            }
          ]
        };
        
        // Show additional text input for custom castlist name if needed
        if (selectedCastlist === 'new_custom') {
          modal.components.push({
            type: 1, // Action Row
            components: [
              {
                type: 4, // Text Input
                custom_id: 'custom_castlist_name',
                label: 'Custom Castlist Name',
                style: 1, // Short
                min_length: 1,
                max_length: 50,
                required: true,
                placeholder: 'e.g. Winners, Production, Alumni'
              }
            ]
          });
        }
        
        // Removed alumni_placements modal fields - using centralized placement system instead

        return res.send({
          type: InteractionResponseType.MODAL,
          data: modal
        });
        
      } catch (error) {
        console.error('Error in add tribe castlist select:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error processing castlist selection.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'prod_clear_tribe_select') {
      // Handle clear tribe selection
      try {
        const guildId = req.body.guild_id;
        const selectedRoleIds = data.values || [];
        
        if (selectedRoleIds.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'Please select at least one tribe to clear.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Load and update playerData
        const playerData = await loadPlayerData();
        if (!playerData[guildId]?.tribes) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'No tribes found to clear.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const removedTribes = [];
        
        // Remove selected tribes
        for (const roleId of selectedRoleIds) {
          if (playerData[guildId].tribes[roleId]) {
            const guild = await client.guilds.fetch(guildId);
            const role = guild.roles.cache.get(roleId);
            removedTribes.push(role?.name || 'Unknown Role');
            delete playerData[guildId].tribes[roleId];
          }
        }
        
        await savePlayerData(playerData);
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `## Tribes Cleared!\n\nüóëÔ∏è Removed ${removedTribes.length} tribe(s):\n${removedTribes.map(name => `‚Ä¢ ${name}`).join('\n')}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error clearing tribes:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error clearing tribes.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'prod_emoji_role_select') {
      // Handle emoji generation/removal role selection
      try {
        const guildId = req.body.guild_id;
        const selectedRoleIds = data.values || [];
        
        if (selectedRoleIds.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'Please select a role to generate/clear emojis for.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const roleId = selectedRoleIds[0]; // Only one role can be selected
        const guild = await client.guilds.fetch(guildId);
        
        // Fetch the role specifically to ensure we have the latest data
        const role = await guild.roles.fetch(roleId);
        
        console.log(`DEBUG: Selected role ID: ${roleId}`);
        console.log(`DEBUG: Fetched role: ${role?.name} (${role?.id})`);
        
        if (!role) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'Selected role not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Check if role has existing emojis generated for it
        const hasExistingEmojis = await checkRoleHasEmojis(guild, role);
        
        if (hasExistingEmojis) {
          // Clear existing emojis
          res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `## Clearing Emojis for ${role.name}\n\n‚è≥ Removing existing emojis for members with the **${role.name}** role. This may take a moment...`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
          
          const emojiResult = await clearEmojisForRole(guild, role);
          
          // Prepare response message
          const messageLines = [`## Emoji Removal Complete for ${role.name}\n`];
          
          if (emojiResult.deletedLines.length > 0) {
            messageLines.push('‚úÖ **Emojis removed:**');
            messageLines.push(...emojiResult.deletedLines.map(line => `‚Ä¢ ${line}`));
            messageLines.push('');
          }
          
          if (emojiResult.errorLines.length > 0) {
            messageLines.push('‚ö†Ô∏è **Errors encountered:**');
            messageLines.push(...emojiResult.errorLines.map(line => `‚Ä¢ ${line}`));
            messageLines.push('');
          }
          
          if (emojiResult.deletedLines.length === 0 && emojiResult.errorLines.length === 0) {
            messageLines.push('‚ÑπÔ∏è No emojis found to remove for this role.');
          }
          
          // Send follow-up response with results
          await DiscordRequest(`webhooks/${process.env.APP_ID}/${req.body.token}`, {
            method: 'POST',
            body: {
              content: messageLines.join('\n'),
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
          
        } else {
          // Generate new emojis
          res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `## Generating Emojis for ${role.name}\n\n‚è≥ Processing emoji generation for members with the **${role.name}** role. This may take a moment...`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
          
          const emojiResult = await generateEmojisForRole(guild, role);
          
          // Prepare response message
          const messageLines = [`## Emoji Generation Complete for ${role.name}\n`];
          
          if (emojiResult.resultLines.length > 0) {
            messageLines.push('‚úÖ **New emojis created:**');
            messageLines.push(...emojiResult.resultLines.map(line => `‚Ä¢ ${line}`));
            messageLines.push('');
          }
          
          if (emojiResult.existingLines.length > 0) {
            messageLines.push('‚ÑπÔ∏è **Existing emojis found:**');
            messageLines.push(...emojiResult.existingLines.map(line => `‚Ä¢ ${line}`));
            messageLines.push('');
          }
          
          if (emojiResult.errorLines.length > 0) {
            messageLines.push('‚ö†Ô∏è **Errors encountered:**');
            messageLines.push(...emojiResult.errorLines.map(line => `‚Ä¢ ${line}`));
            messageLines.push('');
          }
          
          if (emojiResult.maxEmojiReached) {
            messageLines.push('üö® **Server emoji limit reached.** Some emojis could not be created.');
          }
          
          // Send follow-up response with results
          await DiscordRequest(`webhooks/${process.env.APP_ID}/${req.body.token}`, {
            method: 'POST',
            body: {
              content: messageLines.join('\n'),
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
      } catch (error) {
        console.error('Error managing emojis:', error);
        
        // Send error follow-up
        try {
          await DiscordRequest(`webhooks/${process.env.APP_ID}/${req.body.token}`, {
            method: 'POST',
            body: {
              content: 'Error managing emojis. Please try again later.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        } catch (followUpError) {
          console.error('Error sending follow-up error message:', followUpError);
        }
      }
    } else if (custom_id === 'admin_player_select_update') {
      // üîò Convert to ButtonHandlerFactory
      return ButtonHandlerFactory.create({
        id: 'admin_player_select_update',
        updateMessage: true, // Update existing message
        handler: async (context) => {
          const { guildId, client, values } = context;
          const guild = await client.guilds.fetch(guildId);
          const selectedPlayerIds = values || [];

          // Load player data
          const playerData = await loadPlayerData();
          let targetMember = null;
          let titleContent = `Player Management | ${guild.name}`;

          // Handle player selection/deselection
          if (selectedPlayerIds.length > 0) {
            const selectedPlayerId = selectedPlayerIds[0];

            // Get selected player info
            try {
              targetMember = await guild.members.fetch(selectedPlayerId);
              titleContent = `Player Management | ${targetMember.displayName}`;
            } catch (error) {
              console.log('Player not found, keeping no selection');
              targetMember = null;
            }
          }

          // Create player management UI using the new module
          const managementUI = await createPlayerManagementUI({
            mode: PlayerManagementMode.ADMIN,
            targetMember,
            playerData,
            guildId,
            showUserSelect: true,
            showVanityRoles: true,
            title: titleContent,
            bottomLeftButton: {
              label: '‚¨ÖÔ∏è Menu',
              customId: 'prod_menu_back',
              style: ButtonStyle.Secondary
            },
            client
          });

          // Remove ephemeral flag for update message
          managementUI.flags = (1 << 15); // Only IS_COMPONENTS_V2

          return managementUI;
        }
      })(req, res, client);
    } else if (custom_id === 'admin_select_player') {
      // Legacy handler - redirect to new system
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: 'üîÑ Please use the updated Player Management interface from the main menu.',
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });

    } else if (custom_id.startsWith('apply_')) {
      try {
        console.log('Processing apply button click:', custom_id);
        
        const configId = custom_id.replace('apply_', '');
        const guildId = req.body.guild_id;
        const userId = req.body.member.user.id;
        const userDisplayName = req.body.member.nick || req.body.member.user.username;
        
        const guild = await client.guilds.fetch(guildId);
        const member = await guild.members.fetch(userId);
        
        // Get the application configuration
        console.log('Looking for application config:', configId, 'in guild:', guildId);
        const config = await getApplicationConfig(guildId, configId);
        console.log('Found config:', config ? 'Yes' : 'No');
        
        if (!config) {
          console.error(`Application config not found: ${configId} in guild: ${guildId}`);
          
          // Debug: List all available configs
          const playerData = await loadPlayerData();
          const allConfigs = playerData[guildId]?.applicationConfigs || {};
          console.log('Available configs:', Object.keys(allConfigs));
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'Application button configuration not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Create the application channel
        const result = await createApplicationChannel(guild, member, config, configId);
        
        if (!result.success) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: result.error,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚úÖ Your application channel has been created: ${result.channel}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });

      } catch (error) {
        console.error('Error in apply button handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error processing application request.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'select_target_channel' || custom_id === 'select_application_category' || custom_id === 'select_button_style' || custom_id === 'select_production_role' ||
               custom_id.startsWith('select_target_channel_') || custom_id.startsWith('select_application_category_') || custom_id.startsWith('select_button_style_') || custom_id.startsWith('select_production_role_')) {
      try {
        console.log('Processing application configuration selection:', custom_id);
        
        const guildId = req.body.guild_id;
        const userId = req.body.member.user.id;
        
        // Get selected value from Components v2
        let selectedValue;
        
        // Check if this is a role selection - role selections can be empty (cleared)
        const isRoleSelection = custom_id === 'select_production_role' || custom_id.startsWith('select_production_role_');
        
        if (!data.values || data.values.length === 0) {
          if (isRoleSelection) {
            // For role selection, empty values means the user cleared the selection - this is valid
            selectedValue = null;
            console.log('Role selection cleared (empty values array)');
          } else {
            // For other selections, empty values is an error
            console.error('No values found in component data');
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: 'Error: No selection received. Please try again.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
        } else {
          selectedValue = data.values[0];
        }
        
        console.log('Selected value:', selectedValue);
        
        // Find the temporary config for this user
        const playerData = await loadPlayerData();
        const guildData = playerData[guildId];
        
        if (!guildData?.applicationConfigs) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'Configuration session expired. Please try creating the application button again.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Extract config ID from custom_id if present, otherwise find by user ID
        let configId;
        if (custom_id.includes('_config_') || custom_id.includes('_temp_')) {
          // Extract config ID from custom_id (e.g., select_target_channel_config_1751549410029_391415444084490240)
          const configIdMatch = custom_id.match(/_(config|temp)_(.+)$/);
          if (configIdMatch) {
            configId = `${configIdMatch[1]}_${configIdMatch[2]}`;
            console.log('üîç DEBUG: Extracted config ID from custom_id:', configId);
          }
        }
        
        if (!configId) {
          // Fallback to old method - find by user ID
          configId = Object.keys(guildData.applicationConfigs)
            .find(id => (id.startsWith(`temp_`) || id.startsWith(`config_`)) && id.endsWith(`_${userId}`));
          console.log('üîç DEBUG: Using fallback config ID search:', configId);
        }
        
        if (!configId) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'Configuration session not found. Please try creating the application button again.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const tempConfig = guildData.applicationConfigs[configId];
        
        console.log('Current tempConfig before update:', JSON.stringify(tempConfig, null, 2));
        
        // Update the temp config with the selection
        if (custom_id === 'select_target_channel' || custom_id.startsWith('select_target_channel_')) {
          tempConfig.targetChannelId = selectedValue;
          console.log('Updated targetChannelId to:', selectedValue);
        } else if (custom_id === 'select_application_category' || custom_id.startsWith('select_application_category_')) {
          tempConfig.categoryId = selectedValue;
          console.log('Updated categoryId to:', selectedValue);
        } else if (custom_id === 'select_button_style' || custom_id.startsWith('select_button_style_')) {
          tempConfig.buttonStyle = selectedValue;
          console.log('Updated buttonStyle to:', selectedValue);
        } else if (custom_id === 'select_production_role' || custom_id.startsWith('select_production_role_')) {
          // For role select, the value might be empty (no selection)
          tempConfig.productionRole = selectedValue || null;
          console.log('Updated productionRole to:', selectedValue || 'none');
        }
        
        console.log('Updated tempConfig after selection:', JSON.stringify(tempConfig, null, 2));
        
        // Save the updated config
        await saveApplicationConfig(guildId, configId, tempConfig);
        
        // Get fresh guild and categories for UI refresh
        const guild = await client.guilds.fetch(guildId);
        const categories = guild.channels.cache
          .filter(channel => channel.type === ChannelType.GuildCategory)
          .sort((a, b) => a.position - b.position)
          .first(25);
        
        // Create refreshed container with updated selections
        const refreshedContainer = createApplicationSetupContainer(tempConfig, configId, categories);
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
            components: [refreshedContainer]
          }
        });
        
      } catch (error) {
        console.error('Error handling application configuration selection:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error processing your selection. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('create_app_button_')) {
      return ButtonHandlerFactory.create({
        id: 'create_app_button',
        deferred: true, // MANDATORY - this operation involves multiple API calls and can take >3s
        ephemeral: true,
        handler: async (context) => {
          const { guildId, userId, customId, client } = context;
          const configId = customId.replace('create_app_button_', '');
          
          logger.info('BUTTON', 'START: create_app_button', { userId, guildId, configId });
          
          try {
            // Load the config
            logger.debug('APPLICATION', 'Loading application config', { configId });
            const playerData = await loadPlayerData();
            const tempConfig = playerData[guildId]?.applicationConfigs?.[configId];
            
            if (!tempConfig) {
              logger.warn('APPLICATION', 'Config not found', { configId, guildId });
              return {
                content: '‚ùå Configuration not found. Please try again.',
                components: [],
                flags: InteractionResponseFlags.EPHEMERAL
              };
            }
            
            logger.debug('APPLICATION', 'Config loaded', {
              targetChannelId: tempConfig.targetChannelId,
              categoryId: tempConfig.categoryId,
              buttonStyle: tempConfig.buttonStyle,
              buttonText: tempConfig.buttonText
            });
            
            // Verify all selections are made
            if (!tempConfig.targetChannelId || !tempConfig.categoryId || !tempConfig.buttonStyle) {
              logger.warn('APPLICATION', 'Missing required config fields', {
                targetChannelId: tempConfig.targetChannelId,
                categoryId: tempConfig.categoryId,
                buttonStyle: tempConfig.buttonStyle
              });
              return {
                content: '‚ùå Please complete all selections before creating the button.',
                components: [],
                flags: InteractionResponseFlags.EPHEMERAL
              };
            }
            
            // Fetch guild and channels
            logger.debug('APPLICATION', 'Fetching guild and channels');
            const guild = await client.guilds.fetch(guildId);
            const targetChannel = await guild.channels.fetch(tempConfig.targetChannelId);
            const category = await guild.channels.fetch(tempConfig.categoryId);
            
            logger.debug('APPLICATION', 'Discord resources fetched', {
              guildName: guild.name,
              targetChannel: targetChannel.name,
              category: category.name
            });
            
            if (configId.startsWith('temp_')) {
              // Create final configuration for temp configs
              const finalConfigId = `config_${Date.now()}_${userId}`;
              
              const finalConfig = {
                buttonText: tempConfig.buttonText,
                explanatoryText: tempConfig.explanatoryText,
                completionDescription: tempConfig.completionDescription,
                completionImage: tempConfig.completionImage || null,
                channelFormat: tempConfig.channelFormat,
                targetChannelId: tempConfig.targetChannelId,
                categoryId: tempConfig.categoryId,
                buttonStyle: tempConfig.buttonStyle,
                productionRole: tempConfig.productionRole || null,
                createdBy: userId,
                stage: 'active',
                // Backwards compatibility
                welcomeDescription: tempConfig.welcomeDescription,
                welcomeTitle: tempConfig.welcomeTitle
              };
              
              logger.debug('APPLICATION', 'Saving final config', { finalConfigId });
              await saveApplicationConfig(guildId, finalConfigId, finalConfig);
              
              // Create and post the button as a Components V2 container
              const button = createApplicationButton(tempConfig.buttonText, finalConfigId, tempConfig.buttonStyle);
              const channelCard = {
                type: 17, // Container
                accent_color: 0x3498db,
                components: []
              };
              if (tempConfig.explanatoryText?.trim()) {
                channelCard.components.push({ type: 10, content: tempConfig.explanatoryText.trim() });
                channelCard.components.push({ type: 14 });
              }
              channelCard.components.push({ type: 1, components: [button.toJSON()] });

              logger.debug('APPLICATION', 'Posting button to channel', { channelId: targetChannel.id });
              await DiscordRequest(`channels/${targetChannel.id}/messages`, {
                method: 'POST',
                body: { flags: (1 << 15), components: [channelCard] }
              });

              // Clean up temp config
              delete playerData[guildId].applicationConfigs[configId];
              await savePlayerData(playerData);
              logger.debug('APPLICATION', 'Temp config cleaned up', { configId });

              logger.info('APPLICATION', 'SUCCESS: Application button created', {
                userId,
                guildId,
                channelName: targetChannel.name,
                buttonText: tempConfig.buttonText
              });

              return {
                flags: (1 << 15),
                components: [{
                  type: 17, // Container
                  accent_color: 0x27ae60, // Green
                  components: [
                    { type: 10, content: `## ‚úÖ Application Button Posted!\n\nüìù **${tempConfig.buttonText}** posted to <#${targetChannel.id}>\n> **Category:** ${category.name}\n> **Style:** ${tempConfig.buttonStyle}` },
                    { type: 14 },
                    { type: 1, components: [{ type: 2, custom_id: 'prod_menu_back', label: '‚Üê Menu', style: 2 }] }
                  ]
                }]
              };
              
            } else if (configId.startsWith('config_')) {
              // Update season config and post
              logger.debug('APPLICATION', 'Processing season config', { configId });
              
              tempConfig.stage = 'active';
              tempConfig.lastUpdated = Date.now();
              await saveApplicationConfig(guildId, configId, tempConfig);
              logger.debug('APPLICATION', 'Config updated', { configId });
              
              // Create and post the button as a Components V2 container
              const button = createApplicationButton(tempConfig.buttonText, configId, tempConfig.buttonStyle);
              const channelCard = {
                type: 17, // Container
                accent_color: 0x3498db,
                components: []
              };
              if (tempConfig.explanatoryText?.trim()) {
                channelCard.components.push({ type: 10, content: tempConfig.explanatoryText.trim() });
                channelCard.components.push({ type: 14 });
              }
              channelCard.components.push({ type: 1, components: [button.toJSON()] });

              logger.debug('APPLICATION', 'Posting season button to channel', { channelId: targetChannel.id });
              await DiscordRequest(`channels/${targetChannel.id}/messages`, {
                method: 'POST',
                body: { flags: (1 << 15), components: [channelCard] }
              });

              logger.info('APPLICATION', 'SUCCESS: Season application button posted', {
                userId,
                guildId,
                channelName: targetChannel.name,
                buttonText: tempConfig.buttonText,
                categoryName: category.name
              });

              return {
                flags: (1 << 15),
                components: [{
                  type: 17, // Container
                  accent_color: 0x27ae60, // Green
                  components: [
                    { type: 10, content: `## ‚úÖ Season Application Button Posted!\n\nüìù **${tempConfig.buttonText}** posted to <#${targetChannel.id}>\n> **Category:** ${category.name}\n> **Style:** ${tempConfig.buttonStyle}\n\nApplicants will now go through your configured questions when they apply.` },
                    { type: 14 },
                    { type: 1, components: [{ type: 2, custom_id: 'prod_menu_back', label: '‚Üê Menu', style: 2 }] }
                  ]
                }]
              };
            } else {
              logger.error('APPLICATION', 'Unknown configId format', { configId });
              return {
                content: '‚ùå Invalid configuration ID format. Please try again.',
                components: []
              };
            }
            
          } catch (error) {
            logger.error('APPLICATION', 'Failed to create application button', error);
            return {
              content: '‚ùå Error creating application button. Please try again.',
              components: []
            };
          }
        }
      })(req, res, client);
    } else if (custom_id.startsWith('castlist2_nav_')) {
      // Handle new castlist2 navigation system
      try {
        const user = req.body.member?.user || req.body.user;
        console.log(`Processing castlist2 navigation: ${custom_id} | User: ${user?.username || 'Unknown'}#${user?.discriminator || '0000'} (${user?.id || 'Unknown ID'})`);
        
        // Parse new format: castlist2_nav_${action}_${tribeIndex}_${tribePage}_${castlistName}_${displayMode}
        // Example: castlist2_nav_next_page_0_0_default_view
        // Example: castlist2_nav_next_page_0_0_legacyList_edit
        // We need to be careful because action can contain underscores (next_page, last_tribe, etc.)

        // Remove the 'castlist2_nav_' prefix
        const withoutPrefix = custom_id.substring('castlist2_nav_'.length);
        const parts = withoutPrefix.split('_');

        // Format: action_{tribeIndex}_{tribePage}_{castlistId}_{displayMode}
        // CRITICAL: castlistId has underscores! Use position-based parsing

        if (parts.length < 5) {
          throw new Error('Invalid navigation custom_id format - needs at least 5 parts');
        }

        // Position-based parsing (actions are always 2 parts: next_page, last_tribe, etc.)
        // parts[0-1]: action (2 parts)
        // parts[2]: tribeIndex
        // parts[3]: tribePage
        // parts[4 to length-2]: castlistId (may have underscores!)
        // parts[length-1]: displayMode

        const displayMode = parts[parts.length - 1] || 'view';
        const action = `${parts[0]}_${parts[1]}`;  // Actions are always 2 parts
        const currentTribeIndex = parseInt(parts[2]);
        const currentTribePage = parseInt(parts[3]);
        const castlistId = parts.slice(4, parts.length - 1).join('_');

        console.log('Parsed navigation:', { action, currentTribeIndex, currentTribePage, castlistId, displayMode, user: `${user?.username}#${user?.discriminator} (${user?.id})` });
        
        // Ignore disabled buttons
        if (action.startsWith('disabled_')) {
          return res.send({
            type: InteractionResponseType.DEFERRED_UPDATE_MESSAGE
          });
        }
        
        // Send deferred response
        res.send({
          type: InteractionResponseType.DEFERRED_UPDATE_MESSAGE
        });
        
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);

        // ‚úÖ NEW: Use unified data access (eliminates 39 lines of duplicate code)
        const { getTribesForCastlist } = await import('./castlistDataAccess.js');
        const validTribes = await getTribesForCastlist(guildId, castlistId, client);

        if (validTribes.length === 0) {
          // No tribes found - update message to show error
          await DiscordRequest(`webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`, {
            method: 'PATCH',
            body: {
              content: `No tribes found for castlist: ${castlistId}`,
              components: []
            }
          });
          return;
        }

        // Pre-load playerData for sorting context
        const playerData = await loadPlayerData();
        const orderedTribes = reorderTribes(validTribes, req.body.member.user.id, "user-first", castlistId);  // FIX: Use castlistId
        const scenario = determineDisplayScenario(orderedTribes);
        
        // Calculate new navigation position
        let newTribeIndex = currentTribeIndex;
        let newTribePage = currentTribePage;
        
        switch(action) {
          case 'next_page':
            newTribePage++;
            break;
          case 'last_page':
            newTribePage--;
            break;
          case 'next_tribe':
            newTribeIndex++;
            newTribePage = 0; // Reset to first page of new tribe
            break;
          case 'last_tribe':
            newTribeIndex--;
            newTribePage = 0; // Reset to first page of new tribe
            break;
        }
        
        // Validate bounds - handle missing/deleted tribes gracefully
        if (newTribeIndex < 0 || newTribeIndex >= orderedTribes.length) {
          console.warn(`Invalid tribe index ${newTribeIndex} for ${orderedTribes.length} tribes (server: ${guildId}), resetting to 0`);
          newTribeIndex = 0;
          newTribePage = 0;
          
          // If no valid tribes exist at all, show error
          if (orderedTribes.length === 0) {
            throw new Error('No valid tribes found - all roles may have been deleted');
          }
        }

        // Create new navigation state
        const navigationState = createNavigationState(orderedTribes, scenario, newTribeIndex, newTribePage, guild, { playerData, guildId });

        // Get castlist name for display (same pattern as show_castlist2 handler)
        const castlistEntity = playerData[guildId]?.castlistConfigs?.[castlistId];
        const castlistName = castlistEntity?.name || castlistId;

        // Send updated response (preserve displayMode for edit mode navigation)
        await sendCastlist2Response(req, guild, orderedTribes, castlistId, navigationState, req.body.member, req.body.channel_id, displayMode, castlistName, { playerData, guildId });

        console.log(`Successfully navigated to tribe ${newTribeIndex + 1}, page ${newTribePage + 1} in ${displayMode} mode`);

      } catch (error) {
        console.error('Error handling castlist2 navigation:', error);
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;

        // Sanitize error message (Cloudflare HTML pages can be >10KB)
        const { sanitizeErrorMessage } = await import('./utils.js');
        const errorMessage = sanitizeErrorMessage(error);

        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            flags: 1 << 15, // Keep IS_COMPONENTS_V2 flag
            components: [
              {
                type: 10, // Text Display
                content: `# Error\nError navigating castlist: ${errorMessage}`
              }
            ]
          }
        });
      }
    } else if (custom_id.startsWith('castlist2_tribe_prev_') || custom_id.startsWith('castlist2_tribe_next_')) {
      // Handle castlist2 tribe navigation buttons
      try {
        console.log('Processing castlist2 tribe navigation:', custom_id);
        
        // Parse the custom_id to extract components
        // Format: castlist2_tribe_prev_${currentTribePage}_${castlistName} or castlist2_tribe_next_${currentTribePage}_${castlistName}
        const isNext = custom_id.startsWith('castlist2_tribe_next_');
        const prefix = isNext ? 'castlist2_tribe_next_' : 'castlist2_tribe_prev_';
        const parts = custom_id.substring(prefix.length).split('_');
        
        if (parts.length < 2) {
          throw new Error('Invalid tribe navigation custom_id format');
        }
        
        const currentTribePage = parseInt(parts[0]);
        const castlistName = parts.slice(1).join('_');
        
        console.log('Parsed tribe navigation:', { currentTribePage, castlistName, isNext });
        
        // Calculate new tribe page
        const newTribePage = isNext ? currentTribePage + 1 : currentTribePage - 1;
        
        // Send deferred response
        await res.send({
          type: InteractionResponseType.DEFERRED_UPDATE_MESSAGE
        });
        
        const guildId = req.body.guild_id;
        
        // Load tribe data
        const tribes = await getGuildTribes(guildId, castlistName);
        const totalTribes = tribes.length;
        
        if (newTribePage < 0 || newTribePage >= totalTribes) {
          throw new Error('Invalid tribe page');
        }
        
        // Get the tribe to display
        const currentTribe = tribes[newTribePage];
        
        // Fetch guild data
        const fullGuild = await client.guilds.fetch(guildId, { force: true });
        await fullGuild.roles.fetch();
        const members = await fullGuild.members.fetch();
        
        // Get tribe role and members
        const role = await fullGuild.roles.fetch(currentTribe.roleId);
        if (!role) {
          throw new Error('Tribe role not found');
        }
        
        const tribeMembers = members.filter(member => member.roles.cache.has(role.id));
        console.log(`Found ${tribeMembers.size} members in ${role.name}`);
        
        // Get pronoun and timezone data
        const pronounRoleIds = await getGuildPronouns(guildId);
        const timezones = await getGuildTimezones(guildId);
        
        let tribeSection;
        
        if (tribeMembers.size === 0) {
          // Convert hex color to integer if needed
          let accentColor = 0x7ED321; // Default green
          if (currentTribe.color) {
            if (typeof currentTribe.color === 'string' && currentTribe.color.startsWith('#')) {
              // Convert hex string to integer
              accentColor = parseInt(currentTribe.color.slice(1), 16);
            } else if (typeof currentTribe.color === 'number') {
              accentColor = currentTribe.color;
            }
          }

          // Create empty tribe container
          tribeSection = {
            type: 17, // Container
            accent_color: accentColor,
            components: [
              {
                type: 10, // Text Display
                content: `# ${currentTribe.emoji || ''} ${role.name} ${currentTribe.emoji || ''}`.trim()
              },
              {
                type: 14 // Separator after tribe name
              },
              {
                type: 10, // Text Display
                content: '_No players yet_'
              }
            ]
          };
        } else {
          // Convert to array and sort by display name
          const sortedMembers = Array.from(tribeMembers.values())
            .sort((a, b) => a.displayName.localeCompare(b.displayName));

          // Create tribe section using Components V2
          tribeSection = await createTribeSection(
            { ...currentTribe, name: role.name }, // Use role name for accuracy
            sortedMembers, // Pass all members, let createTribeSection handle pagination
            fullGuild,
            pronounRoleIds,
            timezones,
            0, // page within tribe
            13 // playersPerPage
          );
        }

        const tribeComponents = [tribeSection];
        const navigationRows = [];

        // Add tribe navigation buttons
        if (totalTribes > 1) {
          const navRow = new ActionRowBuilder()
            .addComponents(
              new ButtonBuilder()
                .setCustomId(`castlist2_tribe_prev_${newTribePage}_${castlistName}`)
                .setLabel('‚óÄ Last Tribe')
                .setStyle(ButtonStyle.Secondary)
                .setDisabled(newTribePage === 0),
              new ButtonBuilder()
                .setCustomId(`castlist2_tribe_indicator_${newTribePage}`)
                .setLabel(`Tribe ${newTribePage + 1}/${totalTribes}`)
                .setStyle(ButtonStyle.Primary)
                .setDisabled(true),
              new ButtonBuilder()
                .setCustomId(`castlist2_tribe_next_${newTribePage}_${castlistName}`)
                .setLabel('Next Tribe ‚ñ∂')
                .setStyle(ButtonStyle.Secondary)
                .setDisabled(newTribePage >= totalTribes - 1)
            );
          navigationRows.push(navRow.toJSON());
        }

        // Create the complete Components V2 layout (viral buttons now in navigation)
        const responseData = createCastlistV2Layout(
          tribeComponents,
          castlistName,
          fullGuild,
          navigationRows,
          [], // No separate viral buttons needed
          client
        );

        // Check permissions and apply ephemeral flag if user cannot send messages
        const member = req.body.member;
        const channelId = req.body.channel_id;
        if (member && channelId) {
          const canSendMessages = await canSendMessagesInChannel(member, channelId, client);
          console.log(`Permission check: User ${member.user?.username} can send messages in channel ${channelId}: ${canSendMessages}`);
          
          if (!canSendMessages) {
            // Add ephemeral flag to response if user cannot send messages
            responseData.flags = (responseData.flags || 0) | InteractionResponseFlags.EPHEMERAL;
            console.log(`Applied ephemeral flag - castlist visible only to user ${member.user?.username}`);
          }
        }

        // Update the message
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: responseData,
        });

      } catch (error) {
        console.error('Error handling castlist2 tribe navigation:', error);
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            flags: 1 << 15, // IS_COMPONENTS_V2 flag
            components: [
              {
                type: 10, // Text Display
                content: `# Error\nError navigating tribes: ${error.message}`
              }
            ]
          },
        });
      }
    } else if (custom_id.startsWith('castlist2_prev_') || custom_id.startsWith('castlist2_next_')) {
      // Handle castlist2 pagination buttons
      try {
        console.log('Processing castlist2 navigation:', custom_id);
        
        // Parse the custom_id to extract components
        // Format: castlist2_prev_${tribeId}_${currentPage}_${castlistName} or castlist2_next_${tribeId}_${currentPage}_${castlistName}
        const isNext = custom_id.startsWith('castlist2_next_');
        const prefix = isNext ? 'castlist2_next_' : 'castlist2_prev_';
        const parts = custom_id.substring(prefix.length).split('_');
        
        if (parts.length < 3) {
          throw new Error('Invalid button custom_id format');
        }
        
        // Extract components - handle tribeId that might contain underscores
        const castlistName = parts[parts.length - 1];
        const currentPage = parseInt(parts[parts.length - 2]);
        const tribeId = parts.slice(0, parts.length - 2).join('_');
        
        console.log('Parsed navigation:', { tribeId, currentPage, castlistName, isNext });
        
        // Calculate new page
        const newPage = isNext ? currentPage + 1 : currentPage - 1;
        
        if (newPage < 0) {
          throw new Error('Cannot go to negative page');
        }
        
        // Send deferred response
        await res.send({
          type: InteractionResponseType.DEFERRED_UPDATE_MESSAGE
        });
        
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        
        // Fetch guild data
        const fullGuild = await client.guilds.fetch(guildId, { force: true });
        await fullGuild.roles.fetch();
        const members = await fullGuild.members.fetch();
        
        // Load tribe data
        const tribes = await getGuildTribes(guildId, castlistName);
        const targetTribe = tribes.find(tribe => tribe.roleId === tribeId);
        
        if (!targetTribe) {
          throw new Error('Tribe not found');
        }
        
        // Get tribe role and members
        const tribeRole = await fullGuild.roles.fetch(targetTribe.roleId);
        if (!tribeRole) {
          throw new Error('Tribe role not found');
        }
        
        const tribeMembers = members.filter(member => member.roles.cache.has(targetTribe.roleId));
        const sortedMembers = Array.from(tribeMembers.values())
          .sort((a, b) => a.displayName.localeCompare(b.displayName));
        
        // Validate new page
        const playersPerPage = 10;
        const totalPages = Math.ceil(sortedMembers.length / playersPerPage);
        
        if (newPage >= totalPages) {
          throw new Error('Page exceeds total pages');
        }
        
        // Get pronoun and timezone data
        const pronounRoleIds = await getGuildPronouns(guildId);
        const timezones = await getGuildTimezones(guildId);
        
        // Get players for the new page
        const startIndex = newPage * playersPerPage;
        const endIndex = Math.min(startIndex + playersPerPage, sortedMembers.length);
        const playersToShow = sortedMembers.slice(startIndex, endIndex);
        
        // Process member data for the new page
        const memberDataPromises = playersToShow.map(member => 
          processMemberData(member, pronounRoleIds, timezones, guildId)
        );
        const processedMembers = await Promise.all(memberDataPromises);
        
        // Create updated tribe section with Components V2
        const updatedTribeSection = await createTribeSection(
          { ...targetTribe, name: tribeRole.name },
          playersToShow,
          fullGuild,
          pronounRoleIds,
          timezones,
          newPage,
          playersPerPage
        );
        
        // Create updated navigation buttons
        const navRow = createNavigationButtons(targetTribe.roleId, newPage, totalPages, castlistName);
        
        // Get the original message components and update them
        const originalMessage = req.body.message;
        const originalComponents = originalMessage.components || [];
        let updatedComponents = [...originalComponents];
        
        // Find the tribe container to update (look for containers with matching tribe name)
        let tribeContainerIndex = -1;
        for (let i = 0; i < originalComponents.length; i++) {
          const component = originalComponents[i];
          if (component.type === 17) { // Container type
            // Check if this container has the tribe name in its header
            const headerComponent = component.components?.[0];
            if (headerComponent?.type === 10 && headerComponent.content?.includes(tribeRole.name)) {
              tribeContainerIndex = i;
              break;
            }
          }
        }
        
        if (tribeContainerIndex >= 0) {
          // Update the specific tribe container
          updatedComponents[tribeContainerIndex] = updatedTribeSection;
        }
        
        // Find and update the navigation row for this tribe
        let navRowIndex = -1;
        for (let i = 0; i < updatedComponents.length; i++) {
          const component = updatedComponents[i];
          if (component.type === 1 && component.components?.length > 0) { // Action Row
            const firstButton = component.components[0];
            if (firstButton.custom_id && 
                (firstButton.custom_id.includes(`castlist2_prev_${tribeId}_`) || 
                 firstButton.custom_id.includes(`castlist2_next_${tribeId}_`))) {
              navRowIndex = i;
              break;
            }
          }
        }
        
        if (navRowIndex >= 0) {
          // Update the existing navigation row
          updatedComponents[navRowIndex] = navRow.toJSON();
        } else {
          // Add new navigation row if not found
          updatedComponents.push(navRow.toJSON());
        }
        
        // Check permissions and apply ephemeral flag if user cannot send messages
        const member = req.body.member;
        const channelId = req.body.channel_id;
        let responseFlags = 1 << 15; // IS_COMPONENTS_V2 flag
        
        if (member && channelId) {
          const canSendMessages = await canSendMessagesInChannel(member, channelId, client);
          console.log(`Permission check: User ${member.user?.username} can send messages in channel ${channelId}: ${canSendMessages}`);
          
          if (!canSendMessages) {
            // Add ephemeral flag to response if user cannot send messages
            responseFlags = responseFlags | InteractionResponseFlags.EPHEMERAL;
            console.log(`Applied ephemeral flag - castlist visible only to user ${member.user?.username}`);
          }
        }

        // Update the message with Components V2 flag
        const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        await DiscordRequest(endpoint, {
          method: 'PATCH',
          body: {
            flags: responseFlags,
            components: updatedComponents
          },
        });
        
        console.log(`Successfully navigated to page ${newPage + 1} for tribe ${tribeRole.name}`);

      } catch (error) {
        console.error('Error handling castlist2 navigation:', error);
        
        try {
          const endpoint = `webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
          await DiscordRequest(endpoint, {
            method: 'PATCH',
            body: {
              content: `Error navigating castlist: ${error.message}`,
              flags: InteractionResponseFlags.EPHEMERAL
            },
          });
        } catch (updateError) {
          console.error('Error sending error response:', updateError);
        }
      }
    } else {
      // Fallback for unhandled button interactions
      console.log('üîç DEBUG: Unhandled MESSAGE_COMPONENT custom_id:', custom_id);
      console.log('üîç DEBUG: Interaction data:', JSON.stringify(data, null, 2));
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          content: `‚ùå Unknown button interaction: ${custom_id}`,
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });
    }
  } // end if MESSAGE_COMPONENT

  /**
   * Handle modal submissions
   */
  if (type === InteractionType.MODAL_SUBMIT) {
    const { custom_id, components } = data;
    console.log(`üîç DEBUG: MODAL_SUBMIT received - custom_id: ${custom_id}`);
    
    if (custom_id.startsWith('whisper_send_modal_')) {
      // Handle whisper modal submission
      // Format: whisper_send_modal_targetUserId_coordinate
      const parts = custom_id.split('_');
      const targetUserId = parts[3];
      const coordinate = parts.slice(4).join('_'); // Handle coordinates with underscores
      const message = components[0].components[0].value;
      const userId = req.body.member?.user?.id || req.body.user?.id;
      const guildId = req.body.guild_id;
      
      console.log(`üí¨ Whisper modal submitted - sender: ${userId}, target: ${targetUserId}, coord: ${coordinate}`);
      
      const { sendWhisper } = await import('./whisperManager.js');
      const result = await sendWhisper({
        userId,
        guildId,
        token: req.body.token
      }, targetUserId, coordinate, message, client);
      
      return res.send({
        type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
        data: result
      });

    } else if (custom_id.startsWith('modal_item_attr_edit_')) {
      // Phase 5: Edit existing item attribute modifier
      const guildId = req.body.guild_id;
      const parts = custom_id.replace('modal_item_attr_edit_', '').split('_');
      const modifierIndex = parseInt(parts.pop());
      const itemId = parts.join('_');

      // Extract form values
      const bonusValue = parseInt(components[0].components[0].value);
      let bonusOperation = components[1].components[0].value?.toLowerCase().trim();

      // Validate operation
      if (bonusOperation !== 'add' && bonusOperation !== 'addmax') {
        bonusOperation = 'add';
      }
      if (bonusOperation === 'addmax') bonusOperation = 'addMax';

      if (isNaN(bonusValue) || bonusValue < 0) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              components: [
                { type: 10, content: '‚ùå **Invalid bonus value.** Please enter a positive number.' },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back to Stats', style: 2 }] }
              ]
            }]
          }
        });
      }

      try {
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const item = safariData[guildId]?.items?.[itemId];

        if (!item || !item.attributeModifiers?.[modifierIndex]) {
          throw new Error('Item or modifier not found');
        }

        // Update the modifier
        item.attributeModifiers[modifierIndex].value = bonusValue;
        item.attributeModifiers[modifierIndex].operation = bonusOperation;
        await saveSafariContent(safariData);

        const attributeDefs = safariData[guildId]?.attributeDefinitions || {};
        const modifier = item.attributeModifiers[modifierIndex];
        const attrDef = attributeDefs[modifier.attributeId] || {};

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              accent_color: 0x57f287,
              components: [
                { type: 10, content: `‚úÖ **Updated ${attrDef.emoji || 'üìä'} ${attrDef.name || modifier.attributeId} bonus on ${item.name}**\n\nNew value: +${bonusValue}${bonusOperation === 'addMax' ? ' max' : ''}` },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back to Stats', style: 1 }] }
              ]
            }]
          }
        });
      } catch (error) {
        console.error('Error editing item attribute modifier:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              components: [
                { type: 10, content: `‚ùå **Error updating modifier:** ${error.message}` },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back to Stats', style: 2 }] }
              ]
            }]
          }
        });
      }

    } else if (custom_id.startsWith('modal_item_attr_')) {
      // Phase 5: Add new item attribute modifier
      const guildId = req.body.guild_id;
      // Parse: modal_item_attr_{itemId}_{attrId}
      const withoutPrefix = custom_id.replace('modal_item_attr_', '');
      const lastUnderscore = withoutPrefix.lastIndexOf('_');
      const itemId = withoutPrefix.substring(0, lastUnderscore);
      const attrId = withoutPrefix.substring(lastUnderscore + 1);

      // Extract form values
      const bonusValue = parseInt(components[0].components[0].value);
      let bonusOperation = components[1].components[0].value?.toLowerCase().trim();

      // Validate operation
      if (bonusOperation !== 'add' && bonusOperation !== 'addmax') {
        bonusOperation = 'add';
      }
      if (bonusOperation === 'addmax') bonusOperation = 'addMax';

      if (isNaN(bonusValue) || bonusValue < 0) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              components: [
                { type: 10, content: '‚ùå **Invalid bonus value.** Please enter a positive number.' },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back to Stats', style: 2 }] }
              ]
            }]
          }
        });
      }

      try {
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const item = safariData[guildId]?.items?.[itemId];
        const attributeDefs = safariData[guildId]?.attributeDefinitions || {};
        const attrDef = attributeDefs[attrId] || {};

        if (!item) {
          throw new Error('Item not found');
        }

        // Initialize modifiers array if needed
        if (!item.attributeModifiers) {
          item.attributeModifiers = [];
        }

        // Add the new modifier
        item.attributeModifiers.push({
          attributeId: attrId,
          value: bonusValue,
          operation: bonusOperation
        });

        await saveSafariContent(safariData);

        console.log(`üìä Added attribute modifier to item ${itemId}: +${bonusValue} ${bonusOperation} ${attrId}`);

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              accent_color: 0x57f287,
              components: [
                { type: 10, content: `‚úÖ **Added ${attrDef.emoji || 'üìä'} ${attrDef.name || attrId} bonus to ${item.name}**\n\nBonus: +${bonusValue}${bonusOperation === 'addMax' ? ' max' : ''}` },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back to Stats', style: 1 }] }
              ]
            }]
          }
        });
      } catch (error) {
        console.error('Error adding item attribute modifier:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              components: [
                { type: 10, content: `‚ùå **Error adding modifier:** ${error.message}` },
                { type: 14 },
                { type: 1, components: [{ type: 2, custom_id: `entity_field_group_item_${itemId}_stats`, label: '‚Üê Back to Stats', style: 2 }] }
              ]
            }]
          }
        });
      }

    } else if (custom_id === 'modal_attr_create') {
      // Handle attribute creation modal
      const guildId = req.body.guild_id;
      const userId = req.body.member?.user?.id;

      // Extract form values
      const getFieldValue = (fieldId) => {
        for (const row of components) {
          for (const comp of row.components) {
            if (comp.custom_id === fieldId) {
              return comp.value;
            }
          }
        }
        return null;
      };

      const attrName = getFieldValue('attr_name');
      const attrEmoji = getFieldValue('attr_emoji');
      const attrType = getFieldValue('attr_type')?.toLowerCase();
      const attrMaxValue = parseInt(getFieldValue('attr_max_value')) || 100;
      const attrRegenMinutes = parseInt(getFieldValue('attr_regen_minutes')) || 0;

      console.log(`üìä Creating attribute: ${attrName} (${attrType}) for guild ${guildId}`);

      // Validate type
      if (attrType !== 'resource' && attrType !== 'stat') {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              accent_color: 0xe74c3c,
              components: [
                { type: 10, content: '## ‚ùå Invalid Type' },
                { type: 14 },
                { type: 10, content: 'Type must be **resource** or **stat**.\n\n‚Ä¢ **Resource**: Has max value, can regenerate (like HP, Mana)\n‚Ä¢ **Stat**: Single value, no regeneration (like Strength, Luck)' },
                { type: 14 },
                {
                  type: 1,
                  components: [{
                    type: 2,
                    custom_id: 'attribute_management',
                    label: '‚Üê Try Again',
                    style: 2
                  }]
                }
              ]
            }]
          }
        });
      }

      try {
        const { createAttributeDefinition } = await import('./safariManager.js');
        const { ATTRIBUTE_CATEGORIES, REGENERATION_TYPES } = await import('./config/attributeDefaults.js');

        const attributeConfig = {
          name: attrName,
          emoji: attrEmoji,
          category: attrType === 'resource' ? ATTRIBUTE_CATEGORIES.RESOURCE : ATTRIBUTE_CATEGORIES.STAT
        };

        if (attrType === 'resource') {
          attributeConfig.defaultMax = attrMaxValue;
          attributeConfig.defaultCurrent = attrMaxValue;
          attributeConfig.regeneration = {
            type: attrRegenMinutes > 0 ? REGENERATION_TYPES.FULL_RESET : REGENERATION_TYPES.NONE,
            intervalMinutes: attrRegenMinutes || 60,
            amount: 'max'
          };
        } else {
          attributeConfig.defaultValue = attrMaxValue;
        }

        const created = await createAttributeDefinition(guildId, attributeConfig);

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              accent_color: 0x27ae60, // Green
              components: [
                { type: 10, content: '## ‚úÖ Attribute Created!' },
                { type: 14 },
                { type: 10, content: `**${created.emoji} ${created.name}** has been created!\n\n‚Ä¢ Type: ${created.category === 'resource' ? 'Resource' : 'Stat'}\n‚Ä¢ Default Value: ${created.defaultMax || created.defaultValue}${created.regeneration?.type !== 'none' ? `\n‚Ä¢ Regeneration: ${created.regeneration?.intervalMinutes} minutes` : ''}` },
                { type: 14 },
                {
                  type: 1,
                  components: [{
                    type: 2,
                    custom_id: 'attribute_management',
                    label: '‚Üê Back to Attributes',
                    style: 2
                  }]
                }
              ]
            }]
          }
        });
      } catch (error) {
        console.error(`‚ùå Failed to create attribute: ${error.message}`);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              accent_color: 0xe74c3c,
              components: [
                { type: 10, content: '## ‚ùå Creation Failed' },
                { type: 14 },
                { type: 10, content: `Error: ${error.message}` },
                { type: 14 },
                {
                  type: 1,
                  components: [{
                    type: 2,
                    custom_id: 'attribute_management',
                    label: '‚Üê Try Again',
                    style: 2
                  }]
                }
              ]
            }]
          }
        });
      }

    } else if (custom_id.startsWith('modal_admin_set_attr_')) {
      // Handle admin attribute modification modal
      // Format: modal_admin_set_attr_{playerId}_{attrId}
      const parts = custom_id.split('_');
      const playerId = parts[4];
      const attrId = parts.slice(5).join('_'); // Handle attribute IDs with underscores
      const guildId = req.body.guild_id;

      // Extract form values
      const getFieldValue = (fieldId) => {
        for (const row of components) {
          for (const comp of row.components) {
            if (comp.custom_id === fieldId) {
              return comp.value;
            }
          }
        }
        return null;
      };

      const newValue = parseInt(getFieldValue('attr_value'));
      const newMax = getFieldValue('attr_max') ? parseInt(getFieldValue('attr_max')) : null;

      if (isNaN(newValue)) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Invalid value - please enter a number',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      try {
        const { setPlayerAttribute, getAttributeDefinitions } = await import('./safariManager.js');
        const attributes = await getAttributeDefinitions(guildId);
        const attr = attributes[attrId];

        if (!attr) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Attribute not found',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Set the player's attribute value
        const result = await setPlayerAttribute(guildId, playerId, attrId, newValue, newMax);

        console.log(`üìä Admin set ${attr.name} for player ${playerId}: ${newValue}${newMax ? `/${newMax}` : ''}`);

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              accent_color: 0x27ae60, // Green
              components: [
                { type: 10, content: '## ‚úÖ Attribute Updated' },
                { type: 14 },
                { type: 10, content: `**${attr.emoji} ${attr.name}** for <@${playerId}> has been set to:\n\n‚Ä¢ Current: **${result.current}**${attr.category === 'resource' ? `\n‚Ä¢ Max: **${result.max}**` : ''}` },
                { type: 14 },
                {
                  type: 1,
                  components: [{
                    type: 2,
                    custom_id: 'admin_manage_player',
                    label: '‚Üê Back to Player Management',
                    style: 2
                  }]
                }
              ]
            }]
          }
        });
      } catch (error) {
        console.error(`‚ùå Failed to set attribute: ${error.message}`);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Failed to set attribute: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

    } else if (custom_id.startsWith('modal_modify_attr_amount_')) {
      // Handle modify attribute amount modal (Custom Action config)
      // Format: modal_modify_attr_amount_{buttonId}_{actionIndex}
      const parts = custom_id.replace('modal_modify_attr_amount_', '').split('_');
      const actionIndex = parseInt(parts[parts.length - 1]);
      const buttonId = parts.slice(0, -1).join('_');
      const guildId = req.body.guild_id;

      // Extract form values
      const getFieldValue = (fieldId) => {
        for (const row of components) {
          for (const comp of row.components) {
            if (comp.custom_id === fieldId) {
              return comp.value;
            }
          }
        }
        return null;
      };

      const newAmount = parseInt(getFieldValue('attr_amount'));

      if (isNaN(newAmount) || newAmount < 0) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Invalid amount - please enter a positive number',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      try {
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const button = safariData[guildId]?.buttons?.[buttonId];

        if (!button || !button.actions?.[actionIndex]) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action not found',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Ensure config exists
        if (!button.actions[actionIndex].config) {
          button.actions[actionIndex].config = {};
        }

        // Update the amount
        button.actions[actionIndex].config.amount = newAmount;

        // Save updated data
        await saveSafariContent(safariData);

        console.log(`üìä Updated modify_attribute amount for ${buttonId}[${actionIndex}]: ${newAmount}`);

        // Return updated configuration UI
        const { showModifyAttributeConfig } = await import('./customActionUI.js');
        const updatedConfig = await showModifyAttributeConfig(guildId, buttonId, actionIndex);

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: updatedConfig
        });
      } catch (error) {
        console.error(`‚ùå Failed to update amount: ${error.message}`);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Failed to update amount: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

    } else if (custom_id.startsWith('save_placement_')) {
      // Handle placement save from modal submission
      try {
        // üîß FIX: Parse full navigation context from modal custom_id
        // Format: save_placement_{userId}_{seasonContext}_{castlistId}_{tribeIndex}_{tribePage}_{displayMode}
        // CRITICAL: Both seasonContext AND castlistId can contain underscores!
        const parts = custom_id.split('_');

        // Work backwards from the end (these are always single parts)
        const displayMode = parts[parts.length - 1];
        const tribePage = parseInt(parts[parts.length - 2]);
        const tribeIndex = parseInt(parts[parts.length - 3]);

        // Find the castlist by looking for "castlist" pattern OR handle special IDs like "default"
        // Button format: edit_placement_{userId}_{seasonContext}_{castlistId}_{tribeIdx}_{tribePage}_{mode}
        let castlistIdStartIdx = -1;
        for (let i = parts.length - 4; i >= 3; i--) {
          if (parts[i] === 'castlist') {
            castlistIdStartIdx = i;
            break;
          }
        }

        // If no "castlist" found, assume single-part castlistId at fixed position
        // (for special IDs like "default", "active", etc.)
        if (castlistIdStartIdx === -1) {
          castlistIdStartIdx = parts.length - 4; // Position before tribeIdx/tribePage/mode
          console.log(`üîç [PLACEMENT] No 'castlist' keyword found, assuming single-part ID at index ${castlistIdStartIdx}`);
        }

        const playerId = parts[2];
        const seasonContext = parts.slice(3, castlistIdStartIdx).join('_') || 'global';
        const castlistIdShort = parts.slice(castlistIdStartIdx, parts.length - 3).join('_');

        const guildId = req.body.guild_id;

        // üîß FIX: Use parsed castlistId directly - entity IDs have format castlist_{timestamp}_{type}
        // DO NOT append guildId - that creates invalid IDs like castlist_123_974318870057848842
        // Correct format: castlist_1760892362223_system (type suffix, not guild ID)
        const castlistId = castlistIdShort;  // Use as-is from button parsing

        const channelId = req.body.channel_id;
        const member = req.body.member;
        const userId = member?.user?.id;

        console.log(`‚úèÔ∏è DEBUG: Placement modal submitted for player ${playerId} (namespace: ${seasonContext})`);
        console.log(`üìç DEBUG: Navigation context: castlist=${castlistId}, tribe=${tribeIndex}, page=${tribePage}, mode=${displayMode}`);

        // Extract value from Label (type 18) component structure
        const placementInput = components[0].component.value?.trim();

        // Validate: must be integer 1-99 or empty
        if (placementInput && !/^\d{1,2}$/.test(placementInput)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Please enter a whole number (1-99)',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Convert to integer for storage
        const placementValue = placementInput ? parseInt(placementInput, 10) : null;

        // Load and update player data
        const { loadPlayerData, savePlayerData } = await import('./storage.js');
        const playerData = await loadPlayerData();

        // üîß PHASE 1: Initialize structure for target namespace
        if (!playerData[guildId]) {
          playerData[guildId] = {};
        }
        if (!playerData[guildId].placements) {
          playerData[guildId].placements = {};
        }
        if (!playerData[guildId].placements[seasonContext]) {
          playerData[guildId].placements[seasonContext] = {};
        }

        // üîß PHASE 1: Save or delete placement to correct namespace
        if (placementValue !== null) {
          playerData[guildId].placements[seasonContext][playerId] = {
            placement: placementValue,
            updatedBy: userId,
            updatedAt: new Date().toISOString()
          };
          console.log(`‚úÖ Saved placement ${placementValue} to ${seasonContext} for player ${playerId}`);
        } else {
          delete playerData[guildId].placements[seasonContext][playerId];
          console.log(`üóëÔ∏è Deleted placement from ${seasonContext} for player ${playerId}`);
        }

        await savePlayerData(playerData);

        // Clear request cache to force fresh load of updated data
        const { clearRequestCache } = await import('./storage.js');
        clearRequestCache();

        console.log(`üîÑ Refreshing castlist with updated placement`);

        // üîß FIX: Rebuild castlist using FULL navigation context (Safari pattern)
        const { buildCastlist2ResponseData, createNavigationState } = await import('./castlistV2.js');

        // Fetch guild and rebuild tribes list (same as show_castlist2 handler)
        const guild = await client.guilds.fetch(guildId);

        // üîß SMART CACHING: Only fetch if cache is incomplete (CastlistArchitecture.md pattern)
        // Check if member cache is sufficiently populated (80% threshold)
        const cacheRatio = guild.members.cache.size / guild.memberCount;
        if (cacheRatio < 0.8) {
          console.log(`[PLACEMENT] Cache incomplete (${guild.members.cache.size}/${guild.memberCount}), fetching members...`);
          try {
            const fetchStart = Date.now();
            await guild.members.fetch({ timeout: 10000 }); // 10 second timeout
            const fetchTime = Date.now() - fetchStart;
            console.log(`[PLACEMENT] ‚úÖ Fetched ${guild.members.cache.size} members in ${fetchTime}ms`);
          } catch (fetchError) {
            console.warn(`[PLACEMENT] ‚ö†Ô∏è Member fetch failed after 10s: ${fetchError.message}`);
            console.warn(`[PLACEMENT] Continuing with partial cache (${guild.members.cache.size} members)`);
          }
        } else {
          console.log(`[PLACEMENT] Cache sufficiently populated (${guild.members.cache.size}/${guild.memberCount}), skipping fetch`);
        }

        // Load castlist configuration
        // NOTE: castlistEntity may be undefined for virtual castlists (like default before materialization)
        const castlistEntity = playerData[guildId]?.castlistConfigs?.[castlistId];
        const castlistName = castlistEntity?.name || (castlistId === 'default' ? 'Active Castlist' : castlistId);

        // Build tribes array matching the original display
        const allTribes = [];
        const tribes = playerData[guildId]?.tribes || {};

        // Validate tribes object for invalid keys
        const invalidKeys = Object.keys(tribes).filter(key => !/^\d{17,19}$/.test(key));
        if (invalidKeys.length > 0) {
          console.error(`‚ùå [EDIT PLACEMENT] Found ${invalidKeys.length} invalid keys in tribes object:`, invalidKeys);
        }

        for (const [roleId, tribe] of Object.entries(tribes)) {
          // Validate role ID is a Discord snowflake
          if (!/^\d{17,19}$/.test(roleId)) {
            console.warn(`‚ö†Ô∏è [EDIT PLACEMENT] Skipping invalid role ID: ${roleId}`);
            continue;
          }

          // Check legacy 'castlist', transitional 'castlistId', and current 'castlistIds' array
          const matchesCastlist = (
            tribe.castlist === castlistEntity?.name ||              // Legacy name matching
            tribe.castlistId === castlistId ||                      // Transitional ID matching
            (tribe.castlistIds && Array.isArray(tribe.castlistIds) &&
             tribe.castlistIds.includes(castlistId))                // CURRENT: Multi-castlist array
            // REMOVED: Default fallback that included ALL tribes with no castlist fields
          );

          if (matchesCastlist) {
            try {
              const role = await guild.roles.fetch(roleId);
              if (!role) {
                console.log(`‚ö†Ô∏è Role ${roleId} not found, skipping tribe`);
                continue;
              }

              const tribeMembers = Array.from(role.members.values());

              allTribes.push({
                ...tribe,
                roleId,
                name: role.name,
                members: tribeMembers,
                memberCount: tribeMembers.length,
                castlistSettings: {
                  ...castlistEntity?.settings,
                  seasonId: castlistEntity?.seasonId  // FIX: seasonId is at TOP LEVEL of entity, not in settings
                },
                castlistId: castlistId,  // FIX: Use castlistId not castlistName
                guildId: guildId
              });
            } catch (error) {
              console.error(`‚ùå Error fetching role ${roleId}:`, error.message);
              // Skip this tribe and continue with others
              continue;
            }
          }
        }

        // Safety check: ensure we have tribes
        if (allTribes.length === 0) {
          throw new Error('No valid tribes found for this castlist');
        }

        // Determine scenario (same logic as show_castlist2)
        const totalMembers = allTribes.reduce((sum, t) => sum + t.memberCount, 0);
        const maxTribeSize = Math.max(...allTribes.map(t => t.memberCount));
        let scenario = 'ideal';
        if (maxTribeSize >= 9) {
          scenario = 'multi-page';
        }

        // Safety check: tribe index might be out of bounds if tribes were deleted
        const safeTribeIndex = Math.min(tribeIndex, allTribes.length - 1);
        const safeTribePage = safeTribeIndex === tribeIndex ? tribePage : 0;

        console.log(`üìç Navigation safety check: requested tribe ${tribeIndex}, safe tribe ${safeTribeIndex}, allTribes count: ${allTribes.length}`);

        // Create navigation state pointing to a valid view
        const navigationState = createNavigationState(allTribes, scenario, safeTribeIndex, safeTribePage, guild, { playerData, guildId });

        // Build the response data with current navigation state
        // CRITICAL: Pass castlistId for button encoding, name for display
        const castlistResponse = await buildCastlist2ResponseData(
          guild,
          allTribes,
          castlistId,  // ID for button encoding
          navigationState,
          member,
          channelId,
          null,
          displayMode,
          castlistName,  // Display name (handles virtual castlists)
          { playerData, guildId }  // Pass playerData for sorting
        );

        // Return UPDATE_MESSAGE to refresh the castlist with updated placement
        // Modal submit interaction updates the message that contained the button that opened the modal
        console.log(`‚úÖ Placement modal: Sending UPDATE_MESSAGE with refreshed castlist UI`);
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: castlistResponse
        });

      } catch (error) {
        console.error('‚ùå Error in save_placement modal handler:', error);
        console.error('Stack trace:', error.stack);

        // Return UPDATE_MESSAGE with error content
        // This updates the castlist message to show the error
        const { sanitizeErrorMessage } = await import('./utils.js');
        const errorMessage = sanitizeErrorMessage(error);

        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            components: [{
              type: 17,  // Container
              components: [{
                type: 10,  // Text Display
                content: `‚ùå Error saving placement: ${errorMessage}`
              }]
            }]
          }
        });
      }

    // ‚úèÔ∏è Admin Tips Editor - Save modal handler
    } else if (custom_id.startsWith('save_tip_')) {
      // Permission check
      const userId = req.body.member?.user?.id || req.body.user?.id;
      if (userId !== '391415444084490240') {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå This feature is admin-only',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Parse tip index
      const tipIndex = parseInt(custom_id.replace('save_tip_', ''));

      // Extract values from modal (Label components type 18)
      const title = components[0].component.value?.trim();
      const description = components[1].component.value?.trim();
      const showcase = components[2].component.value?.trim();
      const imageUrl = components[3]?.component?.value?.trim() || '';

      // Validate required fields
      if (!title || !description || !showcase) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå All fields are required',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Validate image URL if provided
      if (imageUrl && !imageUrl.startsWith('https://cdn.discordapp.com/')) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Image URL must be a Discord CDN URL (https://cdn.discordapp.com/...)',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Load, update, and save tips config
      const { loadTipsConfig, saveTipsConfig, getCurrentEnvironment } = await import('./tipsGalleryManager.js');
      const config = await loadTipsConfig();
      const env = getCurrentEnvironment();

      if (!config.tips[tipIndex]) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Tip ${tipIndex + 1} not found`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Update tip data (preserve URLs and metadata)
      config.tips[tipIndex].title = title;
      config.tips[tipIndex].description = description;
      config.tips[tipIndex].showcase = showcase;

      // Update image URL for current environment if provided (empty = keep existing)
      if (imageUrl) {
        if (!config.tips[tipIndex].urls) {
          config.tips[tipIndex].urls = {};
        }
        config.tips[tipIndex].urls[env] = imageUrl;
        console.log(`üñºÔ∏è Updated ${env} URL for tip ${tipIndex + 1}`);
      }

      config.lastUpdated = new Date().toISOString();

      // Save to file
      await saveTipsConfig(config);

      console.log(`‚úÖ Updated tip ${tipIndex + 1} by admin ${userId}`);

      // Refresh display with updated tip
      const { createTipsDisplayUI } = await import('./tipsGalleryUIBuilder.js');
      const { getTipMetadata, getTipUrls } = await import('./tipsGalleryManager.js');

      const tipMetadata = getTipMetadata(config, tipIndex);
      const cdnUrls = getTipUrls(config, env);  // env already defined above

      const refreshedUI = createTipsDisplayUI(
        tipIndex,
        config.tips.length,
        tipMetadata,
        cdnUrls[tipIndex],
        'viral_menu',
        userId  // Pass userId for edit button rendering
      );

      return res.send({
        type: InteractionResponseType.UPDATE_MESSAGE,  // Type 7 - Direct update
        data: refreshedUI
      });

    } else if (custom_id.startsWith('condition_currency_modal_')) {
      // Handle currency amount modal submission
      try {
        // Parse custom_id: condition_currency_modal_actionId_conditionIndex_currentPage
        const customIdParts = custom_id.split('_');
        customIdParts.shift(); // Remove 'condition'
        customIdParts.shift(); // Remove 'currency'
        customIdParts.shift(); // Remove 'modal'
        const currentPage = parseInt(customIdParts.pop() || '0');
        const conditionIndex = parseInt(customIdParts.pop() || '0');
        const actionId = customIdParts.join('_');
        
        const amount = parseInt(components[0].components[0].value);
        
        if (isNaN(amount) || amount < 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Please enter a valid positive number.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Load and update condition
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const allSafariContent = await loadSafariContent();
        const condition = allSafariContent[req.body.guild_id]?.buttons?.[actionId]?.conditions?.[conditionIndex];
        
        if (!condition) {
          throw new Error('Condition not found');
        }
        
        // Update value
        condition.value = amount;
        
        // Save changes
        await saveSafariContent(allSafariContent);
        
        console.log(`‚úÖ SUCCESS: condition_currency_modal - set amount to ${amount}`);
        
        // Refresh condition editor
        const { showConditionEditor } = await import('./customActionUI.js');
        await showConditionEditor({
          res,
          actionId,
          conditionIndex,
          guildId: req.body.guild_id,
          currentPage
        });
        
      } catch (error) {
        console.error('Error in condition_currency_modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå An error occurred. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

    } else if (custom_id.startsWith('modal_condition_attr_value_')) {
      // Handle attribute condition value modal submission
      try {
        // Parse custom_id: modal_condition_attr_value_actionId_conditionIndex_currentPage
        const customIdParts = custom_id.split('_');
        customIdParts.shift(); // modal
        customIdParts.shift(); // condition
        customIdParts.shift(); // attr
        customIdParts.shift(); // value
        const currentPage = parseInt(customIdParts.pop() || '0');
        const conditionIndex = parseInt(customIdParts.pop() || '0');
        const actionId = customIdParts.join('_');

        const valueStr = components[0].components[0].value;
        const value = parseFloat(valueStr);

        if (isNaN(value) || value < 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Please enter a valid positive number.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Load and update condition
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const allSafariContent = await loadSafariContent();
        const condition = allSafariContent[req.body.guild_id]?.buttons?.[actionId]?.conditions?.[conditionIndex];

        if (!condition?.config) {
          throw new Error('Condition config not found');
        }

        // For percentage, cap at 100
        const isPercent = condition.config.target === 'percent';
        condition.config.value = isPercent ? Math.min(value, 100) : value;

        await saveSafariContent(allSafariContent);
        console.log(`‚úÖ SUCCESS: modal_condition_attr_value - set value to ${condition.config.value}`);

        // Refresh condition editor
        const { showConditionEditor } = await import('./customActionUI.js');
        await showConditionEditor({
          res,
          actionId,
          conditionIndex,
          guildId: req.body.guild_id,
          currentPage
        });

      } catch (error) {
        console.error('Error in modal_condition_attr_value handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå An error occurred. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

    } else if (custom_id.startsWith('modal_condition_multiattr_value_')) {
      // Handle multi-attribute condition value modal submission
      try {
        // Parse custom_id: modal_condition_multiattr_value_actionId_conditionIndex_currentPage
        const customIdParts = custom_id.split('_');
        customIdParts.shift(); // modal
        customIdParts.shift(); // condition
        customIdParts.shift(); // multiattr
        customIdParts.shift(); // value
        const currentPage = parseInt(customIdParts.pop() || '0');
        const conditionIndex = parseInt(customIdParts.pop() || '0');
        const actionId = customIdParts.join('_');

        const valueStr = components[0].components[0].value;
        const value = parseFloat(valueStr);

        if (isNaN(value) || value < 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Please enter a valid positive number.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Load and update condition
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const allSafariContent = await loadSafariContent();
        const condition = allSafariContent[req.body.guild_id]?.buttons?.[actionId]?.conditions?.[conditionIndex];

        if (!condition?.config) {
          throw new Error('Condition config not found');
        }

        condition.config.value = value;

        await saveSafariContent(allSafariContent);
        console.log(`‚úÖ SUCCESS: modal_condition_multiattr_value - set value to ${condition.config.value}`);

        // Refresh condition editor
        const { showConditionEditor } = await import('./customActionUI.js');
        await showConditionEditor({
          res,
          actionId,
          conditionIndex,
          guildId: req.body.guild_id,
          currentPage
        });

      } catch (error) {
        console.error('Error in modal_condition_multiattr_value handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå An error occurred. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

    } else if (custom_id === 'safari_button_modal') {
      // Handle Safari button creation modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const userId = member.user.id;

        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to create custom buttons.')) return;

        console.log('üìù DEBUG: Safari button modal submitted');
        
        const buttonLabel = components[0].components[0].value?.trim();
        const buttonEmojiInput = components[1].components[0].value?.trim() || null;
        const buttonDesc = components[2].components[0].value?.trim() || null;
        
        // Validate emoji using advanced parsing (for error checking only)
        let buttonEmoji = null;
        if (buttonEmojiInput) {
          const { createSafeEmoji } = await import('./safariButtonHelper.js');
          const validatedEmoji = await createSafeEmoji(buttonEmojiInput);
          if (validatedEmoji) {
            // Store the original input string - safariButtonHelper will process it later
            buttonEmoji = buttonEmojiInput;
            console.log(`‚úÖ Validated emoji input: "${buttonEmojiInput}"`);
          } else {
            console.warn(`‚ö†Ô∏è Invalid emoji input: "${buttonEmojiInput}", will be ignored`);
            buttonEmoji = null;
          }
        }
        
        if (!buttonLabel) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Button label is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Create basic button with no actions yet
        const { createCustomButton } = await import('./safariManager.js');
        const buttonId = await createCustomButton(guildId, {
          label: buttonLabel,
          emoji: buttonEmoji,
          style: 'Primary',
          actions: [],
          tags: buttonDesc ? [buttonDesc] : []
        }, userId);
        
        console.log(`‚úÖ DEBUG: Created button ${buttonId} successfully`);
        
        // Show action selection menu
        const actionMenu = {
          flags: (1 << 15), // IS_COMPONENTS_V2
          components: [{
            type: 17, // Container
            accent_color: 0xf39c12,
            components: [
              {
                type: 10, // Text Display
                content: `## üéâ Button Created: ${buttonLabel} ${buttonEmoji || ''}\n\nNow add actions to your button (up to 5):`
              },
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    custom_id: `safari_add_action_${buttonId}_display_text`,
                    label: 'Show Text',
                    style: 2, // Secondary (grey)
                    emoji: { name: 'üìÑ' }
                  },
                  {
                    type: 2, // Button
                    custom_id: `safari_add_action_${buttonId}_update_currency`,
                    label: 'Change Currency',
                    style: 2, // Secondary (grey)
                    emoji: { name: 'üí∞' }
                  },
                  {
                    type: 2, // Button
                    custom_id: `safari_add_action_${buttonId}_follow_up`,
                    label: 'Show Follow-Up Action',
                    style: 2, // Secondary (grey)
                    emoji: { name: 'üîó' }
                  },
                  {
                    type: 2, // Button
                    custom_id: `safari_add_action_${buttonId}_conditional`,
                    label: 'Add Conditional Action',
                    style: 2, // Secondary (grey)
                    emoji: { name: 'üîÄ' }
                  }
                ]
              },
              {
                type: 14 // Separator
              },
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    custom_id: `safari_finish_button_${buttonId}`,
                    label: 'Finish & Test Action',
                    style: 1, // Primary (blue)
                    emoji: { name: '‚ö°' }
                  },
                  {
                    type: 2, // Button
                    custom_id: 'prod_safari_menu',
                    label: 'Cancel',
                    style: 4,
                    emoji: { name: '‚ùå' }
                  }
                ]
              }
            ]
          }]
        };
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: actionMenu
        });
        
      } catch (error) {
        console.error('Error handling safari button modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error creating button. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    // Legacy handler removed - now using entity_create_modal_ factory pattern
    } else if (false && custom_id.startsWith('safari_button_modal_for_coord_')) {
      // Handle Safari button creation modal for specific coordinate
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const userId = member.user.id;
        
        // Extract coordinate from custom_id
        const coordinate = custom_id.replace('safari_button_modal_for_coord_', '');
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to create custom actions.')) return;

        console.log(`üìù DEBUG: Safari button modal submitted for coordinate ${coordinate}`);
        
        const buttonLabel = components[0].components[0].value?.trim();
        const buttonEmojiInput = components[1].components[0].value?.trim() || null;
        const buttonDesc = components[2].components[0].value?.trim() || null;
        
        // Validate emoji using advanced parsing (for error checking only)
        let buttonEmoji = null;
        if (buttonEmojiInput) {
          const { createSafeEmoji } = await import('./safariButtonHelper.js');
          const validatedEmoji = await createSafeEmoji(buttonEmojiInput);
          if (validatedEmoji) {
            // Store the original input string - safariButtonHelper will process it later
            buttonEmoji = buttonEmojiInput;
            console.log(`‚úÖ Validated emoji input: "${buttonEmojiInput}"`);
          } else {
            console.warn(`‚ö†Ô∏è Invalid emoji input: "${buttonEmojiInput}", will be ignored`);
            buttonEmoji = null;
          }
        }
        
        if (!buttonLabel) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action name is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Create basic button with no actions yet
        const { createCustomButton } = await import('./safariManager.js');
        const buttonId = await createCustomButton(guildId, {
          label: buttonLabel,
          emoji: buttonEmoji,
          style: 'Primary',
          actions: [],
          tags: buttonDesc ? [buttonDesc] : []
        }, userId);
        
        // Set name and description
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const allSafariContent = await loadSafariContent();
        const button = allSafariContent[guildId].buttons[buttonId];
        button.name = buttonLabel;
        button.description = buttonDesc || '';
        await saveSafariContent(allSafariContent);
        
        console.log(`‚úÖ DEBUG: Created button ${buttonId} with name and description`);
        
        // Show Custom Action Editor with the new button and pre-assigned coordinate
        const { createCustomActionEditorUI } = await import('./customActionUI.js');
        const ui = await createCustomActionEditorUI({
          guildId,
          actionId: buttonId,
          coordinate,
          skipAutoSave: true  // Skip auto-save during creation to avoid errors
        });
        
        // Now save the coordinate assignment manually
        const updatedSafariContent = await loadSafariContent();
        await saveSafariContent(updatedSafariContent);
        
        // Add a note about the coordinate assignment
        if (ui.components && ui.components[0] && ui.components[0].components) {
          // Find the header component and append note
          const headerComponent = ui.components[0].components.find(c => c.type === 10);
          if (headerComponent) {
            headerComponent.content += `\n\n‚úÖ **Auto-assigned to location ${coordinate}**`;
          }
        }
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            ...ui,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error creating custom action:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error creating custom action. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_currency_modal_') && custom_id.split('_').length > 4) {
      // Handle currency amount modal for give_currency action (format: safari_currency_modal_buttonId_actionIndex)
      try {
        const parts = custom_id.replace('safari_currency_modal_', '').split('_');
        const actionIndex = parseInt(parts[parts.length - 1]);
        const buttonId = parts.slice(0, -1).join('_');
        
        console.log(`üí∞ MODAL: safari_currency_modal - processing amount for ${buttonId}[${actionIndex}]`);
        
        // Get amount from modal
        const amount = parseInt(components[0].components[0].value);
        
        if (isNaN(amount) || amount < -999999 || amount > 999999) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Please enter a valid number between -999999 and 999999 (0 to remove this action).',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Store in temporary state
        const stateKey = `${req.body.guild_id}_${buttonId}_currency_${actionIndex}`;
        const state = dropConfigState.get(stateKey) || { limit: null, style: null, amount: null, executeOn: 'true' };
        state.amount = amount;
        dropConfigState.set(stateKey, state);
        
        // Show updated configuration UI with amount
        const { getCustomTerms } = await import('./safariManager.js');
        const customTerms = await getCustomTerms(req.body.guild_id);
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: await showGiveCurrencyConfig(req.body.guild_id, buttonId, actionIndex, customTerms)
        });
        
      } catch (error) {
        console.error('Error processing currency modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error processing currency amount.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_action_modal_')) {
      // Handle Safari action modal submissions
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to add actions.')) return;

        // Parse action type and button ID from custom_id
        // Format: safari_action_modal_{buttonId}_{actionType}
        let actionType, buttonId;
        
        if (custom_id.endsWith('_display_text')) {
          actionType = 'display_text';
          // Remove prefix and suffix to get button ID
          buttonId = custom_id.replace('safari_action_modal_', '').replace('_display_text', '');
        } else if (custom_id.endsWith('_update_currency')) {
          actionType = 'update_currency';
          buttonId = custom_id.replace('safari_action_modal_', '').replace('_update_currency', '');
        } else if (custom_id.endsWith('_follow_up_button')) {
          actionType = 'follow_up_button';
          buttonId = custom_id.replace('safari_action_modal_', '').replace('_follow_up_button', '');
        } else if (custom_id.endsWith('_conditional')) {
          actionType = 'conditional';
          buttonId = custom_id.replace('safari_action_modal_', '').replace('_conditional', '');
        } else if (custom_id.endsWith('_give_currency')) {
          actionType = 'give_currency';
          buttonId = custom_id.replace('safari_action_modal_', '').replace('_give_currency', '');
        } else if (custom_id.endsWith('_give_item')) {
          actionType = 'give_item';
          buttonId = custom_id.replace('safari_action_modal_', '').replace('_give_item', '');
        } else {
          // Fallback - should not happen with properly formatted custom_ids
          console.error(`‚ö†Ô∏è WARNING: Unknown action type in custom_id: ${custom_id}`);
          const parts = custom_id.split('_');
          actionType = parts[parts.length - 1];
          buttonId = parts.slice(3, parts.length - 1).join('_');
        }
        
        console.log(`üîß DEBUG: Processing ${actionType} action for button ${buttonId}`);
        
        // Import safari manager to update the button
        const { getCustomButton } = await import('./safariManager.js');
        const { SAFARI_LIMITS } = await import('./config/safariLimits.js');
        const button = await getCustomButton(guildId, buttonId);
        
        if (!button) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Button not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        let actionConfig = {};
        let executeOn = 'true'; // Default to true for backwards compatibility
        
        // Get components from modal submission
        const components = req.body.data.components;
        
        if (actionType === 'display_text') {
          const title = components[0].components[0].value?.trim() || null;
          const content = components[1].components[0].value?.trim();
          const executeOnStr = components[2].components[0].value?.trim() || 'true';
          const colorStr = components[3].components[0].value?.trim();
          const imageUrl = components[4].components[0].value?.trim() || null;
          
          // Parse executeOn value - accept true/TRUE/1 for true, false/FALSE/0 for false
          executeOn = (['true', 'TRUE', '1'].includes(executeOnStr)) ? 'true' : 
                     (['false', 'FALSE', '0'].includes(executeOnStr)) ? 'false' : 'true';
          
          if (!content) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Content is required for text display actions.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          actionConfig = {
            title: title,
            content: content
          };
          
          // Add imageUrl if provided
          if (imageUrl) {
            actionConfig.imageUrl = imageUrl;
          }
          
          // Parse color if provided, or set default green
          if (colorStr) {
            let accentColor = null;
            if (colorStr.startsWith('#')) {
              accentColor = parseInt(colorStr.slice(1), 16);
            } else if (/^[0-9a-fA-F]{6}$/.test(colorStr)) {
              accentColor = parseInt(colorStr, 16);
            } else if (/^\d+$/.test(colorStr)) {
              accentColor = parseInt(colorStr);
            }
            if (accentColor !== null && !isNaN(accentColor) && accentColor >= 0 && accentColor <= 0xFFFFFF) {
              actionConfig.accentColor = accentColor;
            }
          } else {
            // Set default green accent color
            actionConfig.accentColor = 0x57F287; // Nice green color
          }
          
        } else if (actionType === 'update_currency') {
          const amountStr = components[0].components[0].value?.trim();
          const message = components[1].components[0].value?.trim();
          
          const amount = parseInt(amountStr);
          if (isNaN(amount)) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Currency amount must be a valid number.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          if (!message) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Message is required for currency actions.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          actionConfig = {
            amount: amount,
            message: message
          };
        } else if (actionType === 'follow_up_button') {
          const buttonId = components[0].components[0].value?.trim();
          
          if (!buttonId) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Target Button ID is required for follow-up actions.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          // Validate that the target button exists
          const { getCustomButton } = await import('./safariManager.js');
          const targetButton = await getCustomButton(guildId, buttonId);
          
          if (!targetButton) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå Target button "${buttonId}" not found. Please check the Button ID and try again.`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          // Set default values for delay and replace message
          const delay = 0; // Default: no delay
          const replaceMessage = false; // Default: don't replace message
          
          actionConfig = {
            buttonId: buttonId,
            delay: delay,
            replaceMessage: replaceMessage
          };
        } else if (actionType === 'conditional') {
          const conditionType = components[0].components[0].value?.trim();
          const conditionValue = components[1].components[0].value?.trim();
          const successAction = components[2].components[0].value?.trim();
          const failureAction = components[3].components[0].value?.trim() || null;
          
          if (!conditionType || !conditionValue || !successAction) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Condition type, value, and success action are required for conditional actions.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          // Validate condition type
          const validConditionTypes = ['currency_gte', 'currency_lte', 'has_item', 'not_has_item', 'button_used', 'cooldown_expired'];
          if (!validConditionTypes.includes(conditionType)) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå Invalid condition type. Valid types: ${validConditionTypes.join(', ')}`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          // Validate action types
          const validActionTypes = ['display_text', 'update_currency', 'follow_up_button'];
          if (!validActionTypes.includes(successAction)) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå Invalid success action type. Valid types: ${validActionTypes.join(', ')}`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          if (failureAction && !validActionTypes.includes(failureAction)) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå Invalid failure action type. Valid types: ${validActionTypes.join(', ')}`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          actionConfig = {
            conditionType: conditionType,
            conditionValue: conditionValue,
            successAction: successAction,
            failureAction: failureAction
          };
        } else if (actionType === 'give_currency') {
          const amountStr = components[0].components[0].value?.trim();
          const message = components[1].components[0].value?.trim() || null;
          
          const amount = parseInt(amountStr);
          if (isNaN(amount) || amount <= 0) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Currency amount must be a positive number.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          actionConfig = {
            amount: amount,
            message: message,
            limit: {
              type: 'unlimited' // Default to unlimited, will be configured later
            }
          };
        } else if (actionType === 'give_item') {
          const itemId = components[0].components[0].value?.trim();
          const quantityStr = components[1].components[0].value?.trim();
          
          if (!itemId) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Item ID is required.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          const quantity = parseInt(quantityStr);
          if (isNaN(quantity) || quantity <= 0) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Quantity must be a positive number.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          // TODO: Validate item exists when we have item system
          
          actionConfig = {
            itemId: itemId,
            quantity: quantity,
            limit: {
              type: 'unlimited' // Default to unlimited, will be configured later
            }
          };
        }
        
        // Add action to button
        const newAction = {
          type: actionType,
          order: button.actions.length + 1,
          config: actionConfig,
          executeOn: executeOn // Add executeOn property
        };
        
        button.actions.push(newAction);
        
        // Save updated button
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        safariData[guildId].buttons[buttonId] = button;
        await saveSafariContent(safariData);
        
        console.log(`‚úÖ DEBUG: Added ${actionType} action to button ${buttonId}`);
        
        // For give_currency and give_item, show configuration UI instead of finishing
        if (actionType === 'give_currency' || actionType === 'give_item') {
            const actionIndex = button.actions.length - 1; // The action we just added
            
            // Show drop configuration UI
            return res.send({
                type: InteractionResponseType.UPDATE_MESSAGE,
                data: {
                    components: [{
                        type: 17, // Container
                        components: [
                            {
                                type: 10, // Text Display
                                content: `# Configure ${actionType === 'give_currency' ? 'Currency' : 'Item'} Drop\n\n**Action:** ${button.name || buttonId}\n\n*Configure usage limits and button appearance.*`
                            },
                            { type: 14 }, // Separator
                            // Usage limit configuration
                            {
                                type: 9, // Section
                                components: [{
                                    type: 10,
                                    content: `**Usage Limit:** ${newAction.config.limit?.type === 'once_per_player' ? 'Once per player' : newAction.config.limit?.type === 'once_globally' ? 'Once globally' : 'Unlimited'}`
                                }],
                                accessory: {
                                    type: 2, // Button
                                    custom_id: `safari_drop_type_${buttonId}_${actionIndex}`,
                                    label: 'Change',
                                    style: 2, // Secondary
                                    emoji: { name: 'üîÑ' }
                                }
                            },
                            // Button style configuration (for button triggers)
                            {
                                type: 9, // Section
                                components: [{
                                    type: 10,
                                    content: `**Button Style:** ${getButtonStyleName(button.style || 1)}`
                                }],
                                accessory: {
                                    type: 2, // Button
                                    custom_id: `safari_drop_style_${buttonId}_${actionIndex}`,
                                    label: 'Change',
                                    style: 2,
                                    emoji: { name: 'üé®' }
                                }
                            },
                            { type: 14 }, // Separator
                            // Action buttons
                            {
                                type: 1, // Action Row
                                components: [
                                    {
                                        type: 2, // Button
                                        custom_id: `safari_drop_reset_${buttonId}_${actionIndex}`,
                                        label: 'Reset Claims',
                                        style: 2, // Secondary (grey)
                                        emoji: { name: 'üîÑ' }
                                    },
                                    {
                                        type: 2, // Button
                                        custom_id: `safari_remove_action_${buttonId}_${actionIndex}`,
                                        label: 'Delete Action',
                                        style: 4, // Danger (red)
                                        emoji: { name: 'üóëÔ∏è' }
                                    },
                                    {
                                        type: 2, // Button
                                        custom_id: `safari_drop_save_${buttonId}_${actionIndex}`,
                                        label: 'Save & Finish',
                                        style: 3, // Success
                                        emoji: { name: '‚úÖ' }
                                    }
                                ]
                            }
                        ]
                    }],
                    flags: (1 << 15) // IS_COMPONENTS_V2
                }
            });
        }
        
        // Execute finish button tasks automatically after modal submission
        // Update map coordinate assignments - COMPLETE BIDIRECTIONAL SYNC
        if (safariData[guildId].maps) {
          for (const mapId in safariData[guildId].maps) {
            const map = safariData[guildId].maps[mapId];
            if (map.coordinates) {
              for (const coord in map.coordinates) {
                const coordData = map.coordinates[coord];
                if (coordData.buttons) {
                  coordData.buttons = coordData.buttons.filter(id => id !== buttonId);
                }
              }
            }
          }
        }

        // Add action to assigned coordinates
        if (button.coordinates && button.coordinates.length > 0) {
          // Ensure maps structure exists
          if (!safariData[guildId].maps) safariData[guildId].maps = {};
          
          // Find all maps and add coordinate assignments
          for (const mapId in safariData[guildId].maps) {
            if (mapId === 'active' || typeof safariData[guildId].maps[mapId] !== 'object') continue;
            
            const map = safariData[guildId].maps[mapId];
            if (!map.coordinates) map.coordinates = {};
            
            for (const coord of button.coordinates) {
              if (!map.coordinates[coord]) {
                map.coordinates[coord] = { buttons: [] };
              }
              
              if (!map.coordinates[coord].buttons.includes(buttonId)) {
                map.coordinates[coord].buttons.push(buttonId);
              }
            }
          }
        }

        await saveSafariContent(safariData);

        // Send immediate response to avoid timeout
        const { createCustomActionEditorUI } = await import('./customActionUI.js');
        const updatedUI = await createCustomActionEditorUI({
          guildId,
          actionId: buttonId
        });
        
        console.log(`‚úÖ DEBUG: Sending Custom Action Editor update for button ${buttonId}`);
        res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: updatedUI
        });
        
        // Update anchor messages asynchronously after response is sent
        if (button.coordinates && button.coordinates.length > 0) {
          setImmediate(async () => {
            try {
              const { updateAnchorMessage } = await import('./mapCellUpdater.js');
              const activeMapId = safariData[guildId]?.maps?.active;
              
              for (const coord of button.coordinates) {
                const coordData = safariData[guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
                if (coordData?.anchorMessageId) {
                  try {
                    await updateAnchorMessage(guildId, coord, client);
                    console.log(`üìç Updated anchor message for ${coord}`);
                  } catch (error) {
                    console.error(`Error updating anchor for ${coord}:`, error);
                  }
                }
              }
            } catch (error) {
              console.error('Error in async anchor updates:', error);
            }
          });
        }
        
        return;
        
      } catch (error) {
        console.error('Error processing action modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error adding action. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('prod_add_tribe_modal_')) {
      // Handle Add Tribe final submission
      try {
        const parts = custom_id.split('_');
        const roleId = parts[4]; // prod_add_tribe_modal_{roleId}_{castlist}
        const selectedCastlist = parts.slice(5).join('_'); // Handle multi-word castlist names
        
        const emojiValue = components[0].components[0].value?.trim() || null;
        let customCastlistName = null;
        
        // Check if custom castlist name was provided
        if (components[1]?.components[0]?.value) {
          customCastlistName = components[1].components[0].value.trim();
        }
        
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        const role = guild.roles.cache.get(roleId);
        
        if (!role) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: 'Error: Selected role not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Determine final castlist name
        let finalCastlist = selectedCastlist;
        if (selectedCastlist === 'new_custom' && customCastlistName) {
          finalCastlist = customCastlistName; // Preserve capitalization and spaces like /add_tribe command
        }

        // Removed alumni_placements processing - using centralized placement system instead
        
        // Load player data and check for conflicts
        const playerData = await loadPlayerData();
        if (!playerData[guildId]) playerData[guildId] = {};
        if (!playerData[guildId].tribes) playerData[guildId].tribes = {};
        
        // Check if tribe already exists in a different castlist
        const existingTribe = playerData[guildId].tribes[roleId];
        if (existingTribe && existingTribe.castlist !== finalCastlist) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚ùå Tribe not added - this tribe already exists in ${existingTribe.castlist}. You can only have each tribe in one castlist.`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Get role color
        const roleColor = role.hexColor && role.hexColor !== '#000000' ? role.hexColor : null;
        
        // Add analytics name
        let analyticsName = null;
        try {
          const emoji = emojiValue || '';
          analyticsName = emoji ? `${emoji} ${role.name} ${emoji}` : role.name;
        } catch (error) {
          console.debug(`Could not set analytics name for role: ${roleId}`);
        }
        
        // Update tribe data (replicating add_tribe logic but without player emoji generation)
        const tribeData = {
          emoji: emojiValue,
          castlist: finalCastlist,
          showPlayerEmojis: false, // Always false per new specification
          color: roleColor,
          analyticsName,
          analyticsAdded: Date.now()
        };
        
        // Removed alumni_placements specific fields - using centralized placement system
        
        playerData[guildId].tribes[roleId] = tribeData;
        
        // Save data
        await savePlayerData(playerData);
        
        const emojiDisplay = emojiValue ? ` with emoji ${emojiValue}` : '';
        const castlistDisplay = finalCastlist === 'default' ? 'default castlist' : `"${finalCastlist}" castlist`;
        
        // Build success message content
        let successContent = `**${role.name}** has been added to the ${castlistDisplay}${emojiDisplay}.\n\n`;
        successContent += `Players can now view this tribe in the castlist once members are assigned to the role.`;
        
        // Create ComponentsV2 container for success message
        const successContainer = {
          type: 17, // Container (MANDATORY for ComponentsV2)
          accent_color: 0x2ECC71, // Green accent for success
          components: [
            {
              type: 10, // Text Display
              content: `## ‚úÖ CastBot | Tribe Added Successfully`
            },
            {
              type: 14 // Separator
            },
            {
              type: 10, // Text Display
              content: successContent
            }
          ]
        };
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
            components: [successContainer]
          }
        });
        
      } catch (error) {
        console.error('Error handling add tribe modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error adding tribe. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'tribe_swap_merge_modal') {
      // Handle tribe swap/merge modal submission
      try {
        const guildId = req.body.guild_id;
        const channelId = req.body.channel_id;
        const userId = req.body.member.user.id;
        const components = req.body.data.components;

        console.log(`üîÄ [TRIBE SWAP] Processing swap/merge modal for guild ${guildId}`);

        // Helper function to extract values from modal components (handles Label type 18)
        const getFieldValue = (customId) => {
          if (!components || !Array.isArray(components)) {
            return null;
          }

          for (const row of components) {
            // Handle Label (type 18) wrapper
            if (row?.type === 18 && row?.component) {
              if (row.component.custom_id === customId) {
                return row.component.value || row.component.values || null;
              }
            }
            // Handle ActionRow format (legacy)
            else if (row?.components && Array.isArray(row.components)) {
              const field = row.components.find(c => c?.custom_id === customId);
              if (field) return field.value || field.values || null;
            }
          }
          return null;
        };

        // Extract modal values
        const archiveName = getFieldValue('archive_name');
        const vanityRoles = getFieldValue('vanity_roles')?.[0] || 'no';
        const autoRandomize = getFieldValue('auto_randomize')?.[0] || 'no';
        const oddPlayerBehaviour = getFieldValue('odd_player_behaviour')?.[0] || 'manual';

        // Extract new tribe role IDs from resolved roles
        const newTribeRoleIds = Object.keys(req.body.data.resolved?.roles || {});

        console.log(`üîÄ [TRIBE SWAP] Config:`, {
          archiveName,
          newTribeCount: newTribeRoleIds.length,
          vanityRoles,
          autoRandomize,
          oddPlayerBehaviour
        });

        // Validation
        if (!archiveName || archiveName.trim().length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
              components: [{
                type: 17,
                components: [{
                  type: 10,
                  content: '‚ùå Archive castlist name is required'
                }]
              }]
            }
          });
        }

        if (newTribeRoleIds.length < 1) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
              components: [{
                type: 17,
                components: [{
                  type: 10,
                  content: '‚ùå Please select at least 1 new tribe role'
                }]
              }]
            }
          });
        }

        // Get current default castlist tribes
        const playerData = await loadPlayerData();
        const tribes = playerData[guildId]?.tribes || {};
        const currentDefaultTribes = [];

        for (const [roleId, tribeData] of Object.entries(tribes)) {
          if (!tribeData) continue;

          // Check if tribe is on default castlist
          const isOnDefault = tribeData.castlistId === 'default' ||
                             tribeData.castlist === 'default' ||
                             (Array.isArray(tribeData.castlistIds) && tribeData.castlistIds.includes('default'));

          if (isOnDefault) {
            currentDefaultTribes.push({ roleId, ...tribeData });
          }
        }

        if (currentDefaultTribes.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
              components: [{
                type: 17,
                components: [{
                  type: 10,
                  content: '‚ùå No tribes found on default castlist'
                }]
              }]
            }
          });
        }

        console.log(`üîÄ [TRIBE SWAP] Found ${currentDefaultTribes.length} current tribes on default castlist`);

        // Count players in current tribes
        const guild = await client.guilds.fetch(guildId);
        await guild.members.list({ limit: 1000 }); // Ensure all members loaded (REST API)

        const allPlayers = new Set();
        for (const tribe of currentDefaultTribes) {
          const role = guild.roles.cache.get(tribe.roleId);
          if (role) {
            role.members.forEach(member => allPlayers.add(member));
          }
        }

        const playerArray = Array.from(allPlayers);

        if (playerArray.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL,
              components: [{
                type: 17,
                components: [{
                  type: 10,
                  content: '‚ùå No players found in current tribes'
                }]
              }]
            }
          });
        }

        console.log(`üîÄ [TRIBE SWAP] Found ${playerArray.length} players in current tribes`);

        // Send deferred response (this will take time)
        await res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE
        });

        // Helper: Shuffle array (Fisher-Yates)
        const shuffleArray = (array) => {
          const shuffled = [...array];
          for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
          }
          return shuffled;
        };

        // Helper: Delay function
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));

        // Perform auto-randomization if requested
        const assignments = {};
        newTribeRoleIds.forEach(id => assignments[id] = []);

        if (autoRandomize === 'yes') {
          const shuffled = shuffleArray(playerArray);

          // Calculate how many players to assign
          const basePerTribe = Math.floor(shuffled.length / newTribeRoleIds.length);
          const totalToAssign = oddPlayerBehaviour === 'manual'
            ? basePerTribe * newTribeRoleIds.length
            : shuffled.length;

          const playersToAssign = shuffled.slice(0, totalToAssign);
          const unassignedPlayers = shuffled.slice(totalToAssign);

          console.log(`üîÄ [TRIBE SWAP] Starting dramatic reveal for ${playersToAssign.length} players`);

          // Helper: Send message via REST API (channel.send doesn't support raw Components V2)
          const sendMessage = async (messageData) => {
            const response = await fetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
              method: 'POST',
              headers: {
                'Authorization': `Bot ${process.env.DISCORD_TOKEN}`,
                'Content-Type': 'application/json'
              },
              body: JSON.stringify(messageData)
            });

            if (!response.ok) {
              const error = await response.text();
              console.error(`üîÄ [TRIBE SWAP] Failed to send message:`, error);
              throw new Error(`Failed to send message: ${error}`);
            }

            return await response.json();
          };

          // Opening ceremony
          await sendMessage({
            flags: (1 << 15),
            components: [{
              type: 17,
              accent_color: 0xFF6B6B,
              components: [{
                type: 10,
                content: '# üé≠ Drop your buffs!\n\n*The moment you\'ve all been waiting for...*'
              }]
            }]
          });

          await delay(15000);

          // Helper: Format remaining players list with truncation
          const formatRemainingPlayers = (remainingPlayers) => {
            if (remainingPlayers.length === 0) {
              return '-# All players have been swapped! üéâ';
            }

            // Group remaining players by their original tribe (with role ID)
            const playersByTribe = {};

            for (const player of remainingPlayers) {
              const displayName = player.displayName || player.user.username;

              // Find player's original tribe
              let tribeKey = 'Unknown';
              let tribeRoleId = null;
              for (const oldTribe of currentDefaultTribes) {
                const oldRole = guild.roles.cache.get(oldTribe.roleId);
                if (oldRole && oldRole.members.has(player.id)) {
                  tribeKey = oldTribe.roleId;
                  tribeRoleId = oldTribe.roleId;
                  break;
                }
              }

              if (!playersByTribe[tribeKey]) {
                playersByTribe[tribeKey] = {
                  roleId: tribeRoleId,
                  players: []
                };
              }
              playersByTribe[tribeKey].players.push(displayName);
            }

            // Format the output with small font and role mentions
            let content = '-# Players remaining to be swapped:\n';
            const tribeParts = [];

            for (const [tribeKey, tribeData] of Object.entries(playersByTribe)) {
              const playerList = tribeData.players.join(', ');
              const roleMention = tribeData.roleId ? `<@&${tribeData.roleId}>` : 'Unknown';
              tribeParts.push(`-# ${roleMention}: ${playerList}`);
            }

            let fullContent = content + tribeParts.join('\n');

            // Truncate at 1800 characters if needed
            if (fullContent.length > 1800) {
              // Find the last complete player name before 1800 chars
              const truncated = fullContent.substring(0, 1797); // Leave room for "..."
              const lastComma = truncated.lastIndexOf(',');
              const lastNewline = truncated.lastIndexOf('\n');
              const cutPoint = Math.max(lastComma, lastNewline);

              if (cutPoint > 0) {
                fullContent = truncated.substring(0, cutPoint) + '...';
              } else {
                fullContent = truncated + '...';
              }
            }

            return fullContent;
          };

          // Round-robin reveal
          let currentTribeIndex = 0;
          let playerCount = 0;

          for (const player of playersToAssign) {
            playerCount++;
            const tribeRoleId = newTribeRoleIds[currentTribeIndex];
            const tribeRole = guild.roles.cache.get(tribeRoleId);
            const avatarUrl = player.user.displayAvatarURL({ size: 128 });
            const displayName = player.displayName || player.user.username;

            // Find player's old tribe (save both name AND role ID)
            let oldTribeName = 'Unknown';
            let oldTribeRoleId = null;
            for (const oldTribe of currentDefaultTribes) {
              const oldRole = guild.roles.cache.get(oldTribe.roleId);
              if (oldRole && oldRole.members.has(player.id)) {
                oldTribeName = oldRole.name;
                oldTribeRoleId = oldTribe.roleId;
                break;
              }
            }

            console.log(`üîÄ [TRIBE SWAP] ${playerCount}/${playersToAssign.length}: ${displayName} swapped from ${oldTribeName} ‚Üí ${tribeRole.name}`);

            // Calculate remaining players for this reveal (include unassigned for dramatic effect)
            const remainingToReveal = playersToAssign.slice(playerCount);
            const remainingPlayers = [...remainingToReveal, ...unassignedPlayers];
            const remainingPlayersText = formatRemainingPlayers(remainingPlayers);

            // Determine next reveal timing message
            const isLastReveal = playerCount === playersToAssign.length;
            const nextRevealText = isLastReveal
              ? '-# Swap/merge summary in 15 seconds'
              : '-# Next player in... 15 seconds';

            // Enhanced dramatic reveal with progress, dividers, and remaining players
            await sendMessage({
              flags: (1 << 15),
              components: [{
                type: 17,
                accent_color: tribeRole.color || 0x5865F2,
                components: [
                  {
                    type: 10, // Text Display - progress indicator (small font, includes unassigned in total)
                    content: `-# Swap Progress: Player ${playerCount} of ${shuffled.length}`
                  },
                  {
                    type: 14, // Separator
                    divider: true
                  },
                  {
                    type: 10, // Text Display - formal swap message (with role/user mentions)
                    content: oldTribeRoleId
                      ? `<@${player.id}> swaps from <@&${oldTribeRoleId}> into <@&${tribeRoleId}>`
                      : `<@${player.id}> joins <@&${tribeRoleId}>`
                  },
                  {
                    type: 9, // Section - dramatic reveal (with blockquote formatting)
                    components: [{
                      type: 10,
                      content: `> # ${tribeRole.name.toUpperCase()}\n\n## ${displayName}!`
                    }],
                    accessory: {
                      type: 11, // Thumbnail
                      media: { url: avatarUrl }
                    }
                  },
                  {
                    type: 14, // Separator
                    divider: true
                  },
                  {
                    type: 10, // Text Display - remaining players
                    content: remainingPlayersText
                  },
                  {
                    type: 10, // Text Display - next reveal countdown
                    content: nextRevealText
                  }
                ]
              }]
            });

            // Assign role
            try {
              await player.roles.add(tribeRoleId, 'Tribe Swap');
              assignments[tribeRoleId].push(player.id);
            } catch (error) {
              console.error(`üîÄ [TRIBE SWAP] Failed to assign role to ${player.user.username}:`, error);
            }

            await delay(15000);

            // Next tribe (round-robin)
            currentTribeIndex = (currentTribeIndex + 1) % newTribeRoleIds.length;
          }

          console.log(`üîÄ [TRIBE SWAP] Dramatic reveal complete - assigned ${playerCount} players`);

          // Handle unassigned players
          if (unassignedPlayers.length > 0) {
            console.log(`üîÄ [TRIBE SWAP] ${unassignedPlayers.length} players require manual assignment`);

            // Format player mentions for dramatic message
            const playerMentions = unassignedPlayers.map(p => `<@${p.id}>`).join(', ');

            await sendMessage({
              flags: (1 << 15),
              components: [{
                type: 17,
                components: [{
                  type: 10,
                  content: `:interrobang: One player remains to be swapped\n\n${playerMentions} was not swapped into a tribe as there are uneven numbers. What will Production do about this?!`
                }]
              }]
            });
          }
        }

        // Create archive castlist (uses castlistConfigs, not castlists!)
        const timestamp = Date.now();
        const archiveCastlistId = `castlist_archive_${timestamp}`;

        if (!playerData[guildId].castlistConfigs) {
          playerData[guildId].castlistConfigs = {};
        }

        // Check if default castlist has a seasonId and copy it to archive
        const defaultCastlistConfig = playerData[guildId].castlistConfigs?.['default'];
        const seasonId = defaultCastlistConfig?.seasonId || null;

        playerData[guildId].castlistConfigs[archiveCastlistId] = {
          id: archiveCastlistId,
          name: archiveName.trim(),
          type: 'custom',
          createdAt: timestamp,
          createdBy: userId,
          seasonId: seasonId, // Preserve season ID if present
          metadata: {
            description: `Former tribes prior to Tribe Swap on ${new Date(timestamp).toLocaleDateString()}`,
            emoji: 'üì¶'
          }
        };

        if (seasonId) {
          console.log(`üîÄ [TRIBE SWAP] Archive inherits seasonId: ${seasonId}`);
        }

        console.log(`üîÄ [TRIBE SWAP] Created archive castlist: ${archiveName.trim()} (${archiveCastlistId})`);

        // Move old tribes to archive
        console.log(`üîÄ [TRIBE SWAP] Moving ${currentDefaultTribes.length} old tribes to archive...`);
        for (const tribe of currentDefaultTribes) {
          const tribeData = playerData[guildId].tribes[tribe.roleId];
          if (tribeData) {
            const oldRole = guild.roles.cache.get(tribe.roleId);
            const tribeName = oldRole?.name || 'Unknown';

            // Update castlistIds array
            if (!tribeData.castlistIds) tribeData.castlistIds = [];

            // Remove default
            tribeData.castlistIds = tribeData.castlistIds.filter(id => id !== 'default');

            // Add archive
            tribeData.castlistIds.push(archiveCastlistId);
            tribeData.castlistId = archiveCastlistId;
            tribeData.castlist = archiveName.trim();

            console.log(`üîÄ [TRIBE SWAP]   - Moved "${tribeName}" (${tribe.roleId}) to archive`);
          }
        }

        // Add new tribes to default castlist
        console.log(`üîÄ [TRIBE SWAP] Adding ${newTribeRoleIds.length} new tribes to default castlist...`);
        for (const roleId of newTribeRoleIds) {
          const role = guild.roles.cache.get(roleId);

          if (!playerData[guildId].tribes[roleId]) {
            playerData[guildId].tribes[roleId] = {
              castlistIds: [],
              emoji: null,
              displayName: null,
              color: role.color ? `#${role.color.toString(16).padStart(6, '0')}` : null
            };
          }

          const tribe = playerData[guildId].tribes[roleId];

          // Link to default castlist
          if (!tribe.castlistIds) tribe.castlistIds = [];
          if (!tribe.castlistIds.includes('default')) {
            tribe.castlistIds.push('default');
          }
          tribe.castlistId = 'default';
          tribe.castlist = 'default';

          console.log(`üîÄ [TRIBE SWAP]   + Added "${role.name}" (${roleId}) to default`);
        }

        // Handle vanity roles (add old tribe roles as decorative badges on player cards)
        if (vanityRoles === 'yes') {
          console.log(`üîÄ [TRIBE SWAP] Adding old tribe roles as vanity badges to ${playerArray.length} players...`);

          // Initialize players structure if it doesn't exist
          if (!playerData[guildId].players) {
            playerData[guildId].players = {};
          }

          let vanityPlayersUpdated = 0;
          for (const player of playerArray) {
            const displayName = player.displayName || player.user.username;

            // Find which old tribe this player was in
            for (const oldTribe of currentDefaultTribes) {
              const oldRole = guild.roles.cache.get(oldTribe.roleId);
              if (oldRole && oldRole.members.has(player.id)) {
                // Initialize player object if it doesn't exist
                if (!playerData[guildId].players[player.id]) {
                  playerData[guildId].players[player.id] = {};
                }

                // Get or initialize vanityRoles array
                if (!playerData[guildId].players[player.id].vanityRoles) {
                  playerData[guildId].players[player.id].vanityRoles = [];
                }

                const vanityRolesArray = playerData[guildId].players[player.id].vanityRoles;

                // Add old tribe role if not already present (additive)
                if (!vanityRolesArray.includes(oldTribe.roleId)) {
                  vanityRolesArray.push(oldTribe.roleId);
                  vanityPlayersUpdated++;
                  console.log(`üîÄ [TRIBE SWAP]   ‚ú® Vanity: ${displayName} ‚Üí added "${oldRole.name}" badge (${oldTribe.roleId})`);
                }

                // Mark tribe as eligible for vanity display
                const tribeData = playerData[guildId].tribes[oldTribe.roleId];
                if (tribeData) {
                  tribeData.isVanity = true;
                }

                break; // Player can only be in one old tribe
              }
            }
          }

          console.log(`üîÄ [TRIBE SWAP] ‚úÖ Added vanity badges to ${vanityPlayersUpdated} players`);
        } else {
          console.log(`üîÄ [TRIBE SWAP] Vanity roles disabled - old tribes won't appear as player badges`);
        }

        await savePlayerData(playerData);

        console.log(`üîÄ [TRIBE SWAP] ‚úÖ Swap complete! Archive: ${archiveName.trim()}`);
        console.log(`üîÄ [TRIBE SWAP] üìä Summary: ${playerArray.length} players, ${newTribeRoleIds.length} new tribes, ${currentDefaultTribes.length} old tribes archived`);

        // Post completion message (via REST API)
        await fetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
          method: 'POST',
          headers: {
            'Authorization': `Bot ${process.env.DISCORD_TOKEN}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            flags: (1 << 15),
            components: [{
              type: 17,
              accent_color: 0x00FF00,
              components: [{
                type: 10,
                content: `# ‚úÖ Tribe Swap Complete!\n\n**Summary:**\n- **${playerArray.length}** players processed\n- **${newTribeRoleIds.length}** new tribes created\n- **${currentDefaultTribes.length}** old tribes archived to: **${archiveName.trim()}**\n${vanityRoles === 'yes' ? '- ‚ú® Old tribe roles kept as vanity indicators' : ''}\n\nThe game continues... üéÆ`
              }]
            }]
          })
        });

        // Return to castlist hub
        const { createCastlistHub } = await import('./castlistHub.js');
        const hubData = await createCastlistHub(guildId, {
          selectedCastlistId: 'default',
          activeButton: null
        }, client);

        // Send follow-up message with hub
        await fetch(`https://discord.com/api/v10/webhooks/${process.env.DISCORD_APP_ID}/${req.body.token}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            flags: InteractionResponseFlags.EPHEMERAL,
            ...hubData
          })
        });

      } catch (error) {
        console.error(`üîÄ [TRIBE SWAP] Error:`, error);

        // Send error message
        await fetch(`https://discord.com/api/v10/webhooks/${process.env.DISCORD_APP_ID}/${req.body.token}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            flags: InteractionResponseFlags.EPHEMERAL,
            components: [{
              type: 17,
              components: [{
                type: 10,
                content: `‚ùå Tribe swap failed: ${error.message}`
              }]
            }]
          })
        });
      }
    } else if (custom_id.startsWith('tribe_edit_modal|')) {
      // Handle tribe edit modal submission from CastlistV3 Hub
      // Uses deferred response to avoid 3-second timeout (member fetch + hub rebuild is slow)
      const token = req.body.token;

      // Immediately defer the update (prevents "interaction failed")
      res.send({ type: InteractionResponseType.DEFERRED_UPDATE_MESSAGE });

      try {
        const [prefix, roleId, castlistId] = custom_id.split('|');
        const guildId = req.body.guild_id;

        console.log(`[CASTLIST] Processing tribe edit modal for role ${roleId}, castlist ${castlistId}`);

        // Extract modal values (NO tribe_remove field)
        const components = req.body.data.components;
        console.log(`[CASTLIST] Modal components structure:`, JSON.stringify(components, null, 2).substring(0, 500));

        const getFieldValue = (customId) => {
          if (!components || !Array.isArray(components)) {
            console.warn(`[CASTLIST] Components is not an array:`, typeof components);
            return '';
          }

          for (const row of components) {
            // Handle Label (type 18) wrapper with nested component (Components V2 format)
            if (row?.type === 18 && row?.component) {
              if (row.component.custom_id === customId) {
                return row.component.value || '';
              }
            }
            // Handle ActionRow format (type 1) with nested components
            else if (row?.components && Array.isArray(row.components)) {
              const field = row.components.find(c => c?.custom_id === customId);
              if (field) return field.value || '';
            }
            // Handle direct array format (flattened)
            else if (Array.isArray(row)) {
              const field = row.find(c => c?.custom_id === customId);
              if (field) return field.value || '';
            }
          }
          return '';
        };

        const nameInput = getFieldValue('tribe_name');
        const emojiInput = getFieldValue('tribe_emoji');
        const colorInput = getFieldValue('tribe_color');
        const showPlayerEmojisInput = getFieldValue('show_player_emojis');

        console.log(`[CASTLIST] Extracted modal values:`, {
          name: nameInput,
          emoji: emojiInput,
          color: colorInput,
          showPlayerEmojis: showPlayerEmojisInput
        });

        // Validate emoji (modal-specific)
        let processedEmoji = null;
        if (emojiInput !== undefined && emojiInput !== '') {
          const trimmed = emojiInput.trim();
          const customEmojiMatch = trimmed.match(/<a?:(\w+):(\d{17,19})>/);
          if (customEmojiMatch) {
            processedEmoji = trimmed;
          } else if (trimmed.length <= 8 && /[^\x00-\x7F]/u.test(trimmed)) {
            // Accept any short string with non-ASCII characters (covers all Unicode emoji blocks)
            // Discord will handle display ‚Äî better to accept broadly than reject valid emojis
            processedEmoji = trimmed;
          } else {
            console.warn(`[CASTLIST] Invalid emoji format: ${emojiInput}`);
          }
        }

        // Validate hex color (modal-specific)
        const { validateHexColor, populateTribeData } = await import('./utils/tribeDataUtils.js');
        let processedColor = null;
        if (colorInput && colorInput.trim()) {
          processedColor = validateHexColor(colorInput.trim());
          if (!processedColor) {
            console.warn(`[CASTLIST] Invalid color format: ${colorInput}`);
          }
        }

        // Fetch guild and role (needed for rename + populateTribeData)
        const guild = await client.guilds.fetch(guildId);
        const role = guild.roles.cache.get(roleId) || await guild.roles.fetch(roleId);
        let roleName = role?.name || 'tribe';

        // Handle tribe name rename if changed (non-blocking ‚Äî other edits saved regardless)
        let renameWarning = '';
        let roleRenamed = false;
        if (nameInput && nameInput.trim() && nameInput.trim() !== roleName) {
          const newName = nameInput.trim();
          if (newName.length > 100) {
            renameWarning = `‚ö†Ô∏è Name too long (${newName.length}/100 chars) ‚Äî kept "${roleName}"`;
          } else {
            try {
              await role.setName(newName, 'CastBot tribe name edit');
              console.log(`[CASTLIST] Renamed role "${roleName}" ‚Üí "${newName}" (ID: ${roleId})`);
              roleName = newName;
              roleRenamed = true;
            } catch (renameError) {
              console.error(`[CASTLIST] Failed to rename role ${roleId}:`, renameError);
              const isHierarchy = renameError.code === 50013;
              renameWarning = isHierarchy
                ? `‚ö†Ô∏è Can't rename ‚Äî CastBot's role must be above "${roleName}" in Server Settings > Roles`
                : `‚ö†Ô∏è Can't rename ‚Äî ${renameError.message}`;
            }
          }
        }

        // Load player data and use shared utility for common tribe fields
        const playerData = await loadPlayerData();
        if (!playerData[guildId]) playerData[guildId] = {};
        if (!playerData[guildId].tribes) playerData[guildId].tribes = {};

        const { castlistManager } = await import('./castlistManager.js');
        const castlist = await castlistManager.getCastlist(guildId, castlistId);
        const castlistName = (castlistId === 'default') ? 'default' : (castlist?.name || castlistId);

        // populateTribeData handles: castlistIds, castlist, analyticsName, analyticsAdded, defaults
        const existingTribe = playerData[guildId].tribes[roleId] || {};
        const tribe = populateTribeData(existingTribe, role, castlistId, castlistName);
        playerData[guildId].tribes[roleId] = tribe;

        // Apply modal-specific overrides (empty string = clear field)
        if (emojiInput !== undefined) {
          if (emojiInput === '') {
            delete tribe.emoji;
          } else if (processedEmoji) {
            tribe.emoji = processedEmoji;
          }
        }

        if (colorInput !== undefined) {
          if (processedColor) {
            tribe.color = processedColor;
          } else if (!colorInput.trim()) {
            delete tribe.color;
          }
        }

        if (showPlayerEmojisInput !== undefined && showPlayerEmojisInput.trim()) {
          const input = showPlayerEmojisInput.trim().toLowerCase();
          if (input === 'yes' || input === 'y' || input === 'true') {
            tribe.showPlayerEmojis = true;
          } else if (input === 'no' || input === 'n' || input === 'false') {
            tribe.showPlayerEmojis = false;
          }
        }

        await savePlayerData(playerData);

        // Two-phase response: show tribes instantly, then update with member counts
        // When role was renamed, skip Phase 1 to avoid stale Role Select names
        const { twoPhaseHubResponse } = await import('./castlistHandlers.js');
        await twoPhaseHubResponse(token, guildId, {
          message: renameWarning
            ? `${renameWarning}\n‚úÖ Other settings saved for ${tribe.emoji || ''} **${roleName}**`
            : `‚úÖ Updated settings for ${tribe.emoji || ''} **${roleName}**`,
          selectedCastlistId: castlistId,
          activeButton: 'add_tribe'
        }, client, { roleRenamed });
        return null;

      } catch (error) {
        console.error('[CASTLIST] Error processing tribe edit modal:', error);
        return updateDeferredResponse(token, {
          components: [{
            type: 17, // Container
            components: [{
              type: 10, // Text Display
              content: '‚ùå Error updating tribe settings. Please try again.'
            }]
          }]
        });
      }
    } else if (custom_id === 'age_modal' || custom_id === 'player_age_modal') {
      // Use new modular handler for player age modal
      const playerData = await loadPlayerData();
      return await handlePlayerModalSubmit(req, res, custom_id, playerData, client);
    } else if (custom_id === 'application_button_modal' || custom_id.startsWith('application_button_modal_')) {
      try {
        console.log('Processing application_button_modal submission');
        
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        
        // Check if this is for an existing config
        let existingConfigId = null;
        if (custom_id.startsWith('application_button_modal_')) {
          existingConfigId = custom_id.replace('application_button_modal_', '');
          console.log(`üîç DEBUG: Extracted config ID: ${existingConfigId}`);
          console.log(`üîç DEBUG: Original custom_id: ${custom_id}`);
          
          // Debug what configs exist
          const data = await loadPlayerData();
          if (data[guildId]?.applicationConfigs) {
            console.log(`üîç DEBUG: Available configs: ${Object.keys(data[guildId].applicationConfigs)}`);
          }
        }
        
        // If we have an existing configId, pass it to the handler
        if (existingConfigId) {
          req.body.existingConfigId = existingConfigId;
        }
        
        // Handle the modal submission
        const result = await handleApplicationButtonModalSubmit(req.body, guild);
        
        if (!result.success) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: result.error,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: result.response
        });

      } catch (error) {
        console.error('Error in application_button_modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: 'Error processing application button configuration.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_display_text_save_')) {
      // Handle display text edit/save modal submissions
      try {
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to edit actions.')) return;

        const { handleDisplayTextSave } = await import('./customActionUI.js');
        const result = await handleDisplayTextSave(guildId, custom_id, req.body.data);
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            ...result
            // No flags in UPDATE_MESSAGE - per Discord Interaction API requirements
          }
        });
        
      } catch (error) {
        console.error('Error in safari_display_text_save handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error saving display text action.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'create_season_modal' || custom_id.startsWith('season_modal:')) {
      try {
        // Handle both legacy 'create_season_modal' and new 'season_modal:*' patterns
        const guildId = req.body.guild_id;
        const components = req.body.data.components;

        // Parse values from Label components (Type 18)
        // Label structure: components[i].component.value (singular 'component')
        const seasonName = components[0].component.value;
        const seasonDescription = components[1].component.value || '';

        // Parse custom_id to detect create vs edit mode
        // Format: 'season_modal:create' or 'season_modal:{configId}'
        let isEditMode = false;
        let configId = null;

        if (custom_id.startsWith('season_modal:')) {
          const parts = custom_id.split(':');
          if (parts.length !== 2) {
            console.error(`‚ùå Invalid season_modal custom_id format: ${custom_id}`);
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Invalid modal format. Please try again.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }

          const mode = parts[1];
          if (mode === 'create') {
            isEditMode = false;
            console.log('üìù Processing season creation (new pattern)');
          } else {
            isEditMode = true;
            configId = mode;
            console.log(`‚úèÔ∏è Processing season edit for configId: ${configId}`);
          }
        } else {
          // Legacy 'create_season_modal' pattern
          isEditMode = false;
          console.log('üìù Processing season creation (legacy pattern)');
        }

        const playerData = await loadPlayerData();
        if (!playerData[guildId]) {
          playerData[guildId] = { players: {}, tribes: {}, timezones: {}, pronounRoleIDs: [] };
        }
        if (!playerData[guildId].applicationConfigs) {
          playerData[guildId].applicationConfigs = {};
        }

        if (isEditMode) {
          // EDIT MODE: Update existing season config
          const config = playerData[guildId].applicationConfigs?.[configId];

          if (!config) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Season configuration not found.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }

          // Update season name and description
          config.seasonName = seasonName;
          config.explanatoryText = seasonDescription || `Join ${seasonName}!`;

          // Truncate button text if needed (Discord limit: 80 chars)
          // "Apply to " = 9 chars, leaving 71 chars for season name
          let buttonText = `Apply to ${seasonName}`;
          if (buttonText.length > 80) {
            // Truncate season name to 68 chars (9 + 68 + 2 = 79 for "..")
            const truncatedName = seasonName.substring(0, 68) + '..';
            buttonText = `Apply to ${truncatedName}`;
          }
          config.buttonText = buttonText;
          config.lastUpdated = Date.now();

          await savePlayerData(playerData);

          console.log(`‚úÖ SUCCESS: Season "${seasonName}" updated (configId: ${configId})`);

          // Return to question management UI (UPDATE_MESSAGE pattern)
          return refreshQuestionManagementUI(res, config, configId, 0);

        } else {
          // CREATE MODE: Create new season config
          // Generate UUID-based season ID
          const seasonId = `season_${crypto.randomUUID().replace(/-/g, '').substring(0, 16)}`;
          configId = `config_${Date.now()}_${req.body.member.user.id}`;

          // Truncate button text if needed (Discord limit: 80 chars)
          let buttonText = `Apply to ${seasonName}`;
          if (buttonText.length > 80) {
            const truncatedName = seasonName.substring(0, 68) + '..';
            buttonText = `Apply to ${truncatedName}`;
          }

          // Create the new config with season data
          playerData[guildId].applicationConfigs[configId] = {
            buttonText: buttonText,
            explanatoryText: seasonDescription || `Join ${seasonName}!`,
            completionDescription: 'Thank you for completing your application! A host will review it soon.',
            completionImage: null,
            channelFormat: 'üìù%name%-app',
            targetChannelId: null,
            categoryId: null,
            buttonStyle: 'Primary',
            createdBy: req.body.member.user.id,
            stage: 'draft', // Start as draft since it needs channel/category setup
            createdAt: Date.now(),
            lastUpdated: Date.now(),
            seasonId: seasonId,
            seasonName: seasonName,
            questions: []
          };

          await savePlayerData(playerData);

          console.log(`‚úÖ SUCCESS: Season "${seasonName}" created (configId: ${configId})`);

          // Use the refreshQuestionManagementUI function for consistent UI
          return refreshQuestionManagementUI(res, playerData[guildId].applicationConfigs[configId], configId, 0);
        }

      } catch (error) {
        console.error('Error in season_modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error processing season. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('season_new_question_modal_')) {
      // Handle new question creation
      try {
        // Extract configId and currentPage: season_new_question_modal_{configId}_{currentPage}
        const prefix = 'season_new_question_modal_';
        const remaining = custom_id.replace(prefix, '');
        const parts = remaining.split('_');
        const currentPage = parseInt(parts.pop()); // Get page from end
        const configId = parts.join('_'); // Join remaining parts as configId
        const guildId = req.body.guild_id;
        const components = req.body.data.components;

        // Parse values from Label components (Type 18)
        // Label structure: components[i].component.value (singular 'component')
        const questionTitle = components[0].component.value;
        const questionText = components[1].component.value;
        const imageURL = components[2].component.value;
        
        // Load player data
        const playerData = await loadPlayerData();
        const config = playerData[guildId]?.applicationConfigs?.[configId];
        
        if (!config) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Season configuration not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Ensure questions array exists
        if (!config.questions) {
          config.questions = [];
        }
        
        // Create new question with unique ID
        const questionId = `question_${crypto.randomUUID().replace(/-/g, '').substring(0, 16)}`;
        const newQuestion = {
          id: questionId,
          order: config.questions.length + 1,
          questionTitle: questionTitle,
          questionText: questionText,
          imageURL: imageURL || '',
          createdAt: Date.now()
        };
        
        config.questions.push(newQuestion);
        await savePlayerData(playerData);
        
        // Calculate the page for the new question (last page)
        const questionsPerPage = 5;
        const newQuestionPage = Math.floor((config.questions.length - 1) / questionsPerPage);
        
        // Refresh the UI on the page containing the new question
        return refreshQuestionManagementUI(res, config, configId, newQuestionPage);
        
      } catch (error) {
        console.error('Error creating new question:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error creating question. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('season_edit_question_modal_')) {
      // Handle question edit
      try {
        // Extract configId and index: season_edit_question_modal_{configId}_{index}
        const prefix = 'season_edit_question_modal_';
        const remaining = custom_id.replace(prefix, '');
        const lastUnderscoreIndex = remaining.lastIndexOf('_');
        const configId = remaining.substring(0, lastUnderscoreIndex);
        const questionIndex = parseInt(remaining.substring(lastUnderscoreIndex + 1));
        const guildId = req.body.guild_id;
        const components = req.body.data.components;

        // Parse values from Label components (Type 18)
        // Label structure: components[i].component.value (singular 'component')
        const questionTitle = components[0].component.value;
        const questionText = components[1].component.value;
        const imageURL = components[2].component.value;
        
        // Load player data
        const playerData = await loadPlayerData();
        const config = playerData[guildId]?.applicationConfigs?.[configId];
        const question = config?.questions?.[questionIndex];
        
        if (!question) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Question not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Update question
        question.questionTitle = questionTitle;
        question.questionText = questionText;
        question.imageURL = imageURL || '';
        question.lastUpdated = Date.now();
        
        await savePlayerData(playerData);
        
        // Calculate current page based on question index (5 questions per page)
        const questionsPerPage = 5;
        const currentPage = Math.floor(questionIndex / questionsPerPage);
        
        // Refresh the UI
        return refreshQuestionManagementUI(res, config, configId, currentPage);
        
      } catch (error) {
        console.error('Error editing question:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error editing question. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('save_player_notes_') || custom_id.startsWith('save_notes_')) {
      // Handle player notes modal submission - converted to Button Handler Factory
      return ButtonHandlerFactory.create({
        id: 'save_player_notes',
        updateMessage: true, // Update existing message with new notes
        handler: async (context) => {
          console.log(`‚úèÔ∏è START: save_player_notes modal - custom_id: ${context.customId}`);
          
          // Parse custom_id - handle both old and new formats
          const parts = context.customId.split('_');
          let channelId, appIndex, configId;
          
          if (context.customId.startsWith('save_notes_')) {
            // New shortened format: save_notes_[channelId]_[appIndex]
            channelId = parts[2];
            appIndex = parseInt(parts[3]);
            // ConfigId will need to be retrieved from current app data
          } else {
            // Legacy format: save_player_notes_[channelId]_[appIndex]_[configId]
            channelId = parts[3];
            appIndex = parseInt(parts[4]);
            configId = parts[5]; // May be undefined
          }
          
          const { guildId, userId, client } = context;
          
          // Get the notes text from the modal
          const notesText = req.body.data.components[0].components[0].value?.trim() || '';
          
          console.log(`‚úèÔ∏è Saving notes for channel ${channelId}: "${notesText}"`);
          
          // Load and update player data
          const playerData = await loadPlayerData();
          
          // Ensure application exists
          if (!playerData[guildId]) playerData[guildId] = {};
          if (!playerData[guildId].applications) playerData[guildId].applications = {};
          if (!playerData[guildId].applications[channelId]) playerData[guildId].applications[channelId] = {};
          
          // Update player notes
          if (notesText) {
            playerData[guildId].applications[channelId].playerNotes = notesText;
          } else {
            // Remove notes if empty
            delete playerData[guildId].applications[channelId].playerNotes;
          }
          
          await savePlayerData(playerData);
          
          console.log(`‚úÖ SUCCESS: save_player_notes - notes updated`);
          
          // Regenerate the ranking interface with updated notes
          const guild = await client.guilds.fetch(guildId);
          
          // If we don't have configId (new shortened format), we need to find it
          if (!configId) {
            // Get the current application to find its configId
            const app = playerData[guildId]?.applications?.[channelId];
            if (app?.configId) {
              configId = app.configId;
              console.log(`‚úèÔ∏è Retrieved configId from application: ${configId}`);
            }
          }
          
          const allApplications = configId 
            ? await getApplicationsForSeason(guildId, configId)
            : await getAllApplicationsFromData(guildId);
          const currentApp = allApplications[appIndex];
          
          if (!currentApp) {
            return {
              content: '‚ùå Application not found.',
              ephemeral: true
            };
          }
        
        // Fetch the applicant member for avatar
        let applicantMember;
        try {
          applicantMember = await guild.members.fetch(currentApp.userId);
        } catch (error) {
          applicantMember = {
            displayName: currentApp.displayName,
            user: { username: currentApp.username },
            displayAvatarURL: () => currentApp.avatarURL || `https://cdn.discordapp.com/embed/avatars/${currentApp.userId % 5}.png`
          };
        }
        
        const applicantAvatarURL = applicantMember.displayAvatarURL({ size: 512 });
        
        const galleryComponent = {
          type: 12,
          items: [{
            media: { url: applicantAvatarURL },
            description: `Avatar of applicant ${currentApp.displayName || currentApp.username}`
          }]
        };
        
        // Create ranking buttons
        const rankingButtons = [];
        const userRanking = playerData[guildId]?.applications?.[currentApp.channelId]?.rankings?.[userId];
        
          for (let i = 1; i <= 5; i++) {
            const isSelected = userRanking === i;
            rankingButtons.push(
              new ButtonBuilder()
                .setCustomId(`rank_${i}_${currentApp.channelId}_${appIndex}_${configId || 'legacy'}`)
                .setLabel(i.toString())
                .setStyle(isSelected ? ButtonStyle.Success : ButtonStyle.Secondary)
                .setDisabled(isSelected)
            );
          }
        
        const rankingRow = new ActionRowBuilder().addComponents(rankingButtons);
        
          // Create navigation buttons
          const navButtons = [];
          if (allApplications.length > 1) {
            navButtons.push(
              new ButtonBuilder()
                .setCustomId(`ranking_prev_${appIndex}_${configId || 'legacy'}`)
                .setLabel('‚óÄ Previous')
                .setStyle(ButtonStyle.Secondary)
                .setDisabled(appIndex === 0),
              new ButtonBuilder()
                .setCustomId(`ranking_next_${appIndex}_${configId || 'legacy'}`)
                .setLabel('Next ‚ñ∂')
                .setStyle(ButtonStyle.Secondary)
                .setDisabled(appIndex === allApplications.length - 1)
            );
          }
          
          navButtons.push(
            new ButtonBuilder()
              .setCustomId(`ranking_view_all_scores_${configId || 'legacy'}`)
              .setLabel('üìä View All Scores')
              .setStyle(ButtonStyle.Primary)
          );
        
        const navRow = new ActionRowBuilder().addComponents(navButtons);
        
        // Calculate average score
        const allRankings = playerData[guildId]?.applications?.[currentApp.channelId]?.rankings || {};
        const rankings = Object.values(allRankings).filter(r => r !== undefined);
        const avgScore = rankings.length > 0 ? (rankings.reduce((a, b) => a + b, 0) / rankings.length).toFixed(1) : 'No scores';
        
        // Get casting status for display
        const castingStatus = playerData[guildId]?.applications?.[currentApp.channelId]?.castingStatus;
        let castingStatusText = '';
        if (castingStatus === 'cast') {
          castingStatusText = '‚úÖ Cast';
        } else if (castingStatus === 'tentative') {
          castingStatusText = '‚ùì Tentative';
        } else if (castingStatus === 'reject') {
          castingStatusText = 'üóëÔ∏è Don\'t Cast';
        } else {
          castingStatusText = '‚ö™ Undecided';
        }
        
        // Use Cast Ranking Manager to regenerate the UI with updated notes
        const { generateSeasonAppRankingUI } = await import('./castRankingManager.js');
        const result = await generateSeasonAppRankingUI({
          guildId,
          userId,
          configId: configId || 'notes',
          allApplications,
          currentApp,
          appIndex,
          applicantMember,
          guild,
          seasonName: 'Current Season',
          playerData,
          ephemeral: false
        });
        
        return result;
        }
      })(req, res, client);
    } else if (custom_id.startsWith('admin_age_modal_')) {
      // Use new modular handler for admin age modal
      const playerData = await loadPlayerData();
      return await handlePlayerModalSubmit(req, res, custom_id, playerData, client);
    } else if (custom_id.startsWith('prod_timezone_offset_modal_')) {
      // Handle timezone offset modal submission
      try {
        const roleId = custom_id.replace('prod_timezone_offset_modal_', '');
        const offsetValue = components[0].components[0].value?.trim();
        
        // Validate offset input
        const offset = parseFloat(offsetValue);
        if (isNaN(offset) || offset < -12 || offset > 14) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå **Invalid offset value**\n\nPlease enter a valid UTC offset between -12 and +14 (e.g., 4, -5, 5.5, -3.5, 0)',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const guildId = req.body.guild_id;
        const guild = await client.guilds.fetch(guildId);
        const role = guild.roles.cache.get(roleId);
        
        if (!role) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error: Selected role not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Update playerData with timezone role and offset
        const playerData = await loadPlayerData();
        if (!playerData[guildId]) playerData[guildId] = {};
        if (!playerData[guildId].timezones) playerData[guildId].timezones = {};
        
        // Check if timezone already exists
        const existingOffset = playerData[guildId].timezones[roleId]?.offset;
        const isUpdate = existingOffset !== undefined;
        
        // Add or update timezone with offset
        playerData[guildId].timezones[roleId] = { offset };
        
        // Save data
        await savePlayerData(playerData);
        
        const offsetText = offset >= 0 ? `UTC+${offset}` : `UTC${offset}`;
        const actionText = isUpdate ? 'updated' : 'added';
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚úÖ **Timezone ${actionText}!**\n\n**Role:** ${role.name}\n**Offset:** ${offsetText}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error handling timezone offset modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error processing timezone offset.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_currency_modal_')) {
      // Handle Safari currency setting modal submission (MIGRATED TO FACTORY)
      return ButtonHandlerFactory.create({
        id: 'safari_currency_modal',
        requiresPermission: PermissionFlagsBits.ManageRoles,
        permissionName: 'Manage Roles',
        ephemeral: true,
        handler: async (context) => {
          const userId = context.customId.replace('safari_currency_modal_', '');
          
          // Get currency amount from modal
          const currencyAmount = context.components[0].components[0].value?.trim();
          
          // Validate currency input - remove commas and parse
          const cleanAmount = currencyAmount.replace(/,/g, '');
          const amount = parseInt(cleanAmount, 10);
          if (isNaN(amount) || amount < 0 || amount > 999999) {
            return {
              content: '‚ùå **Invalid currency amount**\n\nPlease enter a number between 0 and 999,999.'
            };
          }
          
          console.log(`üí∞ DEBUG: Setting currency for user ${userId} to ${amount}`);
          
          // Import Safari manager functions
          const { updateCurrency, getCurrency } = await import('./safariManager.js');
          
          // Get current currency to calculate difference
          const currentCurrency = await getCurrency(context.guildId, userId);
          const difference = amount - currentCurrency;
          
          // Update currency (set to exact amount)
          await updateCurrency(context.guildId, userId, difference);
          
          // Get user info for confirmation
          const guild = await client.guilds.fetch(context.guildId);
          const targetMember = await guild.members.fetch(userId);
          
          return {
            content: `‚úÖ **Currency Updated!**\n\n**Player:** ${targetMember.displayName}\n**Previous Balance:** ${currentCurrency} coins\n**New Balance:** ${amount} coins\n**Change:** ${difference >= 0 ? '+' : ''}${difference} coins`
          };
        }
      })(req, res, client);
    } else if (custom_id.startsWith('safari_item_qty_modal_')) {
      // Handle Safari item quantity setting modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Extract IDs from custom_id: safari_item_qty_modal_${guildId}_${itemId}_${userId}
        const parts = custom_id.replace('safari_item_qty_modal_', '').split('_');
        const modalGuildId = parts[0];
        const userId = parts[parts.length - 1];
        const itemId = parts.slice(1, -1).join('_'); // Everything between guildId and userId
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to manage player items.')) return;
        
        // Get quantity amount from modal
        const quantityValue = components[0].components[0].value?.trim();
        
        // Validate quantity input
        const quantity = parseInt(quantityValue, 10);
        if (isNaN(quantity) || quantity < 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå **Invalid quantity**\n\nPlease enter a number 0 or higher.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`üì¶ DEBUG: Setting item ${itemId} quantity for user ${userId} to ${quantity}`);
        
        // Load item data to check if it's an attack item
        const { loadEntity } = await import('./entityManager.js');
        const item = await loadEntity(guildId, 'item', itemId);
        console.log(`üì¶ DEBUG: loadEntity result for item ${itemId}:`, item);
        const itemName = item?.name || 'Unknown Item';
        const isAttackItem = item?.attackValue !== undefined && item?.attackValue > 0;
        
        // Get current player data
        const playerData = await loadPlayerData();
        
        // Ensure player structure exists
        if (!playerData[guildId]) {
          playerData[guildId] = { players: {} };
        }
        if (!playerData[guildId].players) {
          playerData[guildId].players = {};
        }
        if (!playerData[guildId].players[userId]) {
          playerData[guildId].players[userId] = {};
        }
        if (!playerData[guildId].players[userId].safari) {
          playerData[guildId].players[userId].safari = {};
        }
        if (!playerData[guildId].players[userId].safari.inventory) {
          playerData[guildId].players[userId].safari.inventory = {};
        }
        
        const inventory = playerData[guildId].players[userId].safari.inventory;
        const currentItem = inventory[itemId];
        
        // Get previous values for change calculation (handle both legacy numbers and object format)
        const previousQuantity = typeof currentItem === 'number' ? currentItem : (currentItem?.quantity || 0);
        const quantityChange = quantity - previousQuantity;
        
        // Always replace with proper object format (handles both legacy numbers and existing objects)
        if (quantity === 0) {
          // Remove item entirely when setting to 0
          delete inventory[itemId];
        } else {
          // Set item quantity - always create new object to handle legacy number format
          if (isAttackItem) {
            // For attack items, preserve existing attacks or set to quantity for new items/legacy numbers
            const previousAttacks = (typeof currentItem === 'object' && currentItem?.numAttacksAvailable !== undefined)
              ? currentItem.numAttacksAvailable + quantityChange
              : quantity; // For new items or legacy numbers, set attacks equal to quantity

            inventory[itemId] = {
              quantity: quantity,
              numAttacksAvailable: Math.max(0, previousAttacks)
            };
          } else {
            // Regular item
            inventory[itemId] = {
              quantity: quantity,
              numAttacksAvailable: 0
            };
          }
        }
        
        // Log admin activity (player history + Safari channel)
        try {
          const { addActivityEntry, ACTIVITY_TYPES } = await import('./activityLogger.js');
          addActivityEntry(playerData, guildId, userId, ACTIVITY_TYPES.admin, `[ADMIN] Set ${itemName} x${quantity}`);
        } catch (e) { console.error('Activity log error:', e); }

        // Save player data
        await savePlayerData(playerData);

        // Get user info for confirmation
        const guild = await client.guilds.fetch(guildId);
        const targetMember = await guild.members.fetch(userId);

        // Post to Safari log channel (fire-and-forget)
        try {
          const { logItemPickup } = await import('./safariLogger.js');
          await logItemPickup({
            guildId, userId, username: targetMember.user?.username, displayName: targetMember.displayName,
            location: 'Admin', itemId, itemName, itemEmoji: item?.emoji, quantity,
            source: `[ADMIN] Set to ${quantity} (was ${previousQuantity})`, channelName: 'admin'
          });
        } catch (e) { /* Safari log is optional */ }

        // Create confirmation message
        let changeText = '';
        if (quantityChange > 0) {
          changeText = `**Change:** +${quantityChange}`;
        } else if (quantityChange < 0) {
          changeText = `**Change:** ${quantityChange}`;
        } else {
          changeText = '**Change:** No change';
        }
        
        let attackInfo = '';
        if (isAttackItem && inventory[itemId]) {
          attackInfo = `\n**Attacks Available:** ${inventory[itemId].numAttacksAvailable}`;
        }
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚úÖ **Item Quantity Updated!**\n\n**Player:** ${targetMember.displayName}\n**Item:** ${itemName}\n**Previous Quantity:** ${previousQuantity}\n**New Quantity:** ${quantity}\n${changeText}${attackInfo}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error handling item quantity modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error setting item quantity.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('map_grid_edit_modal_')) {
      // Handle map grid edit modal submission
      try {
        const guildId = req.body.guild_id;
        const coord = custom_id.replace('map_grid_edit_modal_', '');
        const components = req.body.data.components;
        
        // Extract values from modal
        const title = components[0].components[0].value;
        const description = components[1].components[0].value;
        const imageURL = components[2].components[0].value;
        const cluesText = components[3].components[0].value;
        const cellType = components[4].components[0].value;
        
        console.log(`üó∫Ô∏è DEBUG: Processing map grid edit for ${coord}`);
        
        // Validate image URL if provided
        if (imageURL && !imageURL.startsWith('https://cdn.discordapp.com/')) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå **Invalid Image URL**\n\nImages must be hosted on Discord CDN (https://cdn.discordapp.com/...)',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Parse clues (one per line)
        const clues = cluesText
          .split('\n')
          .map(line => line.trim())
          .filter(line => line.length > 0);
        
        // Load and update safari content
        const { loadSafariContent, saveSafariContent } = await import('./mapExplorer.js');
        const safariData = await loadSafariContent();
        const activeMapId = safariData[guildId]?.maps?.active;
        const mapData = safariData[guildId]?.maps?.[activeMapId];
        
        if (!mapData || !mapData.coordinates[coord]) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Location not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Update coordinate data
        mapData.coordinates[coord].baseContent = {
          title: title,
          description: description,
          image: imageURL || null,
          clues: clues
        };
        mapData.coordinates[coord].cellType = cellType;
        
        // Save updated data
        await saveSafariContent(safariData);
        
        // Create confirmation message
        let confirmationParts = [
          `‚úÖ **Location ${coord} Updated!**`,
          '',
          `**Title:** ${title}`,
          `**Cell Type:** ${cellType}`,
          `**Description:** ${description.substring(0, 100)}${description.length > 100 ? '...' : ''}`
        ];
        
        if (clues.length > 0) {
          confirmationParts.push(`**Clues:** ${clues.length} clue(s) added`);
        }
        
        if (imageURL) {
          confirmationParts.push(`**Image:** Image URL saved`);
        }
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: confirmationParts.join('\n'),
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in map_grid_edit_modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating location content.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('map_currency_drop_modal_')) {
      // Handle currency drop configuration modal submission
      try {
        const guildId = req.body.guild_id;
        // Parse coord and optional index from custom_id
        // Format: map_currency_drop_modal_{coord} or map_currency_drop_modal_{coord}_{index}
        const modalParts = custom_id.replace('map_currency_drop_modal_', '').split('_');
        const coord = modalParts[0]; // First part is always the coord (e.g., "B1")
        const editIndex = modalParts.length > 1 && !isNaN(parseInt(modalParts[1])) ? parseInt(modalParts[1]) : -1;
        const components = req.body.data.components;
        
        // Extract values from modal
        const amount = parseInt(components[0].components[0].value);
        const buttonText = components[1].components[0].value;
        const buttonEmoji = components[2].components[0].value || 'ü™ô';
        
        if (isNaN(amount) || amount <= 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Invalid currency amount. Please enter a positive number.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`ü™ô Processing currency drop modal for ${coord}: ${amount} coins`);
        
        // Load and update safari data
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const activeMapId = safariData[guildId]?.maps?.active;
        const coordData = safariData[guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
        
        if (!coordData) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Location not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Initialize currencyDrops array if needed
        if (!coordData.currencyDrops) {
          coordData.currencyDrops = [];
        }
        
        // Check if this is editing an existing drop or creating new
        // The modal can be triggered from either "Add Currency Drop" or "Edit Amount/Text"
        let dropIndex = editIndex; // Use the index we parsed earlier
        
        // If no index specified (editIndex === -1), this is a new drop - always create new
        // Don't check for duplicates or assume editing existing drops
        
        if (dropIndex >= 0 && dropIndex < coordData.currencyDrops.length) {
          // Update existing drop
          coordData.currencyDrops[dropIndex] = {
            amount: amount,
            buttonText: buttonText,
            buttonEmoji: buttonEmoji,
            buttonStyle: coordData.currencyDrops[dropIndex].buttonStyle || 2,
            dropType: coordData.currencyDrops[dropIndex].dropType || 'once_per_player',
            claimedBy: coordData.currencyDrops[dropIndex].claimedBy || []
          };
        } else {
          // Add new currency drop
          coordData.currencyDrops.push({
            amount: amount,
            buttonText: buttonText,
            buttonEmoji: buttonEmoji,
            buttonStyle: 2, // Secondary/grey
            dropType: 'once_per_player',
            claimedBy: []
          });
          dropIndex = coordData.currencyDrops.length - 1; // Set index to newly added drop
        }
        
        await saveSafariContent(safariData);
        
        // Update anchor message
        const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
        await safeUpdateAnchorMessage(guildId, coord, client);
        
        // Return to the drop management interface
        const { createEntityManagementUI } = await import('./entityManagementUI.js');
        const ui = await createEntityManagementUI({
          entityType: 'map_cell',
          guildId: guildId,
          selectedId: coord,
          mode: 'edit',
          activeFieldGroup: 'items' // Show the drops management tab
        });
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            ...ui,
            ephemeral: true
          }
        });
        
      } catch (error) {
        console.error('Error in map_currency_drop_modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error configuring currency drop.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('map_item_search_modal_')) {
      // Handle item search modal submission for map locations
      try {
        const coord = custom_id.replace('map_item_search_modal_', '');
        const guildId = req.body.guild_id;
        const components = req.body.data.components;
        
        console.log(`üîç START: map_item_search_modal - coord ${coord}`);
        
        // Extract search term from modal
        const searchTerm = components[0].components[0].value?.trim() || '';
        
        // Show filtered item selection
        const { createMapItemSelectionUI } = await import('./entityManagementUI.js');
        
        const itemSelectionInterface = await createMapItemSelectionUI({
          guildId: guildId,
          coordinate: coord,
          title: `Search Results for "${searchTerm}" - ${coord}`,
          description: `Items matching "${searchTerm}" for map location`,
          searchTerm: searchTerm
        });
        
        console.log(`‚úÖ SUCCESS: map_item_search_modal - showing filtered results for "${searchTerm}"`);
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            ...itemSelectionInterface,
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL // IS_COMPONENTS_V2 + EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error(`‚ùå ERROR: map_item_search_modal - ${error.message}`);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error searching items. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_item_search_modal_')) {
      // Handle item search modal submission for safari give_item action
      try {
        const buttonId = custom_id.replace('safari_item_search_modal_', '');
        const guildId = req.body.guild_id;
        const components = req.body.data.components;
        
        console.log(`üîç START: safari_item_search_modal - button ${buttonId}`);
        
        // Extract search term from modal
        const searchTerm = components[0].components[0].value?.trim() || '';
        
        // Load and filter items
        const { loadSafariContent } = await import('./safariManager.js');
        const { parseTextEmoji } = await import('./utils/emojiUtils.js');
        const safariData = await loadSafariContent();
        const allItems = safariData[guildId]?.items || {};
        
        // Filter items by name (case insensitive)
        const filteredItems = {};
        const searchLower = searchTerm.toLowerCase();
        
        console.log(`üîç DEBUG: Searching for "${searchTerm}" in ${Object.keys(allItems).length} items`);
        
        for (const [itemId, item] of Object.entries(allItems)) {
          if (item.name && item.name.toLowerCase().includes(searchLower)) {
            filteredItems[itemId] = item;
            console.log(`‚úÖ Match found: ${item.name} (${itemId})`);
          }
        }
        
        console.log(`üîç DEBUG: Found ${Object.keys(filteredItems).length} matching items`)
        
        // Create item options array with search results
        const itemOptions = [];
        
        // Add search option again if still many results
        if (Object.keys(filteredItems).length > 10) {
          itemOptions.push({
            label: `üîç Search: "${searchTerm}"`,
            value: 'search_entities',
            description: 'Click to search again'
          });
        }
        
        // Add filtered items (limited to remaining slots)
        const maxItems = Object.keys(filteredItems).length > 10 ? 24 : 25;
        Object.entries(filteredItems).slice(0, maxItems).forEach(([itemId, item]) => {
          const { cleanText, emoji } = parseTextEmoji(`${item.emoji || ''} ${item.name}`, 'üì¶');
          const safeCleanText = cleanText || `${item.emoji || 'üì¶'} ${item.name || 'Unnamed Item'}`;
          itemOptions.push({
            label: safeCleanText.substring(0, 100),
            value: itemId,
            description: item.description?.substring(0, 100),
            emoji: emoji
          });
        });
        
        // If no results, show message
        if (itemOptions.length === 0 || (itemOptions.length === 1 && itemOptions[0].value === 'search_entities')) {
          itemOptions.push({
            label: 'No items found',
            value: 'no_results',
            description: `No items matching "${searchTerm}"`,
            emoji: { name: '‚ùå' }
          });
        }
        
        console.log(`‚úÖ SUCCESS: safari_item_search_modal - found ${Object.keys(filteredItems).length} items matching "${searchTerm}"`);
        
        // Return filtered results (update original message to prevent duplicates)
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            components: [{
              type: 17, // Container
              components: [
                {
                  type: 10, // Text Display
                  content: `## Item\n\n*Search results for "${searchTerm}"*`
                },
                { type: 14 }, // Separator
                {
                  type: 1, // Action Row
                  components: [{
                    type: 3, // String Select
                    custom_id: `safari_give_item_select_${buttonId}`,
                    placeholder: `Select item to give...`,
                    options: itemOptions
                  }]
                }
              ]
            }]
            // Note: UPDATE_MESSAGE cannot have flags - they're stripped automatically
          }
        });
        
      } catch (error) {
        console.error('Error in safari_item_search_modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error searching items. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('player_item_search_modal_')) {
      // Handle item search modal submission for player-centric item editing
      try {
        const targetUserId = custom_id.replace('player_item_search_modal_', '');
        const guildId = req.body.guild_id;
        const components = req.body.data.components;

        console.log(`üîç START: player_item_search_modal - user ${targetUserId}`);

        // Extract search term from modal
        const searchTerm = components[0].components[0].value?.trim() || '';

        // Import and create updated UI with search results
        const { createPlayerItemSelectorUI } = await import('./entityManagementUI.js');

        const uiResponse = await createPlayerItemSelectorUI({
          guildId,
          targetUserId,
          searchTerm,
          selectedItemId: null
        });

        console.log(`‚úÖ SUCCESS: player_item_search_modal - showing search results for "${searchTerm}"`);

        // Return search results (update original message)
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            ...uiResponse,
            flags: undefined // Remove flags for UPDATE_MESSAGE
          }
        });

      } catch (error) {
        console.error('Error in player_item_search_modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error searching items. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('condition_item_search_modal_')) {
      // Handle item search modal for condition editor
      try {
        // Parse: condition_item_search_modal_actionId_conditionIndex_currentPage
        const parts = custom_id.replace('condition_item_search_modal_', '').split('_');
        const currentPage = parseInt(parts.pop() || '0');
        const conditionIndex = parseInt(parts.pop() || '0');
        const actionId = parts.join('_');
        
        const guildId = req.body.guild_id;
        const components = req.body.data.components;
        
        console.log(`üîç START: condition_item_search_modal - action ${actionId}, condition ${conditionIndex}`);
        
        // Extract search term
        const searchTerm = components[0].components[0].value?.trim() || '';
        
        // Load and filter items
        const { loadSafariContent } = await import('./safariManager.js');
        const { parseTextEmoji } = await import('./utils/emojiUtils.js');
        const safariData = await loadSafariContent();
        const allItems = safariData[guildId]?.items || {};
        
        // Filter items (matching Safari logic exactly)
        const filteredItems = {};
        const searchLower = searchTerm.toLowerCase();
        
        console.log(`üîç DEBUG: Searching for "${searchTerm}" in ${Object.keys(allItems).length} items`);
        
        for (const [itemId, item] of Object.entries(allItems)) {
          if (item.name && item.name.toLowerCase().includes(searchLower)) {
            filteredItems[itemId] = item;
            console.log(`‚úÖ Match found: ${item.name} (${itemId})`);
          }
        }
        
        console.log(`üîç DEBUG: Found ${Object.keys(filteredItems).length} matching items`);
        
        // Get current condition to preserve operator
        const condition = safariData[guildId]?.buttons?.[actionId]?.conditions?.[conditionIndex];
        if (!condition) {
          throw new Error('Condition not found during search');
        }
        
        // Create item options with search results
        const itemOptions = [];
        
        // ALWAYS add search option first (for refinement)
        itemOptions.push({
          label: `üîç Search: "${searchTerm}"`,
          value: 'search_items',
          description: 'Click to search again'
        });
        
        // Add filtered items (max 24)
        Object.entries(filteredItems)
          .slice(0, 24)
          .forEach(([itemId, item]) => {
            const { cleanText, emoji } = parseTextEmoji(`${item.emoji || ''} ${item.name}`, 'üì¶');
            const safeCleanText = cleanText || `${item.emoji || 'üì¶'} ${item.name || 'Unnamed Item'}`;
            itemOptions.push({
              label: safeCleanText.substring(0, 100),
              value: itemId,
              description: item.description?.substring(0, 100),
              emoji: emoji
            });
          });
        
        // Handle no results (matching Safari exactly)
        if (itemOptions.length === 1) { // Only search option
          itemOptions.push({
            label: 'No items found',
            value: 'no_results',
            description: `No items matching "${searchTerm}"`,
            emoji: { name: '‚ùå' }
          });
        }
        
        console.log(`‚úÖ SUCCESS: condition_item_search_modal - found ${Object.keys(filteredItems).length} items`);
        
        // Return to condition editor with search results
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            components: [{
              type: 17, // Container
              accent_color: 0x5865f2,
              components: [
                {
                  type: 10,
                  content: `## ‚ûï Condition Editor\nWhen...`
                },
                {
                  type: 1, // Action Row - Type selector (keep existing)
                  components: [{
                    type: 3,
                    custom_id: `condition_type_select_${actionId}_${conditionIndex}_${currentPage}`,
                    placeholder: 'Select Condition Type...',
                    options: [
                      { label: 'Currency', value: 'currency', emoji: { name: 'ü™ô' }, default: condition.type === 'currency' },
                      { label: 'Item', value: 'item', emoji: { name: 'üì¶' }, default: true },
                      { label: 'Role', value: 'role', emoji: { name: 'üëë' }, default: condition.type === 'role' }
                    ]
                  }]
                },
                { type: 14 }, // Separator
                {
                  type: 10,
                  content: `### Item Details\nWhen user...\n*Search results for "${searchTerm}"*`
                },
                {
                  type: 1, // Operator buttons
                  components: [
                    {
                      type: 2,
                      custom_id: `condition_has_${actionId}_${conditionIndex}_${currentPage}_item`,
                      label: 'Has',
                      style: condition.operator === 'has' ? 1 : 2,
                      emoji: { name: '‚úÖ' }
                    },
                    {
                      type: 2,
                      custom_id: `condition_not_has_${actionId}_${conditionIndex}_${currentPage}_item`,
                      label: 'Does not have',
                      style: condition.operator === 'not_has' ? 1 : 2,
                      emoji: { name: '‚ùå' }
                    }
                  ]
                },
                {
                  type: 10,
                  content: 'the following item...'
                },
                {
                  type: 1, // Action Row - Item select with results
                  components: [{
                    type: 3,
                    custom_id: `condition_item_select_${actionId}_${conditionIndex}_${currentPage}`,
                    placeholder: 'Select an item...',
                    options: itemOptions
                  }]
                },
                {
                  type: 1, // Back button
                  components: [{
                    type: 2,
                    custom_id: `condition_manager_${actionId}_${currentPage}`,
                    label: '‚Üê Back',
                    style: 2,
                    emoji: { name: 'üß©' }
                  }]
                }
              ]
            }]
          }
        });
        
      } catch (error) {
        console.error('Error in condition_item_search_modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error searching items. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('map_drop_text_modal_')) {
      // Handle item drop button text modal submission
      try {
        const guildId = req.body.guild_id;
        const parts = custom_id.replace('map_drop_text_modal_', '').split('_');
        const coord = parts[0];
        const itemId = parts.slice(1).join('_');
        const components = req.body.data.components;
        
        console.log('üîç DEBUG: Modal components:', JSON.stringify(components, null, 2));
        
        // Extract values with proper error handling
        if (!components || !components[0] || !components[0].components || !components[0].components[0]) {
          console.error('‚ùå Invalid component structure for modal submission');
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error processing modal submission.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const buttonText = components[0].components[0].value;
        const buttonEmoji = (components[1] && components[1].components && components[1].components[0]) 
          ? components[1].components[0].value || 'üì¶' 
          : 'üì¶';
        
        console.log(`‚úèÔ∏è Updating drop text for ${coord} item ${itemId}`);
        
        // Load and update safari data
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const activeMapId = safariData[guildId]?.maps?.active;
        const coordData = safariData[guildId]?.maps?.[activeMapId]?.coordinates?.[coord];
        
        if (!coordData) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Location not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Initialize itemDrops if needed
        if (!coordData.itemDrops) {
          coordData.itemDrops = [];
        }
        
        // Find and update the drop, or create if it doesn't exist
        let dropIndex = coordData.itemDrops.findIndex(drop => drop.itemId === itemId);
        
        if (dropIndex === -1) {
          // Create new item drop if it doesn't exist
          console.log(`‚ú® Creating new item drop for ${itemId}`);
          coordData.itemDrops.push({
            itemId: itemId,
            buttonText: buttonText,
            buttonEmoji: buttonEmoji,
            buttonStyle: 2, // Secondary
            dropType: 'once_per_player',
            claimedBy: []
          });
        } else {
          // Update existing item drop
          coordData.itemDrops[dropIndex].buttonText = buttonText;
          coordData.itemDrops[dropIndex].buttonEmoji = buttonEmoji;
        }
        
        await saveSafariContent(safariData);
        
        // Update anchor message
        const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
        await safeUpdateAnchorMessage(guildId, coord, client);
        
        // Return to item drop configuration
        const { createEntityManagementUI } = await import('./entityManagementUI.js');
        const ui = await createEntityManagementUI({
          entityType: 'map_cell',
          guildId: guildId,
          selectedId: coord,
          mode: 'edit'
        });
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            ...ui,
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in map_drop_text_modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating button text.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_starting_info_modal_')) {
      // Handle Starting Info modal submission (starting location)
      const targetUserId = custom_id.split('_').pop();
      const guildId = req.body.guild_id;

      const startingLocation = components[0]?.component?.value?.trim().toUpperCase() || '';
      console.log(`üö© Processing Starting Info for user ${targetUserId}: startingLocation=${startingLocation || '(none)'}`);

      if (!startingLocation) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ö†Ô∏è No changes made. Provide a starting location to set.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      if (!startingLocation.match(/^[A-Z][1-9]\d?$/)) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Invalid starting location format. Use letter + number (e.g., B3, D5).',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Validate coordinate exists on active map
      const { loadSafariContent: loadSafariStartInfo } = await import('./safariManager.js');
      const safariDataStartInfo = await loadSafariStartInfo();
      const activeMapIdStartInfo = safariDataStartInfo[guildId]?.maps?.active;
      const activeMapStartInfo = activeMapIdStartInfo ? safariDataStartInfo[guildId]?.maps?.[activeMapIdStartInfo] : null;

      if (activeMapStartInfo && !activeMapStartInfo.coordinates[startingLocation]) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Starting location **${startingLocation}** does not exist on the current map.`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Save starting location (works for both initialized and uninitialized players)
      const { loadPlayerData: loadPDStartInfo, savePlayerData: savePDStartInfo } = await import('./storage.js');
      const pdStartInfo = await loadPDStartInfo();
      if (!pdStartInfo[guildId]) pdStartInfo[guildId] = { players: {} };
      if (!pdStartInfo[guildId].players[targetUserId]) pdStartInfo[guildId].players[targetUserId] = {};
      if (!pdStartInfo[guildId].players[targetUserId].safari) pdStartInfo[guildId].players[targetUserId].safari = { mapProgress: {} };
      if (!pdStartInfo[guildId].players[targetUserId].safari.mapProgress) pdStartInfo[guildId].players[targetUserId].safari.mapProgress = {};
      if (!pdStartInfo[guildId].players[targetUserId].safari.mapProgress[activeMapIdStartInfo]) pdStartInfo[guildId].players[targetUserId].safari.mapProgress[activeMapIdStartInfo] = {};
      pdStartInfo[guildId].players[targetUserId].safari.mapProgress[activeMapIdStartInfo].startingLocation = startingLocation;
      await savePDStartInfo(pdStartInfo);

      console.log(`üö© Set starting location for player ${targetUserId} to ${startingLocation}`);

      // Update the existing ephemeral Player Admin panel in-place
      const { createMapAdminUI: createUIStartInfo } = await import('./safariMapAdmin.js');
      const uiStartInfo = await createUIStartInfo({
        guildId,
        userId: targetUserId,
        mode: 'player_view'
      });
      delete uiStartInfo.flags; // Strip flags for UPDATE_MESSAGE (ephemeral inherited)
      return res.send({
        type: InteractionResponseType.UPDATE_MESSAGE,
        data: uiStartInfo
      });

    } else if (custom_id.startsWith('map_admin_coordinate_modal_')) {
      // Handle player location modal submission (move only)
      const targetUserId = custom_id.split('_').pop();
      const guildId = req.body.guild_id;

      const coordinate = components[0]?.component?.value?.trim().toUpperCase() || '';
      console.log(`üõ°Ô∏è Processing location modal for user ${targetUserId}: move=${coordinate || '(none)'}`);

      if (!coordinate) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ö†Ô∏è No coordinate provided.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      if (!coordinate.match(/^[A-Z][1-9]\d?$/)) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Invalid coordinate format. Use letter + number (e.g., B3, D5).',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Validate coordinate exists on the active map
      const { loadSafariContent } = await import('./safariManager.js');
      const safariDataCheck = await loadSafariContent();
      const activeMapIdCheck = safariDataCheck[guildId]?.maps?.active;
      const activeMapCheck = activeMapIdCheck ? safariDataCheck[guildId]?.maps?.[activeMapIdCheck] : null;

      if (activeMapCheck && !activeMapCheck.coordinates[coordinate]) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Coordinate **${coordinate}** does not exist on the current map.`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Check if player is initialized
      const { loadPlayerData, savePlayerData } = await import('./storage.js');
      const playerDataCheck = await loadPlayerData();
      const playerMapDataCheck = playerDataCheck[guildId]?.players?.[targetUserId]?.safari?.mapProgress?.[activeMapIdCheck];

      if (!playerMapDataCheck) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Cannot move player ‚Äî they are not initialized in Safari.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Skip if coordinate matches current location
      if (coordinate === playerMapDataCheck?.currentLocation) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ö†Ô∏è Player is already at **${coordinate}**.`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // ‚úÖ Send deferred response immediately (within 3 seconds)
      res.send({
        type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });

      // ‚úÖ Execute move in background with webhook follow-up
      (async () => {
        try {
          const { movePlayerToCoordinate } = await import('./safariMapAdmin.js');
          await movePlayerToCoordinate(guildId, targetUserId, coordinate, client);

          const { createMapAdminUI } = await import('./safariMapAdmin.js');
          const ui = await createMapAdminUI({
            guildId,
            userId: targetUserId,
            mode: 'player_view'
          });

          const webhookUrl = `https://discord.com/api/v10/webhooks/${req.body.application_id}/${req.body.token}`;
          const webhookResponse = await fetch(webhookUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(ui)
          });

          if (!webhookResponse.ok) {
            const errorData = await webhookResponse.text();
            throw new Error(`Webhook returned ${webhookResponse.status}: ${errorData}`);
          }

          console.log(`‚úÖ SUCCESS: Player ${targetUserId} moved to ${coordinate}`);
        } catch (error) {
          console.error('‚ùå ERROR in deferred location modal:', error.message, error);

          try {
            const errorUrl = `https://discord.com/api/v10/webhooks/${req.body.application_id}/${req.body.token}`;
            await fetch(errorUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                content: `‚ùå Error: ${error.message}`,
                flags: InteractionResponseFlags.EPHEMERAL
              })
            });
          } catch (webhookError) {
            console.error('‚ùå Failed to send error webhook:', webhookError.message);
          }
        }
      })(); // Fire and forget

    } else if (custom_id.startsWith('map_admin_stamina_modal_')) {
      // Handle stamina set submission
      const targetUserId = custom_id.split('_').pop();
      const guildId = req.body.guild_id;
      const amount = parseInt(components[0].components[0].value?.trim());

      console.log(`üõ°Ô∏è Processing stamina set to ${amount} for user ${targetUserId}`);

      // Validate amount immediately
      if (isNaN(amount) || amount < 0 || (amount > 10 && amount !== 99)) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Invalid amount. Please enter a number between 0 and 10 (or 99 for test mode).',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // ‚úÖ Send deferred response immediately (within 3 seconds)
      res.send({
        type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });

      // ‚úÖ Execute long-running operations in background with webhook follow-up
      (async () => {
        try {
          const { setPlayerStamina, createMapAdminUI } = await import('./safariMapAdmin.js');

          await setPlayerStamina(guildId, targetUserId, amount);

          // Create updated UI
          const ui = await createMapAdminUI({
            guildId,
            userId: targetUserId,
            mode: 'player_view'
          });

          // Send follow-up via webhook using POST to create new follow-up message
          // POST is more reliable than PATCH for deferred interactions and doesn't require edit permissions
          console.log('üîç Sending webhook follow-up for stamina modal via POST');
          const webhookUrl = `https://discord.com/api/v10/webhooks/${req.body.application_id}/${req.body.token}`;
          const webhookResponse = await fetch(webhookUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(ui)
          });

          if (!webhookResponse.ok) {
            const errorData = await webhookResponse.text();
            throw new Error(`Webhook returned ${webhookResponse.status}: ${errorData}`);
          }

          console.log(`‚úÖ SUCCESS: Set stamina for player ${targetUserId} to ${amount} and sent webhook follow-up`);
        } catch (error) {
          console.error('‚ùå ERROR in deferred stamina modal:', error.message, error);

          // Try to send error follow-up via webhook using POST
          try {
            const errorUrl = `https://discord.com/api/v10/webhooks/${req.body.application_id}/${req.body.token}`;
            const errorResponse = await fetch(errorUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                content: `‚ùå Error: ${error.message}`,
                flags: InteractionResponseFlags.EPHEMERAL
              })
            });
            if (!errorResponse.ok) {
              console.error(`Failed to send error webhook: ${errorResponse.status}`);
            }
          } catch (webhookError) {
            console.error('‚ùå Failed to send error webhook:', webhookError.message);
          }
        }
      })(); // Fire and forget

    } else if (custom_id.startsWith('map_admin_currency_modal_')) {
      // Handle currency edit submission
      try {
        const targetUserId = custom_id.split('_').pop();
        const guildId = req.body.guild_id;
        const amount = parseInt(components[0].components[0].value?.trim());
        
        console.log(`üõ°Ô∏è Processing currency set to ${amount} for user ${targetUserId}`);
        
        if (isNaN(amount) || amount < 0 || amount > 999999) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Invalid amount. Please enter a number between 0 and 999999.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        const { loadPlayerData, savePlayerData } = await import('./storage.js');
        const { createMapAdminUI } = await import('./safariMapAdmin.js');
        
        // Set currency directly in player data (works for both initialized and uninitialized players)
        const playerData = await loadPlayerData();
        if (!playerData[guildId]) playerData[guildId] = { players: {} };
        if (!playerData[guildId].players[targetUserId]) playerData[guildId].players[targetUserId] = {};
        if (!playerData[guildId].players[targetUserId].safari) playerData[guildId].players[targetUserId].safari = {};

        playerData[guildId].players[targetUserId].safari.currency = amount;

        // Log admin activity
        const { addActivityEntry, ACTIVITY_TYPES } = await import('./activityLogger.js');
        const { getCustomTerms } = await import('./safariManager.js');
        const adminTerms = await getCustomTerms(guildId);
        addActivityEntry(playerData, guildId, targetUserId, ACTIVITY_TYPES.admin, `[ADMIN] Currency set to ${amount} ${adminTerms.currencyName}`);

        await savePlayerData(playerData);

        // Post to Safari log channel (fire-and-forget)
        try {
          const { logCurrencyChange } = await import('./safariLogger.js');
          const adminMember = req.body.member;
          const adminName = adminMember?.user?.username || 'Admin';
          await logCurrencyChange({
            guildId, userId: targetUserId, username: adminName, displayName: adminMember?.nick || adminName,
            location: 'Admin', amount, currencyName: adminTerms.currencyName,
            source: `[ADMIN] Set to ${amount}`, channelName: 'admin'
          });
        } catch (e) { /* Safari log is optional */ }

        // Return updated player view
        const ui = await createMapAdminUI({
          guildId,
          userId: targetUserId,
          mode: 'player_view'
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: ui
        });
        
      } catch (error) {
        console.error('Error in map_admin_currency_modal:', error);
        // Return Components V2 error message for any other errors
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL, // IS_COMPONENTS_V2 + EPHEMERAL
            components: [{
              type: 17, // Container
              accent_color: 0xe74c3c, // Red for error
              components: [
                {
                  type: 10, // Text Display
                  content: `# ‚ùå Error Processing Request\n\nAn error occurred while updating the currency.\n\n**Error:** ${error.message}\n\nPlease try again or contact support if the issue persists.`
                }
              ]
            }]
          }
        });
      }
      
    } else if (custom_id.startsWith('map_admin_item_qty_modal_') || custom_id.startsWith('map_admin_add_item_qty_modal_')) {
      // Handle map admin item quantity submission (both edit and add)
      try {
        const isAddMode = custom_id.startsWith('map_admin_add_item_qty_modal_');
        // Format: map_admin_item_qty_modal_${guildId}_${itemId}_${userId}
        // OR: map_admin_add_item_qty_modal_${guildId}_${itemId}_${userId}
        const parts = custom_id.split('_');
        const userId = parts.pop(); // Get last part
        const guildId = req.body.guild_id;
        
        // Find where guildId ends and itemId starts
        let guildIdIndex = -1;
        const startIndex = isAddMode ? 6 : 5; // Different starting index for add vs edit
        for (let i = startIndex; i < parts.length; i++) {
          if (parts[i] === guildId) {
            guildIdIndex = i;
            break;
          }
        }
        
        // Extract itemId between guildId and userId
        const itemId = parts.slice(guildIdIndex + 1).join('_');
        const quantity = parseInt(components[0].components[0].value?.trim());
        
        console.log(`üõ°Ô∏è Processing item quantity ${isAddMode ? 'add' : 'set'}: user=${userId}, item=${itemId}, qty=${quantity}`);
        
        if (isNaN(quantity) || quantity < 0 || quantity > 9999) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Invalid quantity. Please enter a number between 0 and 9999.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Load item data to determine if it's an attack item
        const { loadEntity } = await import('./entityManager.js');
        const item = await loadEntity(guildId, 'item', itemId);
        
        // Update player inventory
        const playerData = await loadPlayerData();
        if (!playerData[guildId]) playerData[guildId] = { players: {} };
        if (!playerData[guildId].players[userId]) playerData[guildId].players[userId] = { safari: {} };
        if (!playerData[guildId].players[userId].safari.inventory) {
          playerData[guildId].players[userId].safari.inventory = {};
        }
        
        const inventory = playerData[guildId].players[userId].safari.inventory;
        
        // Import getItemQuantity to handle both number and object formats
        const { getItemQuantity } = await import('./safariManager.js');
        
        if (isAddMode) {
          // Add mode - add to existing quantity
          const currentQuantity = getItemQuantity(inventory[itemId] || 0);
          const newQuantity = currentQuantity + quantity;
          
          if (newQuantity > 9999) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Adding this quantity would exceed the maximum of 9999.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          if (item?.attackValue) {
            // Attack item - use object format
            const currentAttacks = inventory[itemId]?.numAttacksAvailable || 0;
            inventory[itemId] = {
              quantity: newQuantity,
              numAttacksAvailable: currentAttacks + quantity // Add to available attacks
            };
          } else {
            // Regular item - use object format for consistency
            inventory[itemId] = {
              quantity: newQuantity,
              numAttacksAvailable: 0
            };
          }
        } else {
          // Edit mode - set exact quantity
          if (quantity === 0) {
            // Remove item
            delete inventory[itemId];
          } else {
            // Set item quantity
            if (item?.attackValue) {
              // Attack item - use object format
              inventory[itemId] = {
                quantity: quantity,
                numAttacksAvailable: quantity // For admin, set attacks equal to quantity
              };
            } else {
              // Regular item - use object format for consistency
              inventory[itemId] = {
                quantity: quantity,
                numAttacksAvailable: 0
              };
            }
          }
        }
        
        await savePlayerData(playerData);
        
        // Get user info for success message
        const guild = await client.guilds.fetch(guildId);
        const targetMember = await guild.members.fetch(userId);
        const displayName = targetMember.displayName || targetMember.user.username;
        const itemName = item?.name || 'Unknown Item';
        
        // Success message
        const successMessage = isAddMode
          ? `‚úÖ Added ${quantity} √ó ${item?.emoji || 'üì¶'} ${itemName} to ${displayName}'s inventory.`
          : quantity === 0
            ? `‚úÖ Removed ${item?.emoji || 'üì¶'} ${itemName} from ${displayName}'s inventory.`
            : `‚úÖ Set ${item?.emoji || 'üì¶'} ${itemName} quantity to ${quantity} for ${displayName}.`;

        // Add audit logging for admin actions
        const adminUserId = req.body.member?.user?.id || req.body.user?.id;
        console.log(`üõ°Ô∏è ADMIN: User ${adminUserId} set ${itemName} quantity for ${userId} from previous value to ${quantity} in guild ${guildId}`);

        // Determine return destination based on context
        const returnButton = isPlayerAdminContext
          ? {
              type: 2, // Button
              style: 2, // Secondary
              label: '‚Üê Item Selector',
              custom_id: `map_admin_edit_items_${userId}`, // Returns to player item selector
              emoji: { name: 'üì¶' }
            }
          : {
              type: 2, // Button
              style: 2, // Secondary
              label: 'Back to Inventory',
              custom_id: `map_admin_edit_items_${userId}`,
              emoji: { name: '‚¨ÖÔ∏è' }
            };

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: successMessage,
            components: [{
              type: 1, // Action Row
              components: [returnButton]
            }],
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in map_admin_item_qty_modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Error: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('safari_buy_')) {
      // MVP2: Handle item purchases (format: safari_buy_guildId_storeId_itemId_timestamp)
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        
        // Parse custom ID to extract store and item info
        const parts = custom_id.split('_');
        if (parts.length < 5) {
          throw new Error('Invalid buy button custom ID format');
        }
        
        const extractedGuildId = parts[2];
        const storeId = parts[3];
        const itemId = parts[4];
        
        // Verify guild ID matches
        if (extractedGuildId !== guildId) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Invalid purchase request.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`üí≥ DEBUG: Processing purchase: ${itemId} from store ${storeId} by user ${userId}`);
        
        // Import Safari manager functions
        const { buyItem } = await import('./safariManager.js');
        
        const result = await buyItem(guildId, storeId, itemId, userId);
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: result
        });
        
      } catch (error) {
        console.error('Error handling item purchase:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error processing purchase. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_store_modal') {
      // Handle Safari store creation modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to create stores.')) return;
        
        // Extract form data (Label/type 18 format with ActionRow fallback)
        const getVal = (comp) => (comp?.component?.value ?? comp?.components?.[0]?.value)?.trim() || null;
        const storeName = getVal(components[0]);
        const storeEmoji = getVal(components[1]);
        const storeownerText = getVal(components[2]); // index 2 = greeting
        const storeDescription = getVal(components[3]); // index 3 = description

        // Validate required fields
        if (!storeName) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store name is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        console.log(`üè™ DEBUG: Creating store "${storeName}" for guild ${guildId}`);
        
        // Import Safari manager functions
        const { createStore } = await import('./safariManager.js');
        
        const result = await createStore(guildId, {
          name: storeName,
          emoji: storeEmoji,
          description: storeDescription,
          storeownerText: storeownerText,
          createdBy: member.user.id
        });
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚úÖ **Store Created Successfully!**\n\n**${storeEmoji ? storeEmoji + ' ' : ''}${storeName}**\n${storeDescription ? storeDescription : ''}\n\nStore ID: \`${result}\`\n\nYou can now add items to this store and assign it to buttons.`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error creating store:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error creating store. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_store_modal_redirect') {
      // Handle Safari store creation modal submission with redirect to management UI
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const token = req.body.token;

        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to create stores.')) return;

        // Extract form data (Label/type 18 format with ActionRow fallback)
        const getVal = (comp) => (comp?.component?.value ?? comp?.components?.[0]?.value)?.trim() || null;
        const storeName = getVal(components[0]);
        const storeEmoji = getVal(components[1]);
        const storeownerText = getVal(components[2]); // index 2 = greeting
        const storeDescription = getVal(components[3]); // index 3 = description

        // Validate required fields
        if (!storeName) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store name is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        console.log(`üè™ DEBUG: Creating store "${storeName}" for guild ${guildId} with redirect`);

        // DEFER IMMEDIATELY to prevent 3-second timeout
        await sendDeferredResponse(res, true);

        // Import Safari manager functions
        const { createStore, loadSafariContent } = await import('./safariManager.js');
        const { createStoreItemManagementUI } = await import('./entityManagementUI.js');

        const newStoreId = await createStore(guildId, {
          name: storeName,
          emoji: storeEmoji,
          description: storeDescription,
          storeownerText: storeownerText,
          createdBy: member.user.id
        });

        // Load the new store data
        const safariData = await loadSafariContent();
        const newStore = safariData[guildId]?.stores?.[newStoreId];

        if (!newStore) {
          // Fallback if store wasn't found for some reason
          return updateDeferredResponse(token, {
            content: `‚úÖ Store created but couldn't load management interface. Store ID: \`${newStoreId}\``,
            flags: InteractionResponseFlags.EPHEMERAL
          });
        }

        // Initialize store.items if it doesn't exist
        if (!newStore.items) {
          newStore.items = [];
        }

        // Redirect directly to new store item management for better UX
        const uiResponse = await createStoreItemManagementUI({
          storeId: newStoreId,
          store: newStore,
          guildId: guildId,
          searchTerm: ''
        });

        // Update the deferred response with the store management interface
        return updateDeferredResponse(token, uiResponse);

      } catch (error) {
        console.error('Error creating store with redirect:', error);

        // Determine error message
        let errorMessage = '‚ùå Error creating store. Please try again.';
        if (error.code === 'DUPLICATE_STORE') {
          errorMessage = `‚ùå ${error.message}`;
        }

        // If we already sent deferred response, update it; otherwise send error
        if (req.body.token && res.headersSent) {
          return updateDeferredResponse(req.body.token, {
            content: errorMessage,
            flags: InteractionResponseFlags.EPHEMERAL
          });
        }
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: errorMessage,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_store_modal_location_')) {
      // Handle Safari store creation modal submission for map locations
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const components = req.body.data.components;

        // Extract entityId from custom_id
        const entityId = custom_id.replace('safari_store_modal_location_', '');
        console.log(`üè™ DEBUG: Creating store for location ${entityId}`);

        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to create stores.')) return;

        // Extract form data (Label/type 18 format with ActionRow fallback)
        const getVal = (comp) => (comp?.component?.value ?? comp?.components?.[0]?.value)?.trim() || null;
        const storeName = getVal(components[0]);
        const storeEmoji = getVal(components[1]);
        const storeownerText = getVal(components[2]); // index 2 = greeting
        const storeDescription = getVal(components[3]); // index 3 = description

        // Validate required fields
        if (!storeName) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              components: [{
                type: 17, // Container
                components: [{
                  type: 10, // Text Display
                  content: '‚ùå Store name is required.'
                }]
              }],
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Create the store using existing createStore function
        const { createStore, loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const newStoreId = await createStore(guildId, {
          name: storeName,
          emoji: storeEmoji,
          description: storeDescription,
          storeownerText: storeownerText,
          createdBy: member.user.id
        });

        console.log(`‚úÖ DEBUG: Store '${newStoreId}' created successfully`);

        // Add store to location coordinates
        const safariData = await loadSafariContent();
        const activeMapId = safariData[guildId]?.maps?.active;
        const coordData = safariData[guildId]?.maps?.[activeMapId]?.coordinates?.[entityId];

        if (!coordData) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              components: [{
                type: 17, // Container
                components: [{
                  type: 10, // Text Display
                  content: '‚ùå Location data not found.'
                }]
              }],
              flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Add store to location
        if (!coordData.stores) coordData.stores = [];
        coordData.stores.push(newStoreId);
        await saveSafariContent(safariData);

        console.log(`‚úÖ DEBUG: Store '${newStoreId}' added to location ${entityId}`);

        // Update anchor message
        const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
        await safeUpdateAnchorMessage(guildId, entityId, client);

        // Return to location store selector with new store visible
        const { createStoreSelectionUI } = await import('./storeSelector.js');
        const uiResponse = await createStoreSelectionUI({
          guildId: guildId,
          action: 'add_to_location',
          entityId: entityId,
          preSelectedStores: coordData.stores, // Include new store
          title: `üè™ Manage Stores at ${entityId}`,
          backButtonId: `entity_view_mode_map_cell_${entityId}`,
          backButtonLabel: '‚Üê Back',
          backButtonEmoji: 'üìç'
        });

        // Return Components V2 response
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            ...uiResponse,
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          }
        });

      } catch (error) {
        console.error(`‚ùå ERROR: safari_store_modal_location - ${error.message}`);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            components: [{
              type: 17, // Container
              components: [{
                type: 10, // Text Display
                content: '‚ùå Error creating store. Please try again.'
              }]
            }],
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_store_search_modal') {
      // Handle Safari store search modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const components = req.body.data.components;

        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to search stores.')) return;

        // Get search term from modal
        const searchTerm = components[0].components[0].value?.trim().toLowerCase() || '';
        console.log(`üîç DEBUG: Searching stores with term: "${searchTerm}"`);

        // Import Safari manager functions
        const { loadSafariContent } = await import('./safariManager.js');
        const { parseTextEmoji } = await import('./utils/emojiUtils.js');

        // Load stores
        const safariData = await loadSafariContent();
        const stores = safariData[guildId]?.stores || {};

        // Filter stores based on search term
        let filteredStores = {};
        if (searchTerm) {
          for (const [id, store] of Object.entries(stores)) {
            const name = store.name?.toLowerCase() || '';
            const description = store.description?.toLowerCase() || '';

            if (name.includes(searchTerm) || description.includes(searchTerm)) {
              filteredStores[id] = store;
            }
          }
        } else {
          // Empty search shows all stores
          filteredStores = stores;
        }

        console.log(`üîç DEBUG: Found ${Object.keys(filteredStores).length} matching stores`);

        // Build dropdown with filtered results
        const storeOptions = [];

        // Always include Create New Store
        storeOptions.push({
          label: 'Create New Store',
          value: 'create_new_store',
          description: 'Create a new store.',
          emoji: { name: '‚ûï' }
        });

        const filteredCount = Object.keys(filteredStores).length;

        // Handle different result scenarios
        if (filteredCount === 0) {
          // No results found
          storeOptions.push({
            label: 'No stores found',
            value: 'no_results',
            description: searchTerm ? `No matches for "${searchTerm.slice(0, 50)}"` : 'No stores available',
            emoji: { name: '‚ùå' }
          });
        } else {
          // Add Search Again option if we still have many results
          if (filteredCount > 23) {
            storeOptions.push({
              label: 'Search Stores',
              value: 'search_stores',
              description: `Showing 23 of ${filteredCount} matches. Search again to refine.`,
              emoji: { name: 'üîç' }
            });
          }

          // Calculate how many stores we can show
          // We have Create New (1) + potentially Search Again (1) + stores
          const maxStoresToShow = filteredCount > 23 ? 23 : (25 - storeOptions.length);

          // Add filtered stores (sorted by lastModified desc)
          Object.entries(filteredStores)
            .sort(([, a], [, b]) => (b.metadata?.lastModified || b.metadata?.createdAt || 0) - (a.metadata?.lastModified || a.metadata?.createdAt || 0))
            .slice(0, maxStoresToShow)
            .forEach(([storeId, store]) => {
              const itemCount = store.items?.length || 0;
              const { cleanText, emoji } = parseTextEmoji(`${store.emoji || ''} ${store.name}`, 'üè™');
              const safeCleanText = cleanText || `${store.emoji || 'üè™'} ${store.name || 'Unnamed Store'}`;
              storeOptions.push({
                label: safeCleanText.slice(0, 100),
                value: storeId,
                description: (() => {
                  const storeDesc = store.description?.trim();
                  const descSuffix = storeDesc ? ` ¬∑ ${storeDesc}` : '';
                  const base = `${itemCount} items`;
                  return (base + descSuffix).length > 100
                    ? (base + descSuffix).slice(0, 98) + '..'
                    : base + descSuffix;
                })(),
                emoji: emoji
              });
            });
        }

        // Create select menu with filtered results
        const storeSelect = new StringSelectMenuBuilder()
          .setCustomId('safari_store_items_select')
          .setPlaceholder(searchTerm ? `Results for "${searchTerm.slice(0, 30)}"` : 'Select a store')
          .setMinValues(1)
          .setMaxValues(1)
          .addOptions(storeOptions);

        const selectRow = new ActionRowBuilder().addComponents(storeSelect);

        // Create back button
        const backButton = new ButtonBuilder()
          .setCustomId('prod_safari_menu')
          .setLabel('‚Üê Safari')
          .setStyle(ButtonStyle.Secondary)
          .setEmoji('ü¶Å');

        const backRow = new ActionRowBuilder().addComponents(backButton);

        // Create container with filtered results
        const container = {
          type: 17, // Container
          components: [
            {
              type: 10, // TextDisplay
              content: searchTerm
                ? `## üîç Search Results for "${searchTerm.slice(0, 50)}"\n\nFound ${filteredCount} matching store${filteredCount !== 1 ? 's' : ''}.`
                : `## üì¶ All Stores\n\nShowing all ${filteredCount} store${filteredCount !== 1 ? 's' : ''}.`
            },
            {
              type: 14 // Separator
            },
            selectRow.toJSON(),
            backRow.toJSON()
          ]
        };

        // Send UPDATE_MESSAGE with search results
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            content: '',
            embeds: [],
            components: [container],
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL // IS_COMPONENTS_V2 + EPHEMERAL
          }
        });

      } catch (error) {
        console.error('Error searching stores:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error searching stores. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_store_location_search_modal_')) {
      // Handle location store search modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const components = req.body.data.components;
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to search stores.')) return;

        // Extract entityId from custom_id
        const entityId = custom_id.replace('safari_store_location_search_modal_', '');

        // Get search term from modal
        const searchTerm = components[0].components[0].value?.trim().toLowerCase() || '';
        console.log(`üîç DEBUG: Searching location stores for ${entityId} with term: "${searchTerm}"`);

        // Use the store selector with search term
        const { createStoreSelectionUI } = await import('./storeSelector.js');
        const { loadSafariContent } = await import('./safariManager.js');

        // Load current stores for this location
        const safariData = await loadSafariContent();
        const activeMapId = safariData[guildId]?.maps?.active;
        const coordStores = safariData[guildId]?.maps?.[activeMapId]?.coordinates?.[entityId]?.stores || [];

        // Create filtered store selector
        const ui = await createStoreSelectionUI({
          guildId: guildId,
          action: 'add_to_location',
          entityId: entityId,
          preSelectedStores: coordStores,
          title: `üîç Search Results for ${entityId}`,
          backButtonId: `entity_view_mode_map_cell_${entityId}`,
          backButtonLabel: '‚Üê Back',
          backButtonEmoji: 'üìç',
          searchTerm: searchTerm  // Pass search term for filtering
        });

        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: ui
        });
      } catch (error) {
        console.error('Error handling location store search modal:', error);
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            content: '‚ùå Error searching stores. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_store_edit_modal_')) {
      // Handle Safari store edit modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to edit stores.')) return;
        
        // Parse storeId from custom_id
        const storeId = custom_id.replace('safari_store_edit_modal_', '');
        console.log(`‚úèÔ∏è DEBUG: Processing store edit for ${storeId}`);
        
        // Extract form data from Label-wrapped components (component singular, not components array)
        // Fallback to ActionRow format for backwards compatibility
        const getVal = (comp) => (comp?.component?.value ?? comp?.components?.[0]?.value)?.trim() || null;
        const storeName = getVal(components[0]);
        const storeEmoji = getVal(components[1]);
        const storeownerText = getVal(components[2]); // Greeting moved to index 2
        const storeDescription = getVal(components[3]); // Description moved to index 3
        
        // Validate required fields
        if (!storeName) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store name is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Import Safari manager functions
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        
        // Check if store exists
        if (!safariData[guildId]?.stores?.[storeId]) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Update store data while preserving existing metadata
        const existingStore = safariData[guildId].stores[storeId];
        safariData[guildId].stores[storeId] = {
          ...existingStore,
          name: storeName,
          emoji: storeEmoji || existingStore.emoji, // Preserve existing if blank (custom emojis can't pre-fill in Labels)
          description: storeDescription,
          settings: {
            ...existingStore.settings,
            storeownerText: storeownerText
          },
          metadata: {
            ...existingStore.metadata,
            lastModified: Date.now()
          }
        };
        
        // Save updated data
        await saveSafariContent(safariData);
        
        console.log(`‚úÖ DEBUG: Store ${storeId} updated successfully`);
        
        // Redirect back to store management UI with updated store data
        const { createStoreItemManagementUI } = await import('./entityManagementUI.js');
        
        const updatedStore = safariData[guildId].stores[storeId];
        const uiResponse = await createStoreItemManagementUI({
          storeId: storeId,
          store: updatedStore,
          guildId: guildId,
          searchTerm: '' // Clear any search
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: uiResponse
        });
        
      } catch (error) {
        console.error('Error updating store:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating store. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_store_stock_modal_')) {
      // Handle Safari store stock management modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to manage stock.')) return;
        
        // Parse storeId from custom_id
        const storeId = custom_id.replace('safari_store_stock_modal_', '');
        console.log(`üì¶ DEBUG: Processing stock update for store ${storeId}`);
        
        // Extract selected item and new stock quantity from modal
        let selectedItemId = null;
        let stockQuantityStr = null;
        
        // Modal has Label components with nested string select and text input
        for (const component of components) {
          if (component.component?.type === 3) { // String Select in Label
            selectedItemId = component.component.values?.[0];
          } else if (component.component?.type === 4) { // Text Input in Label
            stockQuantityStr = component.component.value?.trim();
          }
        }
        
        // Validate we got both inputs
        if (!selectedItemId || stockQuantityStr === null || stockQuantityStr === '') {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Both item selection and stock quantity are required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Parse and validate stock quantity
        let newStock;
        if (stockQuantityStr === '-1' || stockQuantityStr.toLowerCase() === 'unlimited') {
          newStock = -1; // Unlimited
        } else {
          newStock = parseInt(stockQuantityStr, 10);
          if (isNaN(newStock)) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Invalid stock quantity. Please enter a number (-1 for unlimited, 0 for out of stock, or a positive number).',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          if (newStock < -1) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Stock quantity cannot be less than -1. Use -1 for unlimited stock.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
        }
        
        // Import Safari manager functions
        const { updateItemStock, loadSafariContent } = await import('./safariManager.js');
        
        // Update the stock
        await updateItemStock(guildId, storeId, selectedItemId, newStock);
        
        console.log(`‚úÖ Updated stock for item ${selectedItemId} in store ${storeId} to ${newStock}`);
        
        // Reload safari data to get updated store
        const safariData = await loadSafariContent();
        const updatedStore = safariData[guildId]?.stores?.[storeId];
        const items = safariData[guildId]?.items || {};
        const item = items[selectedItemId];
        
        // Get stock display for confirmation message
        let stockDisplay;
        if (newStock === -1) {
          stockDisplay = 'Unlimited';
        } else if (newStock === 0) {
          stockDisplay = 'Out of Stock';
        } else {
          stockDisplay = `${newStock} in stock`;
        }
        
        // Redirect back to store management UI with updated store data
        const { createStoreItemManagementUI } = await import('./entityManagementUI.js');
        
        const uiResponse = await createStoreItemManagementUI({
          storeId: storeId,
          store: updatedStore,
          guildId: guildId,
          searchTerm: '' // Clear any search
        });
        
        // Add success message to the response
        if (uiResponse.components && uiResponse.components[0]) {
          // Insert success message after the title
          const successMessage = {
            type: 10, // Text Display
            content: `‚úÖ **Stock Updated!** ${item?.emoji || 'üì¶'} ${item?.name || 'Item'} is now **${stockDisplay}**`
          };
          
          // Insert after the title (position 1)
          uiResponse.components[0].components.splice(1, 0, successMessage);
        }
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: uiResponse
        });
        
      } catch (error) {
        console.error('Error updating stock:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating stock. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_item_modal') {
      // Handle Safari item creation modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to create items.')) return;
        
        // Extract form data - Updated for Challenge Game Logic
        const components = req.body.data.components;
        const itemName = components[0].components[0].value?.trim();
        const priceStr = components[1].components[0].value?.trim();
        const goodOutcomeStr = components[2].components[0].value?.trim() || '';
        const badOutcomeStr = components[3].components[0].value?.trim() || '';
        const attackValueStr = components[4].components[0].value?.trim() || '';
        
        // Validate required fields
        if (!itemName) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Item name is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Validate price
        const price = parseInt(priceStr, 10);
        if (isNaN(price) || price < 0 || price > 999999) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Price must be a number between 0 and 999,999.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Validate and parse game values
        const validateGameValue = (value, fieldName) => {
          if (!value || value.trim() === '') return null; // Allow blank
          const num = parseInt(value.trim(), 10);
          if (isNaN(num) || num < 0 || num > 999999) {
            throw new Error(`${fieldName} must be a number between 0 and 999,999.`);
          }
          return num;
        };
        
        let goodOutcomeValue = null;
        let badOutcomeValue = null;
        let attackValue = null;
        
        try {
          goodOutcomeValue = validateGameValue(goodOutcomeStr, 'Good Outcome Yield');
          badOutcomeValue = validateGameValue(badOutcomeStr, 'Bad Outcome Yield');
          attackValue = validateGameValue(attackValueStr, 'Attack Power');
        } catch (validationError) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚ùå Validation Error: ${validationError.message}`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`üéí DEBUG: Creating item "${itemName}" for guild ${guildId} with game values: good=${goodOutcomeValue}, bad=${badOutcomeValue}, attack=${attackValue}`);
        
        // Import Safari manager functions
        const { createItem } = await import('./safariManager.js');
        
        // Create item with enhanced game data
        const result = await createItem(guildId, {
          name: itemName,
          emoji: 'üì¶', // Default emoji, can be customized later
          description: `Game item for Challenge system`, // Default description
          basePrice: price,
          category: 'General', // Default category
          // Challenge Game Logic fields
          goodOutcomeValue: goodOutcomeValue,
          badOutcomeValue: badOutcomeValue,
          attackValue: attackValue,
          defenseValue: null, // Will be added in advanced settings
          consumable: 'No', // Default to No
          goodYieldEmoji: '‚òÄÔ∏è', // Default emoji
          badYieldEmoji: '‚òÑÔ∏è', // Default emoji
          createdBy: member.user.id
        });
        
        // Build success message showing game mechanics
        let successMessage = `‚úÖ **Game Item Created Successfully!**\n\n**üì¶ ${itemName}**\n\n**Base Price:** ${price} coins`;
        
        if (goodOutcomeValue !== null || badOutcomeValue !== null) {
          successMessage += `\n\n**Yield Values:**`;
          if (goodOutcomeValue !== null) successMessage += `\n‚òÄÔ∏è Good Event: ${goodOutcomeValue} coins`;
          if (badOutcomeValue !== null) successMessage += `\n‚òÑÔ∏è Bad Event: ${badOutcomeValue} coins`;
        }
        
        if (attackValue !== null) {
          successMessage += `\n\n**Combat:**`;
          successMessage += `\n‚öîÔ∏è Attack: ${attackValue}`;
        }
        
        successMessage += `\n\nItem ID: \`${result}\`\n\nüí° Use "Manage Items" to add defense values, consumable status, and customize emojis.\n\nYou can now add this item to stores and use it in the Challenge Game!`;
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: successMessage,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error creating item:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error creating item. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_properties_modal_')) {
      // Handle properties edit modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to edit properties.')) return;
        
        const buttonId = custom_id.replace('safari_properties_modal_', '');
        console.log(`üîß DEBUG: Processing properties update for button ${buttonId}`);
        
        // Extract field values
        const label = components[0].components[0].value?.trim();
        const emoji = components[1].components[0].value?.trim() || '';
        const style = components[2]?.components[0]?.value?.trim() || 'Primary';
        const tagsString = components[3]?.components[0]?.value?.trim() || '';
        
        if (!label) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Button label is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Parse tags
        const tags = tagsString ? tagsString.split(',').map(t => t.trim()).filter(t => t) : [];
        
        // Update button properties
        const { updateButtonProperties } = await import('./safariManager.js');
        const success = await updateButtonProperties(guildId, buttonId, {
          label,
          emoji,
          style,
          tags
        });
        
        if (!success) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Failed to update button properties.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Return to edit interface
        const { getCustomButton } = await import('./safariManager.js');
        const { EditInterfaceBuilder, EDIT_TYPES } = await import('./editFramework.js');
        
        const button = await getCustomButton(guildId, buttonId);
        const editBuilder = new EditInterfaceBuilder(EDIT_TYPES.BUTTON);
        const editInterface = editBuilder.createEditInterface(button, buttonId);
        
        // Add back button
        editInterface.components[0].components.push({
          type: 1, // Action Row
          components: [{
            type: 2, // Button
            custom_id: 'safari_button_manage_existing',
            label: '‚¨Ö Back to Button List',
            style: 2,
            emoji: { name: 'üîô' }
          }]
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: editInterface
        });
        
      } catch (error) {
        console.error('Error updating button properties:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating button properties.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('safari_edit_action_modal_')) {
      // Handle action edit modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to edit actions.')) return;
        
        // Parse custom_id: safari_edit_action_modal_buttonId_actionIndex_actionType
        const parts = custom_id.replace('safari_edit_action_modal_', '').split('_');
        const actionType = parts[parts.length - 1];
        const actionIndex = parseInt(parts[parts.length - 2]);
        const buttonId = parts.slice(0, -2).join('_');
        
        console.log(`üîß DEBUG: Processing ${actionType} action edit for button ${buttonId}, action ${actionIndex}`);
        
        let actionConfig = {};
        
        if (actionType === 'display_text') {
          const title = components[0].components[0].value?.trim() || null;
          const content = components[1].components[0].value?.trim();
          const colorStr = components[2].components[0].value?.trim();
          const imageUrl = components[3].components[0].value?.trim() || null;
          
          if (!content) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Content is required for text display actions.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          actionConfig = {
            title: title,
            content: content
          };
          
          // Add imageUrl if provided
          if (imageUrl) {
            actionConfig.imageUrl = imageUrl;
          }
          
          // Parse color if provided
          if (colorStr) {
            let accentColor = null;
            if (colorStr.startsWith('#')) {
              accentColor = parseInt(colorStr.slice(1), 16);
            } else if (/^[0-9a-fA-F]{6}$/.test(colorStr)) {
              accentColor = parseInt(colorStr, 16);
            } else if (/^\d+$/.test(colorStr)) {
              accentColor = parseInt(colorStr);
            }
            if (accentColor !== null && !isNaN(accentColor) && accentColor >= 0 && accentColor <= 0xFFFFFF) {
              actionConfig.accentColor = accentColor;
            }
          }
          
        } else if (actionType === 'update_currency') {
          const amountStr = components[0].components[0].value?.trim();
          const message = components[1].components[0].value?.trim() || '';
          
          const amount = parseInt(amountStr);
          if (isNaN(amount)) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Currency amount must be a valid number.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          actionConfig = { amount, message };
        }
        
        // Update the action
        const { updateButtonAction } = await import('./safariManager.js');
        const success = await updateButtonAction(guildId, buttonId, actionIndex, {
          type: actionType,
          config: actionConfig
        });
        
        if (!success) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Failed to update action.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Return to edit interface
        const { getCustomButton } = await import('./safariManager.js');
        const { EditInterfaceBuilder, EDIT_TYPES } = await import('./editFramework.js');
        
        const button = await getCustomButton(guildId, buttonId);
        const editBuilder = new EditInterfaceBuilder(EDIT_TYPES.BUTTON);
        const editInterface = editBuilder.createEditInterface(button, buttonId);
        
        // Add back button
        editInterface.components[0].components.push({
          type: 1, // Action Row
          components: [{
            type: 2, // Button
            custom_id: 'safari_button_manage_existing',
            label: '‚¨Ö Back to Button List',
            style: 2,
            emoji: { name: 'üîô' }
          }]
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: editInterface
        });
        
      } catch (error) {
        console.error('Error updating action:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating action.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    // LEGACY HANDLER - COMMENTED OUT: safari_customize_terms_modal
    // This modal handler has been replaced by the new Components V2 field group interface
    // Remove after confirming new system works properly
    /*
    } else if (custom_id === 'safari_customize_terms_modal') {
      // Handle Safari terms customization modal - LEGACY IMPLEMENTATION
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to customize Safari terms.')) return;
        
        // Extract modal input values from comprehensive Safari settings
        const components = req.body.data.components;
        const gameSettings = components[0]?.components[0]?.value || '75,50,25';
        const eventNames = components[1]?.components[0]?.value || 'Clear Skies,Meteor Strike';
        const eventEmojis = components[2]?.components[0]?.value || '‚òÄÔ∏è,‚òÑÔ∏è';
        const currencySettings = components[3]?.components[0]?.value || 'Dollars,ü™ô';
        const inventoryName = components[4]?.components[0]?.value || 'Inventory';
        
        // Parse comma-separated values
        const parseCommaSeparated = (value, expectedCount, fieldName) => {
          if (!value || value.trim() === '') return new Array(expectedCount).fill(null);
          const parts = value.split(',').map(p => p.trim());
          if (parts.length !== expectedCount) {
            throw new Error(`${fieldName} must have exactly ${expectedCount} comma-separated values.`);
          }
          return parts;
        };
        
        let round1Good = null, round2Good = null, round3Good = null;
        let goodEventName = 'Clear Skies', badEventName = 'Meteor Strike';
        let goodEventEmoji = '‚òÄÔ∏è', badEventEmoji = '‚òÑÔ∏è';
        let currencyName = 'coins', currencyEmoji = 'ü™ô';
        
        try {
          // Parse game settings (probabilities)
          if (gameSettings && gameSettings.trim() !== '') {
            const probabilities = parseCommaSeparated(gameSettings, 3, 'Game Settings');
            for (let i = 0; i < 3; i++) {
              if (probabilities[i] && probabilities[i] !== '') {
                const num = parseInt(probabilities[i], 10);
                if (isNaN(num) || num < 0 || num > 100) {
                  throw new Error(`Round ${i + 1} probability must be between 0 and 100.`);
                }
                if (i === 0) round1Good = num;
                if (i === 1) round2Good = num;
                if (i === 2) round3Good = num;
              }
            }
          }
          
          // Parse event names
          if (eventNames && eventNames.trim() !== '') {
            const names = parseCommaSeparated(eventNames, 2, 'Event Names');
            goodEventName = names[0] || 'Clear Skies';
            badEventName = names[1] || 'Meteor Strike';
          }
          
          // Parse event emojis
          if (eventEmojis && eventEmojis.trim() !== '') {
            const emojis = parseCommaSeparated(eventEmojis, 2, 'Event Emojis');
            goodEventEmoji = emojis[0] || '‚òÄÔ∏è';
            badEventEmoji = emojis[1] || '‚òÑÔ∏è';
          }
          
          // Parse currency settings
          if (currencySettings && currencySettings.trim() !== '') {
            const currency = parseCommaSeparated(currencySettings, 2, 'Currency Settings');
            currencyName = currency[0] || 'coins';
            currencyEmoji = currency[1] || 'ü™ô';
          }
          
        } catch (validationError) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚ùå Validation Error: ${validationError.message}`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`‚öôÔ∏è DEBUG: Customizing Safari settings for guild ${guildId}: Currency="${currencyName}:${currencyEmoji}", Events="${goodEventName}:${badEventName}", Rounds="${round1Good},${round2Good},${round3Good}"`);
        
        // Import Safari manager functions
        const { updateCustomTerms } = await import('./safariManager.js');
        
        // Update all Safari settings
        const updateData = {
          currencyName: currencyName,
          inventoryName: inventoryName,
          currencyEmoji: currencyEmoji,
          goodEventName: goodEventName,
          badEventName: badEventName,
          goodEventEmoji: goodEventEmoji,
          badEventEmoji: badEventEmoji
        };
        
        // Add round probabilities if provided
        if (round1Good !== null) updateData.round1GoodProbability = round1Good;
        if (round2Good !== null) updateData.round2GoodProbability = round2Good;
        if (round3Good !== null) updateData.round3GoodProbability = round3Good;
        
        const success = await updateCustomTerms(guildId, updateData);
        
        if (!success) {
          throw new Error('Failed to update custom terms');
        }
        
        console.log(`‚úÖ DEBUG: Safari settings updated successfully for guild ${guildId}`);
        
        // Build comprehensive success message
        let successMessage = `‚úÖ **Safari Settings Updated!**\n\n**Currency:** ${currencyEmoji} ${currencyName}\n**Inventory:** ${inventoryName}`;
        
        successMessage += `\n\n**Events:**\n‚Ä¢ Good: ${goodEventEmoji} ${goodEventName}\n‚Ä¢ Bad: ${badEventEmoji} ${badEventName}`;
        
        if (round1Good !== null || round2Good !== null || round3Good !== null) {
          successMessage += `\n\n**Round Harvest Probabilities:**`;
          if (round1Good !== null) successMessage += `\n‚Ä¢ Round 1: ${round1Good}% good`;
          if (round2Good !== null) successMessage += `\n‚Ä¢ Round 2: ${round2Good}% good`;
          if (round3Good !== null) successMessage += `\n‚Ä¢ Round 3: ${round3Good}% good`;
        }
        
        successMessage += `\n\nüéÆ All settings configured for Challenge Game Logic!`;
        
        // Return success message
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: successMessage,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error updating Safari terms:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating Safari terms. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    */
    } else if (custom_id.startsWith('safari_config_modal_')) {
      // Handle field group modal submissions - Currency, Events, Rounds
      try {
        const guildId = req.body.guild_id;
        const member = req.body.member;
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to customize Safari terms.')) return;
        
        // Extract group key from custom_id (safari_config_modal_currency -> currency)
        const groupKey = custom_id.replace('safari_config_modal_', '');
        
        console.log(`‚öôÔ∏è DEBUG: Processing field group modal submission for ${groupKey}`);
        
        // Process modal submission
        const { processFieldGroupSubmission } = await import('./safariConfigUI.js');
        const updates = processFieldGroupSubmission(groupKey, req.body.data);
        
        // If updating inventory emoji, parse it properly
        if (updates.inventoryEmoji) {
          const { parseTextEmoji } = await import('./utils/emojiUtils.js');
          const { cleanText, emoji } = parseTextEmoji(updates.inventoryEmoji, 'üß∞');
          // Use the emoji name if it's a valid emoji, otherwise default to üß∞
          updates.inventoryEmoji = emoji.name || 'üß∞';
        }

        // Validate defaultStartingCoordinate if present (from Rounds & Location modal)
        if (groupKey === 'rounds' && updates.defaultStartingCoordinate) {
          const coordinate = updates.defaultStartingCoordinate.trim().toUpperCase();

          // Coordinate Format validation
          const coordinatePattern = /^[A-Z][0-9]{1,2}$/;
          if (!coordinatePattern.test(coordinate)) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå Invalid coordinate format: "${coordinate}" (use A1, B3, G7, etc.)`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }

          // Coordinate Exists in Active Map validation
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[guildId]?.maps?.active;

          console.log(`üó∫Ô∏è DEBUG: Coordinate validation - checking "${coordinate}"`);
          console.log(`üó∫Ô∏è DEBUG: activeMapId = ${activeMapId}`);

          if (!activeMapId) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå No active map found - create a map first before setting starting coordinate',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }

          // Get map data - coordinates are nested under mapData.coordinates
          const mapData = safariData[guildId]?.maps?.configurations?.[activeMapId]
                       || safariData[guildId]?.maps?.[activeMapId];

          if (!mapData) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Could not find map data for active map',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }

          // Coordinates are nested under mapData.coordinates
          const coordinates = mapData.coordinates || {};

          if (!coordinates[coordinate]) {
            const available = Object.keys(coordinates).filter(k => /^[A-Z][0-9]{1,2}$/.test(k)).slice(0, 10).join(', ');
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå Coordinate "${coordinate}" not found in active map.\n\nAvailable coordinates: ${available}`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }

          console.log(`‚úÖ Coordinate "${coordinate}" validated successfully in map "${mapData.name}"`);

          // Update with uppercase version
          updates.defaultStartingCoordinate = coordinate;
        }

        // Validate and parse defaultStartingCurrencyValue if present
        if (updates.defaultStartingCurrencyValue !== undefined) {
          const value = String(updates.defaultStartingCurrencyValue).trim();
          
          // Check if it's a valid whole number
          if (!/^\d+$/.test(value)) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Default Starting Currency must be a whole number (e.g., 100, 250, 1000)',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          const parsed = parseInt(value, 10);
          if (isNaN(parsed) || parsed < 0 || parsed > 100000) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Default Starting Currency must be between 0 and 100,000',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          updates.defaultStartingCurrencyValue = parsed;
        }
        
        // Update Safari settings using existing function
        const { updateCustomTerms } = await import('./safariManager.js');
        const success = await updateCustomTerms(guildId, updates);
        
        if (!success) {
          throw new Error('Failed to update Safari settings');
        }
        
        console.log(`‚úÖ DEBUG: Safari ${groupKey} settings updated successfully for guild ${guildId}:`, updates);
        
        // Get updated custom terms and return refreshed interface
        const { getCustomTerms } = await import('./safariManager.js');
        const updatedTerms = await getCustomTerms(guildId);
        
        // Create updated Safari customization interface
        const { createSafariCustomizationUI } = await import('./safariConfigUI.js');
        const interfaceData = await createSafariCustomizationUI(guildId, updatedTerms);
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: interfaceData
        });
        
      } catch (error) {
        console.error('Error updating Safari field group:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating Safari settings. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'stamina_location_config_modal') {
      // Handle per-server stamina & location configuration modal submission
      try {
        const guildId = req.body.guild_id;
        const member = req.body.member;
        const userId = member.user.id;

        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to configure stamina settings.')) return;

        // Extract modal values from Label components (Components V2 format)
        const components = req.body.data.components;

        // Skip Text Display (index 0), extract from Label components
        const startingStaminaValue = components[1]?.component?.value;
        const maxStaminaValue = components[2]?.component?.value;
        const regenMinutesValue = components[3]?.component?.value;

        // Parse values
        const startingStamina = parseInt(startingStaminaValue);
        const maxStamina = parseInt(maxStaminaValue);
        const regenMinutes = parseInt(regenMinutesValue);

        // Validation Chain
        const errors = [];

        // 1. Starting Stamina (0-99)
        if (isNaN(startingStamina) || startingStamina < 0 || startingStamina > 99) {
          errors.push(`Starting Stamina must be 0-99 (got "${startingStaminaValue}")`);
        }

        // 2. Max Stamina (1-99, must be >= starting)
        if (isNaN(maxStamina) || maxStamina < 1 || maxStamina > 99) {
          errors.push(`Max Stamina must be 1-99 (got "${maxStaminaValue}")`);
        } else if (maxStamina < startingStamina) {
          errors.push(`Max Stamina (${maxStamina}) must be >= Starting Stamina (${startingStamina})`);
        }

        // 3. Regen Minutes (1-1440 = max 1 day)
        if (isNaN(regenMinutes) || regenMinutes < 1 || regenMinutes > 1440) {
          errors.push(`Regen Time must be 1-1440 minutes (got "${regenMinutesValue}")`);
        }

        // If errors, show ephemeral error message
        if (errors.length > 0) {
          console.log(`‚ùå Validation errors in stamina & location config: ${errors.join('; ')}`);
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå **Validation Errors**\n\n' + errors.map(e => `‚Ä¢ ${e}`).join('\n'),
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        console.log(`‚ö° DEBUG: Updating stamina config for guild ${guildId} - Starting: ${startingStamina}, Max: ${maxStamina}, Regen: ${regenMinutes}min`);

        // Save to safariConfig (per-server configuration)
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();

        if (!safariData[guildId]) safariData[guildId] = {};
        if (!safariData[guildId].safariConfig) safariData[guildId].safariConfig = {};

        safariData[guildId].safariConfig.startingStamina = startingStamina;
        safariData[guildId].safariConfig.maxStamina = maxStamina;
        safariData[guildId].safariConfig.staminaRegenerationMinutes = regenMinutes;

        await saveSafariContent(safariData);

        console.log(`‚úÖ SUCCESS: Stamina config updated for guild ${guildId} (changes take effect immediately)`);

        // Refresh the Settings UI (matches pattern of other modal handlers)
        const { getCustomTerms } = await import('./safariManager.js');
        const updatedConfig = await getCustomTerms(guildId);

        const { createSafariCustomizationUI } = await import('./safariConfigUI.js');
        const customizationUI = await createSafariCustomizationUI(guildId, updatedConfig);

        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: customizationUI
        });

      } catch (error) {
        console.error('Error updating stamina & location config:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Error updating stamina settings: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_player_menu_config_modal') {
      // Handle Player Menu configuration modal submission
      try {
        const member = req.body.member;
        const userId = member.user.id;
        const guildId = req.body.guild_id;

        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to configure player menu settings.')) return;

        console.log(`üïπÔ∏è DEBUG: User ${userId} submitting player menu config for guild ${guildId}`);

        // Extract values from Label components with String Select (following safari_store_stock pattern)
        const components = req.body.data.components;
        let enableGlobalCommands = false;
        let inventoryVisibilityMode = 'standard';
        let showCustomCastlists = true; // Default true (show all)
        let globalStoresVisibilityMode = 'always';
        let selectedGlobalStores = null; // null = not submitted (field absent when no stores exist)

        // Modal has Label components with nested string selects - extract all
        for (const component of components) {
          if (component.component?.type === 3) { // String Select in Label
            const customId = component.component.custom_id;
            const selectedValues = component.component.values || [];
            const selectedValue = selectedValues[0];

            if (customId === 'enable_global_commands') {
              enableGlobalCommands = selectedValue === 'true';
            } else if (customId === 'inventory_visibility_mode') {
              inventoryVisibilityMode = selectedValue || 'standard';
            } else if (customId === 'show_custom_castlists') {
              showCustomCastlists = selectedValue === 'true';
            } else if (customId === 'global_stores_visibility_mode') {
              globalStoresVisibilityMode = selectedValue || 'always';
            } else if (customId === 'global_stores_select_modal') {
              selectedGlobalStores = selectedValues; // Multi-select ‚Äî keep all values
            }
          }
        }

        console.log(`üïπÔ∏è DEBUG: enableGlobalCommands setting: ${enableGlobalCommands}`);
        console.log(`üïπÔ∏è DEBUG: inventoryVisibilityMode setting: ${inventoryVisibilityMode}`);
        console.log(`üïπÔ∏è DEBUG: showCustomCastlists setting: ${showCustomCastlists}`);
        console.log(`üïπÔ∏è DEBUG: globalStoresVisibilityMode setting: ${globalStoresVisibilityMode}`);
        console.log(`üïπÔ∏è DEBUG: selectedGlobalStores: ${selectedGlobalStores === null ? '(field absent)' : selectedGlobalStores.join(', ') || '(none)'}`);

        // Load and update safari configuration
        const { loadSafariContent, saveSafariContent, MAX_GLOBAL_STORES } = await import('./safariManager.js');
        const safariData = await loadSafariContent();

        // Ensure safariConfig exists
        if (!safariData[guildId]) {
          safariData[guildId] = {};
        }
        if (!safariData[guildId].safariConfig) {
          safariData[guildId].safariConfig = {};
        }

        // Update the configuration
        safariData[guildId].safariConfig.enableGlobalCommands = enableGlobalCommands;
        safariData[guildId].safariConfig.inventoryVisibilityMode = inventoryVisibilityMode;
        safariData[guildId].safariConfig.showCustomCastlists = showCustomCastlists;
        safariData[guildId].safariConfig.globalStoresVisibilityMode = globalStoresVisibilityMode;
        // Only update globalStores if the field was present in the modal (stores exist)
        if (selectedGlobalStores !== null) {
          safariData[guildId].globalStores = selectedGlobalStores.slice(0, MAX_GLOBAL_STORES);
        }
        await saveSafariContent(safariData);

        const updatedConfig = safariData[guildId].safariConfig;

        console.log(`‚úÖ SUCCESS: Player menu configuration updated for guild ${guildId}`);

        // Refresh customization UI with updated config (consistent with other field group modals)
        const { createSafariCustomizationUI } = await import('./safariConfigUI.js');
        const customizationUI = await createSafariCustomizationUI(guildId, updatedConfig);

        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: customizationUI
        });

      } catch (error) {
        console.error('Error updating player menu config:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Error updating player menu settings: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'global_create_modal_safari_button_info') {
      // Handle global custom action creation modal (no coordinate)
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        
        console.log(`üìù DEBUG: Global custom action creation modal submit - User: ${userId}`);
        
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES)) return;
        
        // Parse fields from modal (Label/type-18 format with ActionRow fallback)
        const getModalVal = (comp) => (comp?.component?.value ?? comp?.components?.[0]?.value)?.trim() || null;
        const buttonLabel = getModalVal(components[0]);
        const buttonEmojiInput = getModalVal(components[1]);
        const buttonDesc = getModalVal(components[2]);

        // Validate emoji using advanced parsing (for error checking only)
        let buttonEmoji = null;
        if (buttonEmojiInput) {
          const { createSafeEmoji } = await import('./safariButtonHelper.js');
          const validatedEmoji = await createSafeEmoji(buttonEmojiInput);
          if (validatedEmoji) {
            // Store the original input string - safariButtonHelper will process it later
            buttonEmoji = buttonEmojiInput;
            console.log(`‚úÖ Validated emoji input: "${buttonEmojiInput}"`);
          } else {
            console.warn(`‚ö†Ô∏è Invalid emoji input: "${buttonEmojiInput}", will be ignored`);
            buttonEmoji = null;
          }
        }

        if (!buttonLabel) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action name is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Create button using existing button creation logic
        const { createButton, loadSafariContent, saveSafariContent } = await import('./safariManager.js');

        // Generate unique ID using existing pattern
        const timestamp = Date.now();
        const buttonId = `${buttonLabel.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '')}_${timestamp}`;

        const button = {
          name: buttonLabel,
          label: buttonLabel,
          description: buttonDesc || '',
          emoji: buttonEmoji,
          style: 1, // Primary
          coordinates: [], // No coordinates initially
          actions: [],
          trigger: {
            type: 'button'
          },
          metadata: {
            createdBy: userId,
            lastModified: timestamp,
            usageCount: 0
          }
        };
        
        // Save the new button
        const allSafariContent = await loadSafariContent();
        if (!allSafariContent[guildId]) {
          allSafariContent[guildId] = { buttons: {} };
        }
        if (!allSafariContent[guildId].buttons) {
          allSafariContent[guildId].buttons = {};
        }
        
        allSafariContent[guildId].buttons[buttonId] = button;
        await saveSafariContent(allSafariContent);
        
        console.log(`‚úÖ DEBUG: Created global custom action ${buttonId}`);
        
        // Show Custom Action Editor for the new button
        const { createCustomActionEditorUI } = await import('./customActionUI.js');
        const ui = await createCustomActionEditorUI({
          guildId,
          actionId: buttonId
          // No coordinate for global editor
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            ...ui,
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in global_create_modal_safari_button_info handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error creating custom action.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('clone_action_modal_')) {
      // Handle clone action modal submission
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;

        console.log(`üîÑ DEBUG: Clone action modal submit - User: ${userId}`);

        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES)) return;

        // Parse custom_id: clone_action_modal_{sourceActionId}_{coordinate} or clone_action_modal_{sourceActionId}_global
        const withoutPrefix = custom_id.replace('clone_action_modal_', '');
        const lastUnderscoreIndex = withoutPrefix.lastIndexOf('_');
        const sourceActionId = withoutPrefix.substring(0, lastUnderscoreIndex);
        const coordinateOrGlobal = withoutPrefix.substring(lastUnderscoreIndex + 1);
        const coordinate = coordinateOrGlobal === 'global' ? null : coordinateOrGlobal;

        console.log(`üîÑ DEBUG: Cloning from ${sourceActionId}, target coordinate: ${coordinate || 'global'}`);

        // Parse modal fields
        const cloneName = components[0].components[0].value?.trim();
        const cloneEmojiInput = components[1].components[0].value?.trim() || null;
        const cloneDesc = components[2].components[0].value?.trim() || null;

        if (!cloneName) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action name is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Validate emoji if provided
        let cloneEmoji = null;
        if (cloneEmojiInput) {
          const { createSafeEmoji } = await import('./safariButtonHelper.js');
          const validatedEmoji = await createSafeEmoji(cloneEmojiInput);
          if (validatedEmoji) {
            cloneEmoji = cloneEmojiInput;
            console.log(`‚úÖ Validated emoji input: "${cloneEmojiInput}"`);
          } else {
            console.warn(`‚ö†Ô∏è Invalid emoji input: "${cloneEmojiInput}", will be ignored`);
          }
        }

        // Load source action
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const allSafariContent = await loadSafariContent();
        const sourceAction = allSafariContent[guildId]?.buttons?.[sourceActionId];

        if (!sourceAction) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Source action not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Deep clone helper function
        const deepClone = (obj) => JSON.parse(JSON.stringify(obj));

        // Clone actions with claimedBy arrays reset
        const clonedActions = Array.isArray(sourceAction.actions) ? deepClone(sourceAction.actions).map(action => {
          // Reset claimedBy arrays in limit configs
          if (action.config?.limit?.claimedBy) {
            action.config.limit.claimedBy = [];
          }
          return action;
        }) : [];

        // Clone conditions, removing AT_LOCATION conditions (legacy/location-specific)
        const clonedConditions = Array.isArray(sourceAction.conditions)
          ? deepClone(sourceAction.conditions).filter(cond => cond.type !== 'AT_LOCATION')
          : [];

        // Clone trigger
        const clonedTrigger = sourceAction.trigger ? deepClone(sourceAction.trigger) : { type: 'button' };

        // Generate new unique ID
        const timestamp = Date.now();
        const newActionId = `${cloneName.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '')}_${timestamp}`;

        // Build the cloned action
        const clonedAction = {
          id: newActionId,
          name: cloneName,
          label: cloneName,
          description: cloneDesc || '',
          emoji: cloneEmoji,
          style: sourceAction.style || 1,
          actions: clonedActions,
          conditions: clonedConditions,
          trigger: clonedTrigger,
          coordinates: coordinate ? [coordinate] : [],
          menuVisibility: 'none', // Reset to hidden
          metadata: {
            createdBy: userId,
            createdAt: timestamp,
            lastModified: timestamp,
            usageCount: 0,
            clonedFrom: sourceActionId // Track clone source
          }
        };

        // Save the cloned action
        if (!allSafariContent[guildId]) {
          allSafariContent[guildId] = { buttons: {} };
        }
        if (!allSafariContent[guildId].buttons) {
          allSafariContent[guildId].buttons = {};
        }
        allSafariContent[guildId].buttons[newActionId] = clonedAction;

        // If coordinate provided, also add to map coordinate buttons array
        if (coordinate && allSafariContent[guildId].maps) {
          // Find the map that has this coordinate
          for (const [mapId, map] of Object.entries(allSafariContent[guildId].maps)) {
            if (map.coordinates && map.coordinates[coordinate]) {
              if (!map.coordinates[coordinate].buttons) {
                map.coordinates[coordinate].buttons = [];
              }
              if (!map.coordinates[coordinate].buttons.includes(newActionId)) {
                map.coordinates[coordinate].buttons.push(newActionId);
              }
              console.log(`üîÑ DEBUG: Added cloned action to ${coordinate} in map ${mapId}`);
              break;
            }
          }
        }

        await saveSafariContent(allSafariContent);

        console.log(`‚úÖ DEBUG: Created cloned action ${newActionId} from ${sourceActionId}`);

        // Queue anchor message update if coordinate was provided
        if (coordinate) {
          try {
            const { afterAddCoordinate } = await import('./anchorMessageIntegration.js');
            await afterAddCoordinate(guildId, newActionId, coordinate);
            console.log(`üìç DEBUG: clone_action_modal - queued anchor update for ${coordinate}`);
          } catch (error) {
            console.error('Error queueing anchor update:', error);
          }
        }

        // Show Custom Action Editor for the new cloned action
        const { createCustomActionEditorUI } = await import('./customActionUI.js');
        const ui = await createCustomActionEditorUI({
          guildId,
          actionId: newActionId,
          coordinate
        });

        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            ...ui,
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          }
        });

      } catch (error) {
        console.error('Error in clone_action_modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Error cloning action: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('entity_create_modal_')) {
      // Handle modal submission for entity creation
      try {
        // Parse: entity_create_modal_{entityType}_info[_{coordinate}]
        const withoutPrefix = custom_id.replace('entity_create_modal_', '');
        const parts = withoutPrefix.split('_');
        
        // Handle special case for safari_button with coordinate
        let entityType, fieldGroup, coordinate;
        if (parts[0] === 'safari' && parts[1] === 'button') {
          entityType = 'safari_button';
          fieldGroup = parts[2]; // Should be 'info'
          coordinate = parts[3]; // Optional coordinate
        } else {
          entityType = parts[0];
          fieldGroup = parts[parts.length - 1]; // Should be 'info'
          coordinate = null;
        }
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        
        console.log(`üìù DEBUG: Entity creation modal submit - Type: ${entityType}, Group: ${fieldGroup}, User: ${userId}`);
        
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES)) return;
        
        // Parse submission data using field editors
        const { parseModalSubmission, validateFields } = await import('./fieldEditors.js');
        const fields = parseModalSubmission(data, fieldGroup);
        const validation = validateFields(fields, entityType);
        
        if (!validation.valid) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚ùå ${validation.errors.join(', ')}`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Special handling for safari_button with coordinate
        if (entityType === 'safari_button' && coordinate) {
          // Parse fields from modal (Label/type-18 format with ActionRow fallback)
          const getModalVal = (comp) => (comp?.component?.value ?? comp?.components?.[0]?.value)?.trim() || null;
          const buttonLabel = getModalVal(components[0]);
          const buttonEmojiInput = getModalVal(components[1]);
          const buttonDesc = getModalVal(components[2]);
          
          // Validate emoji using advanced parsing (for error checking only)
          let buttonEmoji = null;
          if (buttonEmojiInput) {
            const { createSafeEmoji } = await import('./safariButtonHelper.js');
            const validatedEmoji = await createSafeEmoji(buttonEmojiInput);
            if (validatedEmoji) {
              // Store the original input string - safariButtonHelper will process it later
              buttonEmoji = buttonEmojiInput;
              console.log(`‚úÖ Validated emoji input: "${buttonEmojiInput}"`);
            } else {
              console.warn(`‚ö†Ô∏è Invalid emoji input: "${buttonEmojiInput}", will be ignored`);
              buttonEmoji = null;
            }
          }
          
          if (!buttonLabel) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Action name is required.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          // Create custom action using safariManager
          const { createCustomButton } = await import('./safariManager.js');
          const buttonId = await createCustomButton(guildId, {
            label: buttonLabel,
            emoji: buttonEmoji,
            style: 'Primary',
            actions: [],
            tags: buttonDesc ? [buttonDesc] : []
          }, userId);
          
          // Set name and description
          const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
          const allSafariContent = await loadSafariContent();
          const button = allSafariContent[guildId].buttons[buttonId];
          button.name = buttonLabel;
          button.description = buttonDesc || '';
          await saveSafariContent(allSafariContent);
          
          console.log(`‚úÖ DEBUG: Created custom action ${buttonId} for coordinate ${coordinate}`);
          
          // Show Custom Action Editor with the new button and pre-assigned coordinate
          const { createCustomActionEditorUI } = await import('./customActionUI.js');
          const ui = await createCustomActionEditorUI({
            guildId,
            actionId: buttonId,
            coordinate,
            skipAutoSave: false  // Allow auto-save to assign coordinate
          });
          
          // Add success note to the UI
          if (ui.components && ui.components[0] && ui.components[0].components) {
            const headerComponent = ui.components[0].components.find(c => c.type === 10);
            if (headerComponent) {
              headerComponent.content += `\n\n‚úÖ **Auto-assigned to location ${coordinate}**`;
            }
          }
          
          // Queue anchor message update for the coordinate
          try {
            const { afterAddCoordinate } = await import('./anchorMessageIntegration.js');
            await afterAddCoordinate(guildId, buttonId, coordinate);
            console.log(`üîç DEBUG: entity_create_modal - queued anchor update for ${coordinate}`);
          } catch (error) {
            console.error('Error queueing anchor update:', error);
          }
          
          return res.send({
            type: InteractionResponseType.UPDATE_MESSAGE,
            data: ui
          });
        }
        
        // Standard entity creation flow
        const { createEntity } = await import('./entityManager.js');
        const createdEntity = await createEntity(guildId, entityType, fields, userId);
        
        console.log(`‚úÖ DEBUG: Entity '${createdEntity.id}' created successfully`);
        
        // Redirect to edit interface for the newly created entity
        const { createEntityManagementUI } = await import('./entityManagementUI.js');
        const uiResponse = await createEntityManagementUI({
          entityType: entityType,
          guildId: guildId,
          selectedId: createdEntity.id,
          activeFieldGroup: null,
          searchTerm: '',
          mode: 'edit'
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: uiResponse
        });
        
      } catch (error) {
        console.error('Error in entity creation modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error creating entity. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('entity_edit_action_info_modal_')) {
      // Handle action info edit modal submission
      try {
        const actionId = custom_id.replace('entity_edit_action_info_modal_', '');
        const guildId = req.body.guild_id;
        // Parse fields (Label/type-18 format with ActionRow fallback)
        const getModalVal = (comp) => (comp?.component?.value ?? comp?.components?.[0]?.value)?.trim() || null;
        const actionName = getModalVal(components[0]);
        const actionEmoji = getModalVal(components[1]) || '';
        const actionDescription = getModalVal(components[2]) || '';
        
        console.log(`üìù Updating action ${actionId} with name: "${actionName}", emoji: "${actionEmoji}", description: "${actionDescription}"`);
        
        // Validate emoji using enhanced validation (same as Create modal)
        let validatedEmoji = null;
        if (actionEmoji) {
          // Import emoji validation function
          const { createSafeEmoji } = await import('./safariButtonHelper.js');
          const emojiResult = await createSafeEmoji(actionEmoji);
          if (emojiResult) {
            // Store the original input string - safariButtonHelper will process it later
            validatedEmoji = actionEmoji;
            console.log(`‚úÖ Validated emoji: ${emojiResult.name}${emojiResult.id ? ` (ID: ${emojiResult.id})` : ''}`);
          } else {
            console.warn(`‚ö†Ô∏è Invalid emoji provided: "${actionEmoji}", will be ignored`);
            validatedEmoji = null;
          }
        }
        
        // Load and update safari content
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const allSafariContent = await loadSafariContent();
        
        if (!allSafariContent[guildId]?.buttons?.[actionId]) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Update action info ‚Äî keep name, label, and trigger.button.label in sync
        const btn = allSafariContent[guildId].buttons[actionId];
        btn.name = actionName;
        btn.label = actionName; // label mirrors name until decoupled by design
        btn.emoji = validatedEmoji; // Store validated emoji (null if invalid/empty)
        btn.description = actionDescription;
        // Also sync trigger.button label + emoji so posted buttons and preview stay current
        if (btn.trigger?.button) {
          btn.trigger.button.label = actionName;
          btn.trigger.button.emoji = validatedEmoji; // null if cleared/invalid
        }
        
        await saveSafariContent(allSafariContent);
        
        // Update anchor messages for all coordinates using this action
        try {
          const { queueActionCoordinateUpdates } = await import('./anchorMessageManager.js');
          await queueActionCoordinateUpdates(guildId, actionId, 'action_info_updated');
        } catch (error) {
          console.error('Error queueing anchor updates:', error);
        }
        
        // Return to action editor
        const { createCustomActionEditorUI } = await import('./customActionUI.js');
        const ui = await createCustomActionEditorUI({
          guildId: guildId,
          actionId: actionId
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            ...ui,
            flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in entity_edit_action_info_modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating action info.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('modal_phrases_config_')) {
      // Handle modal trigger phrase configuration submission
      try {
        const actionId = custom_id.replace('modal_phrases_config_', '');
        const guildId = req.body.guild_id;
        
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to configure actions.')) return;
        
        console.log(`üìù DEBUG: Modal phrases config submitted for action ${actionId}`);
        
        // Extract phrases from modal (up to 5)
        const phrases = [];
        for (let i = 1; i <= 5; i++) {
          const phrase = components.find(row => 
            row.components[0].custom_id === `phrase_${i}`
          )?.components[0].value?.trim();
          
          if (phrase) {
            phrases.push(phrase);
          }
        }
        
        if (phrases.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå At least one command phrase is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Load and update action
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const action = safariData[guildId]?.buttons?.[actionId];
        
        if (!action) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Update trigger phrases
        if (!action.trigger) {
          action.trigger = { type: 'modal' };
        }
        action.trigger.phrases = phrases;
        
        // Update metadata
        action.metadata = action.metadata || {};
        action.metadata.lastModified = Date.now();
        action.metadata.lastModifiedBy = req.body.member.user.id;
        
        await saveSafariContent(safariData);
        
        // Update anchor messages for all coordinates using this action
        try {
          const { queueActionCoordinateUpdates } = await import('./anchorMessageManager.js');
          await queueActionCoordinateUpdates(guildId, actionId, 'modal_phrases_updated');
        } catch (error) {
          console.error('Error queueing anchor updates:', error);
        }
        
        console.log(`‚úÖ DEBUG: Updated phrases for action ${actionId}: ${phrases.join(', ')}`);
        
        // Show updated trigger config UI
        const { createTriggerConfigUI } = await import('./customActionUI.js');
        const configUI = await createTriggerConfigUI({ guildId, actionId });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: configUI
        });
        
      } catch (error) {
        console.error('Error in modal_phrases_config handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error saving command phrases.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('player_command_modal_')) {
      // Handle player command modal submission with deferred response
      const coord = custom_id.replace('player_command_modal_', '');
      const guildId = req.body.guild_id;
      const channelId = req.body.channel_id;
      const userId = req.body.member.user.id;
      const token = req.body.token;
      const applicationId = req.body.application_id;

      // Get the command entered by the player
      const command = components[0].components[0].value?.trim().toLowerCase();

      console.log(`‚å®Ô∏è DEBUG: Player command submitted - coord: ${coord}, command: "${command}"`);

      if (!command) {
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Please enter a command.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

      // Send deferred response immediately to prevent timeout
      await res.send({
        type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
        data: {
          flags: InteractionResponseFlags.EPHEMERAL
        }
      });

      // Now do the expensive operations asynchronously
      try {

        // Load safari data and find matching action
        const { loadSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const activeMapId = safariData[guildId]?.maps?.active;

        // Detect actual location from channelId if coord is 'global'
        let actualLocation = coord;
        if (coord === 'global') {
          const coordinates = safariData[guildId]?.maps?.[activeMapId]?.coordinates || {};

          // Search for matching channelId in map coordinates
          for (const [coordKey, coordData] of Object.entries(coordinates)) {
            if (coordData.channelId === channelId) {
              actualLocation = coordKey;
              console.log(`üìç DEBUG: Global button in location channel - detected ${actualLocation} from channelId ${channelId}`);
              break;
            }
          }

          // If no match found, set to null to skip location search
          if (actualLocation === 'global') {
            console.log(`üåç DEBUG: Global button in non-location channel - using global-only search`);
            actualLocation = null;
          }
        }

        // Get location-specific actions (empty if actualLocation is null)
        const locationActions = actualLocation
          ? safariData[guildId]?.maps?.[activeMapId]?.coordinates?.[actualLocation]?.buttons || []
          : [];

        // Search for a matching action with modal trigger
        let matchingAction = null;
        for (const actionId of locationActions) {
          const action = safariData[guildId]?.buttons?.[actionId];
          if (action?.trigger?.type === 'modal') {
            const phrases = action.trigger.phrases || [];
            if (phrases.some(phrase => phrase.toLowerCase() === command)) {
              matchingAction = { ...action, id: actionId };  // Include actionId as id property
              break;
            }
          }
        }
        
        if (matchingAction) {
          console.log(`‚úÖ Found matching action for command "${command}" at location ${actualLocation || 'global'}`);

          // Execute the action
          const { executeButtonActions } = await import('./safariManager.js');

          // Create proper interaction object for the execution
          const interactionData = {
            token: req.body.token,
            applicationId: req.body.application_id,
            member: req.body.member,
            channelName: `#${req.body.channel?.name || (actualLocation || 'unknown').toLowerCase()}`
          };

          const result = await executeButtonActions(
            guildId,
            matchingAction.id,  // Use the button ID, not the actions array
            userId,
            interactionData,
            client
          );

          // Log the player command
          try {
            const { logCustomAction } = await import('./safariLogger.js');
            const userData = req.body.member?.user || {};

            await logCustomAction({
              guildId,
              userId,
              username: userData.username || 'Unknown',
              displayName: req.body.member?.nick || userData.global_name || userData.username || 'Unknown',
              location: actualLocation || 'global',
              actionType: 'player_command',
              actionId: command,
              executedActions: matchingAction.actions?.map(action => ({
                type: action.type,
                config: action.config,
                result: 'executed'
              })) || [],
              success: true,
              channelName: `#${req.body.channel?.name || (actualLocation || 'unknown').toLowerCase()}`
            });
          } catch (logError) {
            console.error('Error logging player command:', logError);
          }
          
          // Edit the deferred response with the result
          await DiscordRequest(`webhooks/${applicationId}/${token}/messages/@original`, {
            method: 'PATCH',
            body: result
          });
        } else {
          // No matching command found
          console.log(`‚ùå No matching action found for command "${command}" at ${actualLocation || 'location'}`);

          // NEW: Search global actions (orphan actions) as fallback
          console.log(`üåç DEBUG: No location match for "${command}" at ${actualLocation || 'location'}, searching global actions`);

          for (const actionId of Object.keys(safariData[guildId]?.buttons || {})) {
            const action = safariData[guildId].buttons[actionId];
            if (action.trigger?.type === 'modal' &&
                (!action.coordinates || action.coordinates.length === 0)) {
              const phrases = action.trigger.phrases || [];
              if (phrases.some(phrase => phrase.toLowerCase() === command)) {
                matchingAction = { ...action, id: actionId };  // Add the actionId as id property
                console.log(`‚úÖ Found global action match: ${actionId}`);
                break;
              }
            }
          }

          if (matchingAction) {
            // Execute global action using existing logic
            console.log(`‚úÖ Found matching global action for command "${command}"`);

            // Execute the action
            const { executeButtonActions } = await import('./safariManager.js');

            // Create proper interaction object for the execution
            const interactionData = {
              token: req.body.token,
              applicationId: req.body.application_id,
              member: req.body.member,
              channelName: `#${req.body.channel?.name || coord.toLowerCase()}`
            };

            const result = await executeButtonActions(
              guildId,
              matchingAction.id,  // Use the button ID, not the actions array
              userId,
              interactionData
            );

            // Log the player command
            try {
              const { logCustomAction } = await import('./safariLogger.js');
              const userData = req.body.member?.user || {};

              await logCustomAction({
                guildId,
                userId,
                username: userData.username || 'Unknown',
                displayName: req.body.member?.nick || userData.global_name || userData.username || 'Unknown',
                location: 'global',
                actionType: 'player_command',
                actionId: command,
                executedActions: matchingAction.actions?.map(action => ({
                  type: action.type,
                  config: action.config,
                  result: 'executed'
                })) || [],
                success: true,
                channelName: `#${req.body.channel?.name || 'unknown'}`
              });
            } catch (logError) {
              console.error('Error logging player command:', logError);
            }

            // Edit the deferred response with the result
            await DiscordRequest(`webhooks/${applicationId}/${token}/messages/@original`, {
              method: 'PATCH',
              body: result
            });
            return;
          }

          // Still no match found - proceed with existing executeOn:"false" logic
          console.log(`‚ùå No matching action found for command "${command}" at ${actualLocation || 'location'} or globally`);

          // Check for actions with executeOn: "false" to execute when no match is found
          let falseActions = [];
          for (const actionId of locationActions) {
            const action = safariData[guildId]?.buttons?.[actionId];
            if (action?.trigger?.type === 'modal' && action.actions) {
              // Collect all actions with executeOn: "false"
              const actionsToExecute = action.actions.filter(act => act.executeOn === 'false');
              if (actionsToExecute.length > 0) {
                falseActions.push({ actionId: action.id, actions: actionsToExecute });
              }
            }
          }
          
          if (falseActions.length > 0) {
            console.log(`üéØ Found ${falseActions.length} actions with executeOn:'false' to execute`);
            
            // Execute the false actions from the first modal action that has them
            const { executeButtonActions } = await import('./safariManager.js');
            const firstFalseAction = falseActions[0];
            
            // Create proper interaction object for the execution
            const interactionData = {
              token: req.body.token,
              applicationId: req.body.application_id,
              member: req.body.member,
              channelName: `#${req.body.channel?.name || coord.toLowerCase()}`
            };
            
            // Execute with forceConditionsFail=true to trigger FALSE actions
            const result = await executeButtonActions(
              guildId,
              firstFalseAction.actionId,
              userId,
              interactionData,
              client,
              true // forceConditionsFail - treat as if conditions failed
            );
            
            // Log the player command with false actions
            try {
              const { logCustomAction } = await import('./safariLogger.js');
              const userData = req.body.member?.user || {};
              
              await logCustomAction({
                guildId,
                userId,
                username: userData.username || 'Unknown',
                displayName: req.body.member?.nick || userData.global_name || userData.username || 'Unknown',
                location: coord,
                actionType: 'player_command',
                actionId: command,
                executedActions: firstFalseAction.actions.map(action => ({
                  type: action.type,
                  config: action.config,
                  result: 'executed (on failure)'
                })),
                success: true,
                errorMessage: `No match found for command "${command}", executed failure actions`,
                channelName: `#${req.body.channel?.name || coord.toLowerCase()}`
              });
            } catch (logError) {
              console.error('Error logging player command:', logError);
            }
            
            // Edit the deferred response with the result
            await DiscordRequest(`webhooks/${applicationId}/${token}/messages/@original`, {
              method: 'PATCH',
              body: result
            });
            return;
          } else {
            // No false actions found, show default message
            const locationName = safariData[guildId]?.maps?.[activeMapId]?.coordinates?.[coord]?.baseContent?.title || `location ${coord}`;
            
            // Log the failed player command
            try {
              const { logCustomAction } = await import('./safariLogger.js');
              const userData = req.body.member?.user || {};
              
              await logCustomAction({
                guildId,
                userId,
                username: userData.username || 'Unknown',
                displayName: req.body.member?.nick || userData.global_name || userData.username || 'Unknown',
                location: coord,
                actionType: 'player_command',
                actionId: command,
                executedActions: [],
                success: false,
                errorMessage: `No matching action found for command "${command}"`,
                channelName: `#${req.body.channel?.name || coord.toLowerCase()}`
              });
            } catch (logError) {
              console.error('Error logging player command:', logError);
            }
            
            // Edit the deferred response with the "nothing happened" message
            await DiscordRequest(`webhooks/${applicationId}/${token}/messages/@original`, {
              method: 'PATCH',
              body: {
                components: [{
                  type: 17, // Container
                  accent_color: 0x808080, // Gray
                  components: [
                    {
                      type: 10, // Text Display
                      content: `## Nothing happened\n\nAttempted to \`${command}\` in ${locationName}. Nothing particularly exciting happened.`
                    }
                  ]
                }],
                flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL // IS_COMPONENTS_V2 + EPHEMERAL
              }
            });
          }
        }
        
      } catch (error) {
        console.error('Error in player_command_modal handler:', error);
        // Edit the deferred response with error message
        await DiscordRequest(`webhooks/${applicationId}/${token}/messages/@original`, {
          method: 'PATCH',
          body: {
            content: '‚ùå Error processing command.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('modal_answer_')) {
      // Handle modal answer submission for riddle/puzzle Custom Actions
      // Format: modal_answer_{guildId}_{actionId}_{timestamp}
      const parts = custom_id.split('_');
      const guildId = parts[2];
      const actionId = parts.slice(3, -1).join('_'); // Handle action IDs with underscores

      // Extract the user's answer
      const userAnswer = components[0].components[0].value;
      console.log(`üéØ Modal answer received: "${userAnswer}" for action ${actionId} in guild ${guildId}`);

      // Send deferred response immediately to prevent timeout
      res.send({
        type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
        data: { flags: InteractionResponseFlags.EPHEMERAL }
      });

      try {
        const { getCustomButton, executeButtonActions } = await import('./safariManager.js');
        const customAction = await getCustomButton(guildId, actionId);

        if (!customAction) {
          return await DiscordRequest(`webhooks/${req.body.application_id}/${req.body.token}/messages/@original`, {
            method: 'PATCH',
            body: {
              content: '‚ùå Custom action not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Check if answer matches any phrase (case-insensitive)
        const phrases = customAction.trigger?.phrases || [];
        const isCorrect = phrases.some(phrase =>
          phrase.toLowerCase().trim() === userAnswer.toLowerCase().trim()
        );

        if (isCorrect) {
          console.log(`‚úÖ Correct answer for ${actionId}`);

          // Build interaction context for executeButtonActions
          const interactionData = {
            member: req.body.member,
            channel_id: req.body.channel_id,
            guild_id: guildId,
            token: req.body.token,
            applicationId: req.body.application_id,
            channelName: `#${req.body.channel?.name || 'unknown'}`
          };

          // Execute the action's configured actions
          const result = await executeButtonActions(
            guildId,
            actionId,
            req.body.member.user.id,
            interactionData,
            client
          );

          // Send the result as follow-up
          if (result && result.components) {
            await DiscordRequest(`webhooks/${req.body.application_id}/${req.body.token}/messages/@original`, {
              method: 'PATCH',
              body: result
            });
          } else {
            // If no result, send success message
            await DiscordRequest(`webhooks/${req.body.application_id}/${req.body.token}/messages/@original`, {
              method: 'PATCH',
              body: {
                content: '‚úÖ Action completed successfully!',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
        } else {
          console.log(`‚ùå Incorrect answer for ${actionId}: "${userAnswer}"`);

          // Send generic incorrect message (no lockout, allow retry)
          await DiscordRequest(`webhooks/${req.body.application_id}/${req.body.token}/messages/@original`, {
            method: 'PATCH',
            body: {
              content: '‚ùå That\'s not correct. Try again!',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
      } catch (error) {
        console.error('Error processing modal answer:', error);
        await DiscordRequest(`webhooks/${req.body.application_id}/${req.body.token}/messages/@original`, {
          method: 'PATCH',
          body: {
            content: '‚ùå An error occurred processing your answer.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id.startsWith('admin_command_modal_')) {
      // Handle admin command modal submission - delegate to player logic
      const coord = custom_id.replace('admin_command_modal_', '');
      const modifiedCustomId = `player_command_modal_${coord}`;
      
      // Update the data object to use player custom_id
      req.body.data.custom_id = modifiedCustomId;
      
      // Now process as if it were a player command
      const processAsPlayer = async () => {
        const custom_id = modifiedCustomId; // Local variable that can be used
        
        // This is the exact same logic as player_command_modal handler
        try {
          const coord = custom_id.replace('player_command_modal_', '');
          const guildId = req.body.guild_id;
          const channelId = req.body.channel_id;
          const userId = req.body.member.user.id;
          
          // Get the command entered by the admin
          const command = components[0].components[0].value?.trim().toLowerCase();
          
          console.log(`üîß DEBUG: Admin command submitted (via player logic) - coord: ${coord}, command: "${command}"`);
          
          if (!command) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Please enter a command.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }
          
          // Load safari data and find matching action
          const { loadSafariContent } = await import('./safariManager.js');
          const safariData = await loadSafariContent();
          const activeMapId = safariData[guildId]?.maps?.active;
          const locationActions = safariData[guildId]?.maps?.[activeMapId]?.coordinates?.[coord]?.buttons || [];
          
          // Search for a matching action with modal trigger
          let matchingAction = null;
          for (const actionId of locationActions) {
            const action = safariData[guildId]?.buttons?.[actionId];
            if (action?.trigger?.type === 'modal') {
              const phrases = action.trigger.phrases || [];
              if (phrases.some(phrase => phrase.toLowerCase() === command)) {
                matchingAction = { ...action, id: actionId };  // Include actionId as id property
                break;
              }
            }
          }

          if (matchingAction) {
            console.log(`‚úÖ Found matching action for command "${command}"`);

            // Execute the action
            const { executeButtonActions } = await import('./safariManager.js');

            // Create proper interaction object for the execution
            const interactionData = {
              token: req.body.token,
              applicationId: req.body.application_id
            };

            const result = await executeButtonActions(
              guildId,
              matchingAction.id,  // Use the button ID, not the actions array
              userId,
              interactionData
            );
            
            // Return the result but make it ephemeral for admin
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                ...result,
                flags: (result.flags || 0) | InteractionResponseFlags.EPHEMERAL
              }
            });
          } else {
            // No matching command found
            console.log(`‚ùå No matching action found for command "${command}" at ${coord}`);
            
            // Check for actions with executeOn: "false" to execute when no match is found
            let falseActions = [];
            for (const actionId of locationActions) {
              const action = safariData[guildId]?.buttons?.[actionId];
              if (action?.trigger?.type === 'modal' && action.actions) {
                // Collect all actions with executeOn: "false"
                const actionsToExecute = action.actions.filter(act => act.executeOn === 'false');
                if (actionsToExecute.length > 0) {
                  falseActions.push({ actionId: action.id, actions: actionsToExecute });
                }
              }
            }
            
            if (falseActions.length > 0) {
              console.log(`üéØ Found ${falseActions.length} actions with executeOn:'false' to execute`);
              
              // Execute the false actions from the first modal action that has them
              const { executeButtonActions } = await import('./safariManager.js');
              const firstFalseAction = falseActions[0];
              
              // Create proper interaction object for the execution
              const interactionData = {
                token: req.body.token,
                applicationId: req.body.application_id
              };
              
              // Execute with forceConditionsFail=true to trigger FALSE actions
              const result = await executeButtonActions(
                guildId,
                firstFalseAction.actionId,
                userId,
                interactionData,
                true // forceConditionsFail - treat as if conditions failed
              );
              
              // Return the result but make it ephemeral for admin
              return res.send({
                type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                data: {
                  ...result,
                  flags: (result.flags || 0) | InteractionResponseFlags.EPHEMERAL
                }
              });
            } else {
              // No false actions found, show default message
              const locationName = safariData[guildId]?.maps?.[activeMapId]?.coordinates?.[coord]?.baseContent?.title || `location ${coord}`;
              
              return res.send({
                type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
                data: {
                  components: [{
                    type: 17, // Container
                    accent_color: 0x808080, // Gray
                    components: [
                      {
                        type: 10, // Text Display
                        content: `## Nothing happened\n\nAttempted to \`${command}\` in ${locationName}. Nothing particularly exciting happened.`
                      }
                    ]
                  }],
                  flags: (1 << 15) | InteractionResponseFlags.EPHEMERAL // IS_COMPONENTS_V2 + EPHEMERAL
                }
              });
            }
          }
          
        } catch (error) {
          console.error('Error in admin command handler:', error);
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error processing command.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
      };
      
      return processAsPlayer();
    } else if (custom_id.startsWith('entity_modal_submit_')) {
      // Handle modal submission for field editing
      try {
        // Parse: entity_modal_submit_{entityType}_{entityId}_{fieldGroup}
        const withoutPrefix = custom_id.replace('entity_modal_submit_', '');
        const parts = withoutPrefix.split('_');
        
        // Handle special case for map_cell entityType
        let entityType, entityId, fieldGroup;
        if (parts[0] === 'map' && parts[1] === 'cell') {
          entityType = 'map_cell';
          fieldGroup = parts[parts.length - 1];
          entityId = parts.slice(2, -1).join('_'); // Skip 'map_cell', take until fieldGroup
        } else {
          entityType = parts[0];
          fieldGroup = parts[parts.length - 1];
          entityId = parts.slice(1, -1).join('_');
        }
        const guildId = req.body.guild_id;
        
        console.log(`üìù DEBUG: Modal submit - Type: ${entityType}, ID: ${entityId}, Group: ${fieldGroup}`);
        
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES)) return;
        
        // Parse and validate submission
        const fields = parseModalSubmission(data, fieldGroup);
        const validation = validateFields(fields, entityType);
        
        if (!validation.valid) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚ùå **Validation Error**\n\n${validation.errors.join('\n')}`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Update entity
        await updateEntityFields(guildId, entityType, entityId, fields);
        
        // Special handling for map_cell - update anchor message
        if (entityType === 'map_cell') {
          try {
            const { safeUpdateAnchorMessage } = await import('./mapCellUpdater.js');
            console.log(`üìç Map cell ${entityId} checking for anchor message update...`);
            await safeUpdateAnchorMessage(guildId, entityId, client);
          } catch (error) {
            console.error('Error updating anchor message:', error);
          }
        }
        
        // Refresh UI
        const uiResponse = await createEntityManagementUI({
          entityType: entityType,
          guildId: guildId,
          selectedId: entityId,
          activeFieldGroup: null,
          searchTerm: '',
          mode: 'edit'
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: uiResponse
        });
        
      } catch (error) {
        console.error('Error handling modal submission:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Error saving changes: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
    } else if (custom_id === 'safari_rounds_config_modal') {
      // Handle rounds configuration modal submission
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        const member = req.body.member;
        
        // Security check - require ManageRoles permission
        if (!member?.permissions || !(BigInt(member.permissions) & PermissionFlagsBits.ManageRoles)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå You need Manage Roles permission to configure Safari rounds.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`‚öôÔ∏è DEBUG: Processing rounds configuration for guild ${guildId} by user ${userId}`);
        
        // Extract the total rounds value from modal
        const totalRoundsInput = data.components[0]?.components[0]?.value;
        const newTotalRounds = parseInt(totalRoundsInput);
        
        // Validate input
        if (isNaN(newTotalRounds) || newTotalRounds < 1) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Invalid input. Number of rounds must be at least 1.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Load current Safari data
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        
        // Initialize guild data if needed
        if (!safariData[guildId]) {
          safariData[guildId] = { safariConfig: {} };
        }
        if (!safariData[guildId].safariConfig) {
          safariData[guildId].safariConfig = {};
        }
        
        const safariConfig = safariData[guildId].safariConfig;
        const currentRound = safariConfig.currentRound || 0;
        const oldTotalRounds = safariConfig.totalRounds || 3;
        
        // Validation logic based on current game state
        if (currentRound > newTotalRounds && currentRound <= oldTotalRounds) {
          // Trying to reduce rounds below current round while game is in progress
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚ùå You have a game currently in progress on round ${currentRound} and are attempting to reduce the Total Rounds to ${newTotalRounds}. Finish your current game and reset the game first before changing Total Rounds.`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Update totalRounds
        safariConfig.totalRounds = newTotalRounds;
        await saveSafariContent(safariData);
        
        console.log(`‚úÖ DEBUG: Updated totalRounds from ${oldTotalRounds} to ${newTotalRounds} for guild ${guildId}`);
        
        // Determine status message
        let statusMessage = '';
        if (currentRound === 0 || !currentRound) {
          statusMessage = `\n\nThe game is not started, so this change will take effect when you start the game.`;
        } else if (currentRound > oldTotalRounds) {
          statusMessage = `\n\n‚ö†Ô∏è The game was previously completed. You can now continue with additional rounds or reset the game.`;
        } else if (currentRound <= newTotalRounds) {
          statusMessage = `\n\nThe game is currently on round ${currentRound} of ${newTotalRounds}.`;
        }
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚úÖ Successfully updated the number of rounds from **${oldTotalRounds}** to **${newTotalRounds}**.${statusMessage}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
      } catch (error) {
        console.error('Error in rounds configuration modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Configuration failed: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('safari_schedule_modal_')) {
      // Handle Safari scheduling modal submission
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        const member = req.body.member;
        
        // Extract channelId from custom_id: safari_schedule_modal_CHANNELID
        const channelId = custom_id.split('safari_schedule_modal_')[1];
        
        // Security check - require ManageRoles permission
        if (!member?.permissions || !(BigInt(member.permissions) & PermissionFlagsBits.ManageRoles)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå You need Manage Roles permission to schedule Safari results.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`üîç DEBUG: Processing Safari scheduling for guild ${guildId}, channel ${channelId} by user ${userId}`);

        // Extract form data by custom_id (Label components change array positions)
        let hoursValue = '';
        let minutesValue = '';
        let tasksToCancel = [];
        for (const comp of data.components) {
          // Label wrapper: child is in comp.component or comp.components[0]
          const child = comp.component || comp.components?.[0];
          if (!child) continue;
          if (child.custom_id === 'schedule_hours') hoursValue = child.value?.trim() || '';
          if (child.custom_id === 'schedule_minutes') minutesValue = child.value?.trim() || '';
          if (child.custom_id === 'cancel_tasks' && child.values) tasksToCancel = child.values;
        }

        // Cancel selected tasks
        let deletedCount = 0;
        for (const taskId of tasksToCancel) {
          if (scheduler.cancel(taskId)) {
            deletedCount++;
          }
        }

        // Schedule new task if hours/minutes provided
        let newTaskScheduled = false;
        let scheduleDetails = '';
        if (hoursValue || minutesValue) {
          const hours = parseInt(hoursValue) || 0;
          const minutes = parseInt(minutesValue) || 0;

          if (hours < 0 || minutes < 0 || hours > 168 || minutes > 59) {
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: '‚ùå Invalid time values. Hours: 0-168, Minutes: 0-59.',
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
          }

          if (hours > 0 || minutes > 0) {
            const totalMs = (hours * 3600000) + (minutes * 60000);
            const reminders = [];
            if (totalMs > 2700000) reminders.push({ offsetMs: 1800000, message: '30 minutes' });
            if (totalMs > 600000) reminders.push({ offsetMs: 300000, message: '5 minutes' });
            if (totalMs > 120000) reminders.push({ offsetMs: 60000, message: '1 minute' });

            await scheduler.schedule('process_round_results',
              { channelId, guildId },
              {
                delayMs: totalMs,
                guildId,
                channelId,
                reminders,
                reminderAction: 'send_reminder',
                description: 'Safari Round Results'
              }
            );
            newTaskScheduled = true;

            const executeAt = new Date(Date.now() + totalMs);
            scheduleDetails = `\n\n‚è∞ **New Task Scheduled:**\nSafari Results will run in this channel in **${hours}h ${minutes}m**\n*Executing at: ${executeAt.toLocaleString()}*`;
          }
        }
        
        // Build response message
        let responseText = '‚úÖ **Safari Scheduling Updated**';
        
        if (deletedCount > 0) {
          responseText += `\nüóëÔ∏è Cancelled ${deletedCount} scheduled task${deletedCount > 1 ? 's' : ''}`;
        }
        
        if (newTaskScheduled) {
          responseText += scheduleDetails;
        }
        
        if (deletedCount === 0 && !newTaskScheduled) {
          responseText = 'üìÖ No changes made to Safari scheduling.';
        }
        
        // Send response to channel (not ephemeral) so you can see the confirmation
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: responseText,
            flags: 0 // Not ephemeral - visible to everyone for confirmation
          }
        });
        
      } catch (error) {
        console.error('Error in Safari scheduling modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Scheduling failed: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('ca_schedule_modal_')) {
      // Handle Custom Action scheduling modal submission
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        const member = req.body.member;

        // Security check
        if (!member?.permissions || !(BigInt(member.permissions) & PermissionFlagsBits.ManageRoles)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå You need Manage Roles permission to schedule actions.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Extract actionId and channelId from custom_id: ca_schedule_modal_ACTIONID_CHANNELID
        const modalSuffix = custom_id.replace('ca_schedule_modal_', '');
        const lastUnderscore = modalSuffix.lastIndexOf('_');
        const actionId = modalSuffix.substring(0, lastUnderscore);
        const channelId = modalSuffix.substring(lastUnderscore + 1);

        console.log(`‚è∞ Processing Custom Action schedule for action ${actionId}, channel ${channelId}`);

        // Extract form data by custom_id
        let hoursValue = '';
        let minutesValue = '';
        for (const comp of data.components) {
          const child = comp.component || comp.components?.[0];
          if (!child) continue;
          if (child.custom_id === 'schedule_hours') hoursValue = child.value?.trim() || '';
          if (child.custom_id === 'schedule_minutes') minutesValue = child.value?.trim() || '';
        }

        if (!hoursValue && !minutesValue) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Please enter hours and/or minutes to schedule.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        const hours = parseInt(hoursValue) || 0;
        const minutes = parseInt(minutesValue) || 0;

        if (hours < 0 || minutes < 0 || hours > 168 || minutes > 59) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Invalid time values. Hours: 0-168, Minutes: 0-59.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        if (hours === 0 && minutes === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Schedule time must be at least 1 minute.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Get action name for description
        const { loadSafariContent } = await import('./safariManager.js');
        const allSafariContent = await loadSafariContent();
        const action = allSafariContent[guildId]?.buttons?.[actionId];
        const actionName = action?.name || 'Custom Action';

        const totalMs = (hours * 3600000) + (minutes * 60000);

        await scheduler.schedule('execute_custom_action',
          { channelId, guildId, actionId, userId, actionName },
          {
            delayMs: totalMs,
            guildId,
            channelId,
            description: actionName
          }
        );

        const executeAt = new Date(Date.now() + totalMs);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚úÖ **Scheduled Action**: "${actionName}" will execute in <#${channelId}> in **${hours}h ${minutes}m**\n*Executing at: ${executeAt.toLocaleString()}*`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });

      } catch (error) {
        console.error('Error in Custom Action scheduling modal handler:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Scheduling failed: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

    } else if (custom_id.startsWith('add_coord_submit_')) {
      // Handle coordinate addition modal submission
      try {
        const member = req.body.member;
        const guildId = req.body.guild_id;
        const actionId = custom_id.replace('add_coord_submit_', '');
        
        // Check admin permissions
        if (!requirePermission(req, res, PERMISSIONS.MANAGE_ROLES, 'You need Manage Roles permission to manage coordinates.')) return;
        
        const coordinate = components[0].components[0].value?.trim().toUpperCase();
        
        if (!coordinate) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Coordinate is required.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Validate coordinate format (e.g. A1, B3, D7)
        if (!/^[A-Z]\d+$/.test(coordinate)) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Invalid coordinate format. Use format like A1, B3, D7.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Load and update safari data
        const { loadSafariContent, saveSafariContent } = await import('./safariManager.js');
        const allSafariContent = await loadSafariContent();
        const guildData = allSafariContent[guildId] || {};
        const action = guildData.buttons?.[actionId];
        
        if (!action) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Action not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Add coordinate to action
        if (!action.coordinates) {
          action.coordinates = [];
        }
        if (!action.coordinates.includes(coordinate)) {
          action.coordinates.push(coordinate);
        }
        
        // Add bidirectional sync - update coordinate's buttons array
        const activeMapId = allSafariContent[guildId]?.maps?.active;
        if (activeMapId && allSafariContent[guildId]?.maps?.[activeMapId]?.coordinates?.[coordinate]) {
          const coordData = allSafariContent[guildId].maps[activeMapId].coordinates[coordinate];
          if (!coordData.buttons) {
            coordData.buttons = [];
          }
          if (!coordData.buttons.includes(actionId)) {
            coordData.buttons.push(actionId);
          }
        }
        
        await saveSafariContent(allSafariContent);
        
        // Queue anchor message updates
        try {
          const { queueActionCoordinateUpdates } = await import('./anchorMessageManager.js');
          await queueActionCoordinateUpdates(guildId, actionId, 'coordinate_added');
        } catch (error) {
          console.error('Error queueing anchor updates:', error);
        }
        
        // Return updated UI
        const { createCoordinateManagementUI } = await import('./customActionUI.js');
        const ui = await createCoordinateManagementUI({
          guildId: guildId,
          actionId
        });
        
        console.log(`‚úÖ SUCCESS: add_coord_submit - added ${coordinate} to action ${actionId}`);
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: ui
        });
        
      } catch (error) {
        console.error('Error adding coordinate:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error adding coordinate. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('entity_search_modal_')) {
      // Handle entity search modal submission
      console.log(`üîç DEBUG: Entity search modal - custom_id: ${custom_id}`);
      
      try {
        // Parse entity type from custom_id: entity_search_modal_{entityType}
        const entityType = custom_id.replace('entity_search_modal_', '');
        
        // Get search term from modal
        const searchTerm = data.components[0]?.components[0]?.value?.toLowerCase().trim();
        
        if (!searchTerm) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Please enter a search term.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`üîç DEBUG: Searching ${entityType}s for term: "${searchTerm}"`);
        
        // Import required modules
        const { loadSafariContent } = await import('./safariManager.js');
        const { parseTextEmoji } = await import('./utils/emojiUtils.js');
        
        // Load safari content
        const allSafariContent = await loadSafariContent();
        const guildData = allSafariContent[req.body.guild_id] || {};
        
        // Get entities based on type
        let entities = [];
        switch (entityType) {
          case 'map_cell':
            // For map cells, search through the actual map coordinates
            const activeMapId = guildData.maps?.active;
            if (activeMapId && guildData.maps?.[activeMapId]?.coordinates) {
              const mapCoordinates = guildData.maps[activeMapId].coordinates;
              
              entities = Object.entries(mapCoordinates)
                .filter(([coord, cellData]) => {
                  // Search by coordinate name or cell content
                  const searchableText = [
                    coord.toLowerCase(),
                    cellData.baseContent?.title?.toLowerCase() || '',
                    cellData.baseContent?.description?.toLowerCase() || ''
                  ].join(' ');
                  return searchableText.includes(searchTerm);
                })
                .map(([coord, cellData]) => ({
                  value: coord,
                  label: coord,
                  description: cellData.baseContent?.title || `Location ${coord}`,
                  emoji: cellData.baseContent?.title?.match(/^(.*?) /)?.[1] || 'üìç'
                }));
            }
            break;
            
          case 'safari_button':
            // Search safari buttons
            if (guildData.buttons) {
              entities = Object.entries(guildData.buttons)
                .filter(([id, button]) => {
                  const searchableText = [
                    button.label?.toLowerCase() || '',
                    button.description?.toLowerCase() || '',
                    id.toLowerCase()
                  ].join(' ');
                  return searchableText.includes(searchTerm);
                })
                .map(([id, button]) => ({
                  value: id,
                  label: button.label || id,
                  description: button.description,
                  emoji: button.emoji
                }));
            }
            break;
            
          case 'item':
            // Search items
            if (guildData.items) {
              entities = Object.entries(guildData.items)
                .filter(([id, item]) => {
                  const searchableText = [
                    item.name?.toLowerCase() || '',
                    item.description?.toLowerCase() || '',
                    id.toLowerCase()
                  ].join(' ');
                  return searchableText.includes(searchTerm);
                })
                .map(([id, item]) => {
                  // Safely parse emoji with error handling
                  let emojiObj = null; // Start with null, Discord will handle no emoji
                  if (item.emoji) {
                    try {
                      const emojiStr = String(item.emoji).trim();
                      
                      // Skip problematic or invalid emojis
                      if (emojiStr && !emojiStr.includes('ÔøΩ')) {
                        // Check if it's a custom Discord emoji
                        if (emojiStr.match(/<a?:(\w+):(\d+)>/)) {
                          const parsed = parseTextEmoji(emojiStr);
                          if (parsed?.emoji) {
                            emojiObj = parsed.emoji;
                          }
                        } else {
                          // For regular Unicode emojis, just use the string in the name field
                          // But only if it's a reasonable length (not corrupted)
                          if (emojiStr.length <= 4) {
                            emojiObj = { name: emojiStr };
                          }
                        }
                      }
                    } catch (e) {
                      console.warn(`‚ö†Ô∏è Failed to parse emoji for item ${id}:`, e.message);
                    }
                  }
                  
                  return {
                    value: id,
                    label: item.name || id,
                    description: item.description,
                    emoji: emojiObj // Can be null, Discord handles this
                  };
                });
            }
            break;
            
          case 'store':
            // Search stores
            if (guildData.stores) {
              entities = Object.entries(guildData.stores)
                .filter(([id, store]) => {
                  const searchableText = [
                    store.name?.toLowerCase() || '',
                    store.description?.toLowerCase() || '',
                    store.storeownerText?.toLowerCase() || '',
                    id.toLowerCase()
                  ].join(' ');
                  return searchableText.includes(searchTerm);
                })
                .map(([id, store]) => ({
                  value: id,
                  label: store.name || id,
                  description: store.description || store.storeownerText,
                  emoji: store.emoji
                }));
            }
            break;
            
          default:
            console.error(`üö® Unknown entity type in search: ${entityType}`);
            return res.send({
              type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
              data: {
                content: `‚ùå Unknown entity type: ${entityType}`,
                flags: InteractionResponseFlags.EPHEMERAL
              }
            });
        }
        
        console.log(`üîç DEBUG: Found ${entities.length} matching ${entityType}s`);
        
        if (entities.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚ùå No ${entityType}s found matching "${searchTerm}".`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Check if too many results (need to leave room for "Back to all" option = 24 max entity results)
        if (entities.length >= 24) {
          console.log(`üîç DEBUG: Too many results (${entities.length}), asking user to refine search`);
          
          // Create Components V2 "too many results" message
          const tooManyContainer = {
            type: 17, // Container
            accent_color: 0xff6b6b, // Red accent for warning
            components: [
              {
                type: 10, // Text Display
                content: `## üîç Too Many Search Results\n\nFound **${entities.length}** ${entityType}s matching "${searchTerm}"\n\n‚ö†Ô∏è Please make your search more specific to see results (max 24 results).`
              },
              { type: 14 }, // Separator
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    style: 1, // Primary
                    label: 'üîç Search Again', 
                    custom_id: `entity_search_again_${entityType}`,
                    emoji: { name: 'üîç' }
                  },
                  {
                    type: 2, // Button
                    style: 2, // Secondary
                    label: 'üè† Back to Menu',
                    custom_id: `safari_manage_${entityType === 'item' ? 'items' : entityType === 'store' ? 'stores' : entityType === 'safari_button' ? 'safari_buttons' : 'items'}`
                  }
                ]
              }
            ]
          };
          
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              components: [tooManyContainer],
              flags: InteractionResponseFlags.EPHEMERAL | (1 << 15) // EPHEMERAL + IS_COMPONENTS_V2
            }
          });
        }
        
        // Sort results and limit to 25 for Discord select menu (should be under 24 now)
        entities = entities
          .sort((a, b) => a.label.localeCompare(b.label))
          .slice(0, 24); // Take max 24 to leave room for "Back to all"
        
        // Create select menu with search results
        const options = entities.map(entity => {
          const option = {
            label: entity.label,
            value: entity.value
          };
          
          // Add description if it exists and is valid
          if (entity.description && entity.description.length > 0) {
            option.description = entity.description.substring(0, 100); // Discord limit
          }
          
          // Only add emoji if it's valid and not null
          if (entity.emoji && entity.emoji.name) {
            const emojiName = String(entity.emoji.name);
            // Validate emoji doesn't contain invalid characters and is reasonable length
            if (emojiName && !emojiName.includes('ÔøΩ') && emojiName.length <= 10) {
              option.emoji = entity.emoji;
            }
          }
          
          return option;
        });
        
        // Add back/management option
        options.unshift({
          label: 'üîô Back to all',
          value: 'back_to_all',
          description: 'Return to full list'
        });
        
        const selectMenu = {
          type: 3, // String Select
          custom_id: `entity_select_${entityType}`,
          placeholder: `${entities.length} result${entities.length !== 1 ? 's' : ''} for "${searchTerm}"`,
          options: options
        };
        
        // Create UI with Components V2
        const uiComponents = [
          {
            type: 17, // Container
            accent_color: 0x5865f2,
            components: [
              {
                type: 10, // Text Display
                content: `## Search Results: ${entityType}\nFound ${entities.length} matching "${searchTerm}"`
              },
              { type: 14 }, // Separator
              {
                type: 1, // Action Row
                components: [selectMenu]
              }
            ]
          }
        ];
        
        // Debug log the response we're about to send
        console.log('üîç DEBUG: Sending entity search response with options:', JSON.stringify(options.slice(0, 3), null, 2));
        console.log('üîç DEBUG: Response type: UPDATE_MESSAGE, flags:', (1 << 15));
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            components: uiComponents,
            flags: (1 << 15) // IS_COMPONENTS_V2
          }
        });
        
      } catch (error) {
        console.error('Error handling entity search:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error searching entities. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('custom_action_search_modal_')) {
      // Handle custom action search modal submission
      console.log(`üîç DEBUG: Custom action search modal - custom_id: ${custom_id}`);
      
      try {
        // Parse context: could be map context or follow-up context
        let coordinate = null;
        let mapId = null;
        let isFollowUpContext = false;
        let buttonId = null;
        let actionIndex = null;
        
        if (custom_id !== 'custom_action_search_modal_global') {
          const parts = custom_id.replace('custom_action_search_modal_', '').split('_');
          
          // Check if this is follow-up context: custom_action_search_modal_followup_{buttonId}_{actionIndex}
          if (parts[0] === 'followup') {
            isFollowUpContext = true;
            buttonId = parts.slice(1, -1).join('_'); // Handle button IDs with underscores
            const lastPart = parts[parts.length - 1];
            if (!isNaN(parseInt(lastPart))) {
              actionIndex = parseInt(lastPart);
            } else {
              // No actionIndex, so buttonId includes the last part
              buttonId = parts.slice(1).join('_');
            }
          } else {
            // Original map context: custom_action_search_modal_{coordinate}_{mapId}
            coordinate = parts[0];
            mapId = parts[1];
          }
        }
        
        // Get search term from modal
        const searchTerm = data.components[0]?.components[0]?.value?.toLowerCase().trim();
        
        if (!searchTerm) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Please enter a search term.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`üîç DEBUG: Searching ${isFollowUpContext ? 'follow-up' : 'custom'} actions for term: "${searchTerm}"`);
        
        // Import required modules
        const { loadSafariContent } = await import('./safariManager.js');
        const { StringSelectMenuBuilder, ActionRowBuilder } = await import('discord.js');
        
        // Load safari content
        const allSafariContent = await loadSafariContent();
        const guildData = allSafariContent[req.body.guild_id] || {};
        const allActions = guildData.buttons || {};
        
        // Search through actions
        const searchResults = Object.entries(allActions)
          .filter(([actionId, action]) => {
            // For follow-up context, exclude the current button
            if (isFollowUpContext && actionId === buttonId) {
              return false;
            }
            
            const searchableText = [
              action.name?.toLowerCase() || '',
              action.label?.toLowerCase() || '',
              action.description?.toLowerCase() || '',
              action.trigger?.modal?.title?.toLowerCase() || ''
            ].join(' ');
            return searchableText.includes(searchTerm);
          })
          .map(([actionId, action]) => ({ actionId, action }));
        
        console.log(`üîç DEBUG: Found ${searchResults.length} matching ${isFollowUpContext ? 'follow-up' : 'custom'} actions`);
        
        if (searchResults.length === 0) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚ùå No ${isFollowUpContext ? 'follow-up' : 'custom'} actions found matching "${searchTerm}".`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Check if too many results
        if (searchResults.length >= 24) {
          console.log(`üîç DEBUG: Too many results (${searchResults.length}), asking user to refine search`);
          
          // Create Components V2 "too many results" message
          const tooManyContainer = {
            type: 17, // Container
            accent_color: 0xff6b6b, // Red accent for warning
            components: [
              {
                type: 10, // Text Display
                content: `## üîç Too Many Search Results\n\nFound **${searchResults.length}** actions matching "${searchTerm}"\n\n‚ö†Ô∏è Please make your search more specific to see results (max 24 results).`
              },
              { type: 14 }, // Separator
              {
                type: 1, // Action Row
                components: [
                  {
                    type: 2, // Button
                    style: 1, // Primary
                    label: 'üîç Search Again',
                    custom_id: coordinate ? `custom_action_search_again_${coordinate}_${mapId}` : 'custom_action_search_again_global',
                    emoji: { name: 'üîç' }
                  },
                  {
                    type: 2, // Button
                    style: 2, // Secondary
                    label: '‚¨ÖÔ∏è Back to Actions',
                    custom_id: coordinate ? `entity_field_group_map_cell_${coordinate}_interaction` : 'safari_action_editor'
                  }
                ]
              }
            ]
          };
          
          return res.send({
            type: InteractionResponseType.UPDATE_MESSAGE,
            data: {
              components: [tooManyContainer],
              flags: (1 << 15) // IS_COMPONENTS_V2
            }
          });
        }
        
        // Build select menu with search results
        let customId;
        if (isFollowUpContext) {
          // For follow-up context, route back to follow-up selector
          customId = actionIndex !== undefined ? 
            `safari_follow_up_select_${buttonId}_${actionIndex}` : 
            `safari_follow_up_select_${buttonId}`;
        } else {
          // For map context, route back to custom action list
          customId = coordinate && mapId ? 
            `entity_custom_action_list_${coordinate}_${mapId}` : 
            'entity_custom_action_list_global';
        }
        const selectMenu = new StringSelectMenuBuilder()
          .setCustomId(customId)
          .setPlaceholder(`${searchResults.length} result${searchResults.length !== 1 ? 's' : ''} for "${searchTerm}"`)
          .setMinValues(1)
          .setMaxValues(1);
        
        // Add back option
        if (isFollowUpContext) {
          selectMenu.addOptions({
            label: 'üîô Back to all',
            value: 'back_to_all_follow_up',
            description: 'Return to full follow-up action list'
          });
        } else {
          selectMenu.addOptions({
            label: 'üîô Back to all',
            value: 'back_to_all',
            description: 'Return to full action list'
          });
        }
        
        // Add search results (limited to 23 to leave room for back option)
        for (const { actionId, action } of searchResults.slice(0, 23)) {
          // Create meaningful description
          let description = action.description || 'No description';
          const actionCount = action.actions?.length || 0;
          if (actionCount > 0) {
            description += ` ‚Ä¢ ${actionCount} action${actionCount !== 1 ? 's' : ''}`;
          }
          
          selectMenu.addOptions({
            label: (action.name || action.label || 'Unnamed Action').substring(0, 100),
            value: actionId,
            description: description.substring(0, 100)
          });
        }
        
        const selectRow = new ActionRowBuilder().addComponents(selectMenu);
        
        // Create UI with Components V2
        const uiComponents = [
          {
            type: 17, // Container
            accent_color: 0x5865f2,
            components: [
              {
                type: 10, // Text Display
                content: `## Search Results: Custom Actions\nFound ${searchResults.length} matching "${searchTerm}"`
              },
              { type: 14 }, // Separator
              selectRow.toJSON()
            ]
          }
        ];
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: {
            components: uiComponents,
            flags: (1 << 15) // IS_COMPONENTS_V2
          }
        });
        
      } catch (error) {
        console.error('Error handling custom action search:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error searching custom actions. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id.startsWith('store_item_search_modal_')) {
      // Handle store item search modal submission
      console.log(`üîç DEBUG: Store item search modal - custom_id: ${custom_id}`);
      
      try {
        // Extract store ID from custom_id
        const storeId = custom_id.replace('store_item_search_modal_', '');
        
        // Get search term from modal
        const searchTerm = data.components[0]?.components[0]?.value?.toLowerCase().trim();
        
        if (!searchTerm) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Please enter a search term.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        console.log(`üîç DEBUG: Searching store items for term: "${searchTerm}" in store ${storeId}`);
        
        // Import required functions
        const { loadSafariContent } = await import('./safariManager.js');
        const { createStoreItemManagementUI } = await import('./entityManagementUI.js');
        
        const safariData = await loadSafariContent();
        const store = safariData[req.body.guild_id]?.stores?.[storeId];
        
        if (!store) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Store not found.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Create UI with search term
        const uiResponse = await createStoreItemManagementUI({
          storeId: storeId,
          store: store,
          guildId: req.body.guild_id,
          searchTerm: searchTerm
        });
        
        return res.send({
          type: InteractionResponseType.UPDATE_MESSAGE,
          data: uiResponse
        });
        
      } catch (error) {
        console.error('Error handling store item search:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error searching store items. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id === 'map_update_modal') {
      // Handle map update modal submission
      try {
        const guildId = req.body.guild_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;
        const mapUrl = components[0].components[0].value?.trim();
        const mapRows = parseInt(components[1].components[0].value?.trim());
        const mapColumns = parseInt(components[2].components[0].value?.trim());
        
        console.log(`üîÑ DEBUG: Map update modal submitted - guild: ${guildId}, url: ${mapUrl}, dimensions: ${mapColumns}x${mapRows}`);
        
        // Basic URL validation
        if (!mapUrl || !mapUrl.startsWith('https://cdn.discordapp.com/attachments/')) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Please provide a valid Discord CDN URL (must start with https://cdn.discordapp.com/attachments/)',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Validate dimensions
        if (isNaN(mapRows) || isNaN(mapColumns) || mapRows < 1 || mapRows > 100 || mapColumns < 1 || mapColumns > 100) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Map dimensions must be between 1 and 100 for both rows and columns.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Calculate total channel count first
        const totalChannels = mapRows * mapColumns;
        
        // Validate total channel count
        if (totalChannels > 400) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: `‚ùå ${mapColumns}x${mapRows} = ${totalChannels} channels exceeds the 400 channel limit.`,
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
        
        // Defer response for long operation
        await res.send({
          type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
        
        // Check if map exists to determine create vs update
        const { loadSafariContent } = await import('./safariManager.js');
        const safariData = await loadSafariContent();
        const hasActiveMap = safariData[guildId]?.maps?.active;
        const activeMapId = safariData[guildId]?.maps?.active;
        const existingMap = activeMapId ? safariData[guildId]?.maps?.[activeMapId] : null;
        
        // If updating, check if dimensions changed
        if (hasActiveMap && existingMap) {
          // Get existing dimensions (with backwards compatibility)
          const existingWidth = existingMap.gridWidth || existingMap.gridSize || 7;
          const existingHeight = existingMap.gridHeight || existingMap.gridSize || 7;
          
          if (mapColumns !== existingWidth || mapRows !== existingHeight) {
            // Dimensions changed - block the update
            const followupUrl = `https://discord.com/api/v10/webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
            await fetch(followupUrl, {
              method: 'PATCH',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                content: `‚ùå Map dimensions cannot be changed (current: ${existingWidth}x${existingHeight}, requested: ${mapColumns}x${mapRows}).\n\nTo use different dimensions, delete the existing map first.`,
                flags: InteractionResponseFlags.EPHEMERAL
              })
            });
            return;
          }
        }
        
        const guild = await client.guilds.fetch(guildId);
        let result;
        
        if (hasActiveMap) {
          // Update existing map
          console.log(`üîÑ Updating existing map for guild ${guildId}`);
          const { updateMapImage } = await import('./mapExplorer.js');
          result = await updateMapImage(guild, userId, mapUrl);
        } else {
          // Create new map with custom image and dimensions
          console.log(`üèóÔ∏è Creating new map with custom image for guild ${guildId} - dimensions: ${mapColumns}x${mapRows}`);
          const { createMapGridWithCustomImage } = await import('./mapExplorer.js');
          result = await createMapGridWithCustomImage(guild, userId, mapUrl, mapColumns, mapRows);
        }
        
        // Send followup with result
        const followupUrl = `https://discord.com/api/v10/webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
        
        await fetch(followupUrl, {
          method: 'PATCH',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            content: result.message,
            flags: InteractionResponseFlags.EPHEMERAL
          })
        });
        
      } catch (error) {
        console.error('Error in map_update_modal handler:', error);
        
        // Try to send error as followup
        try {
          const followupUrl = `https://discord.com/api/v10/webhooks/${process.env.APP_ID}/${req.body.token}/messages/@original`;
          await fetch(followupUrl, {
            method: 'PATCH',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              content: `‚ùå Error ${hasActiveMap ? 'updating' : 'creating'} map: ${error.message}`,
              flags: InteractionResponseFlags.EPHEMERAL
            })
          });
        } catch (followupError) {
          console.error('Error sending followup:', followupError);
        }
      }
      
    } else if (custom_id === 'map_admin_blacklist_modal') {
      // Handle blacklist modal submission
      try {
        const guildId = req.body.guild_id;
        const { handleMapAdminBlacklistModal } = await import('./safariMapAdmin.js');
        
        // Create context for the handler
        const context = {
          guildId: guildId,
          userId: req.body.member?.user?.id || req.body.user?.id
        };
        
        const result = await handleMapAdminBlacklistModal(context, req);
        
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: result
        });
        
      } catch (error) {
        console.error('Error handling blacklist modal:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: '‚ùå Error updating blacklisted coordinates. Please try again.',
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }
      
    } else if (custom_id === 'map_admin_refresh_anchors_modal') {
      // Handle refresh anchors modal submission
      try {
        const guildId = req.body.guild_id;
        const token = req.body.token;
        const applicationId = req.body.application_id;

        // Check if user requested "All" (which takes a long time)
        const coordinatesInput = req.body.data.components[0]?.component?.value || '';
        const isRefreshAll = coordinatesInput.trim().toLowerCase() === 'all';

        if (isRefreshAll) {
          // Defer immediately for "All" refresh (takes ~60 seconds for 49 anchors)
          res.send({
            type: InteractionResponseType.DEFERRED_CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });

          // Process in background and edit deferred response
          const { handleMapAdminRefreshAnchorsModal } = await import('./safariMapAdmin.js');
          const context = {
            guildId: guildId,
            userId: req.body.member?.user?.id || req.body.user?.id
          };

          const result = await handleMapAdminRefreshAnchorsModal(context, req);

          // Edit the deferred response with results
          const editUrl = `https://discord.com/api/v10/webhooks/${applicationId}/${token}/messages/@original`;
          await fetch(editUrl, {
            method: 'PATCH',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              ...result,
              flags: result.flags | InteractionResponseFlags.EPHEMERAL
            })
          });

          return;
        } else {
          // Specific coordinates - fast enough for synchronous response
          const { handleMapAdminRefreshAnchorsModal } = await import('./safariMapAdmin.js');
          const context = {
            guildId: guildId,
            userId: req.body.member?.user?.id || req.body.user?.id
          };

          const result = await handleMapAdminRefreshAnchorsModal(context, req);

          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              ...result,
              flags: result.flags | InteractionResponseFlags.EPHEMERAL
            }
          });
        }

      } catch (error) {
        console.error('Error handling refresh anchors modal:', error);

        // If response not sent yet, send error
        if (!res.headersSent) {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Error refreshing anchor messages. Please try again.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }
      }
      
    } else if (custom_id.startsWith('castlist_edit_info_modal_')) {
      // Handle castlist Edit Info modal submission
      const { handleEditInfoModal } = await import('./castlistHandlers.js');
      return handleEditInfoModal(req, res, client, custom_id);
    } else if (custom_id.startsWith('castlist_order_modal_')) {
      // Handle castlist Order modal submission
      const { handleOrderModal } = await import('./castlistHandlers.js');
      return handleOrderModal(req, res, client, custom_id);
    } else if (custom_id === 'castlist_create_new_modal') {
      // Handle NEW castlist creation modal submission
      const { handleCreateNewModal } = await import('./castlistHandlers.js');
      return handleCreateNewModal(req, res, client);

    } else if (custom_id === 'health_monitor_schedule_modal') {
      // Handle health monitor scheduling modal submission
      try {
        const guildId = req.body.guild_id;
        const channelId = req.body.channel_id;
        const userId = req.body.member?.user?.id || req.body.user?.id;

        // Security check
        if (userId !== '391415444084490240') {
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Access denied.',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        console.log('[üåà Ultramonitor] Processing schedule modal submission');

        // Extract minutes value and convert to hours
        const minutesValue = data.components[0]?.components[0]?.value?.trim();
        const minutes = parseFloat(minutesValue) || 0;
        const hours = minutes / 60; // Convert to hours

        // Import and get singleton health monitor
        const { getHealthMonitor } = await import('./src/monitoring/healthMonitor.js');
        const monitor = getHealthMonitor(client);

        // Validate input (allow 1 minute minimum for testing)
        if (minutes < 0 || minutes > 10080) { // 10080 minutes = 1 week
          return res.send({
            type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
            data: {
              content: '‚ùå Invalid minutes. Please enter 0 to disable, or 1-10080 minutes (1 week max).',
              flags: InteractionResponseFlags.EPHEMERAL
            }
          });
        }

        // Start or stop monitoring
        const result = monitor.start(hours, channelId, guildId);
        console.log(`[üåà Ultramonitor] Monitor start result:`, result);

        let responseMessage;
        if (minutes === 0) {
          responseMessage = '‚èπÔ∏è **Health monitoring disabled**';
        } else {
          const displayTime = minutes >= 60 ?
            `${Math.round(minutes/60)} hour${Math.round(minutes/60) === 1 ? '' : 's'}` :
            `${minutes} minute${minutes === 1 ? '' : 's'}`;
          responseMessage = `‚úÖ **Health monitoring scheduled**\n\n**Interval**: Every ${displayTime}\n**Channel**: <#${channelId}>\n**First check**: In 5 seconds\n\n_Note: Schedule clears on bot restart_`;
        }

        console.log(`[üåà Ultramonitor] Schedule updated - ${minutes === 0 ? 'disabled' : `every ${minutes} minutes`}`);

        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: responseMessage,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });

      } catch (error) {
        console.error('[üåà Ultramonitor] Schedule error:', error);
        return res.send({
          type: InteractionResponseType.CHANNEL_MESSAGE_WITH_SOURCE,
          data: {
            content: `‚ùå Error setting schedule: ${error.message}`,
            flags: InteractionResponseFlags.EPHEMERAL
          }
        });
      }

    } else {
      console.log(`‚ö†Ô∏è DEBUG: Unhandled MODAL_SUBMIT custom_id: ${custom_id}`);
    }
  } // end if MODAL_SUBMIT
  // ...rest of interaction handling...
}); // end app.post

app.listen(PORT, () => {
  console.log('Listening on port', PORT);
});

// Log in to Discord with your client's token
// Legacy duplicate messageReactionRemove handler removed (was at line 41904) ‚Äî
// comprehensive handler exists at messageReactionRemove listener below

client.login(process.env.DISCORD_TOKEN);

// Helper functions moved to utils/emojiUtils.js (Phase 1A refactoring)

// Generate emojis for all members with a specific role
async function generateEmojisForRole(guild, role) {
  const resultLines = [];
  const existingLines = [];
  const errorLines = [];
  let maxEmojiReached = false;
  
  const guildId = guild.id;
  const roleId = role.id;
  
  // Load current player data
  const data = await loadPlayerData();
  if (!data[guildId]) data[guildId] = {};
  if (!data[guildId].players) data[guildId].players = {};
  
  // Fetch all members via REST API (guild.members.list) instead of Gateway OP 8
  await guild.members.list({ limit: 1000 });
  
  // Get members with this role
  const targetMembers = guild.members.cache.filter(member => 
    member.roles.cache.has(roleId) && !member.user.bot
  );
  
  console.log(`Found ${targetMembers.size} members with role ${role.name} (${roleId})`);
  
  if (targetMembers.size === 0) {
    return {
      resultLines: [],
      existingLines: [],
      errorLines: ['No members found with this role'],
      maxEmojiReached: false
    };
  }
  
  // Generate emojis for each member (same logic as add_tribe)
  for (const [memberId, member] of targetMembers) {
    try {
      // Check if player already has an emoji
      const existingPlayer = data[guildId].players?.[memberId];
      if (existingPlayer?.emojiCode) {
        existingLines.push(`${member.displayName}: Already has emoji ${existingPlayer.emojiCode}`);
        continue;
      }
      
      console.log(`Creating emoji for ${member.displayName} (${memberId})`);
      const result = await createEmojiForUser(member, guild);
      
      if (result && result.success) {
        // Update player data with emoji
        await updatePlayer(guildId, memberId, { emojiCode: result.emojiCode });
        resultLines.push(`${member.displayName} ${result.emojiCode} (${result.isAnimated ? 'animated' : 'static'})`);
      }
    } catch (error) {
      console.error(`Error creating emoji for ${member.displayName}:`, error);
      
      // Handle specific error types
      let errorMessage = `${member.displayName}: Error creating emoji`;
      
      if (error.code === 30008) {
        errorMessage = `${member.displayName}: Maximum emoji limit reached for server`;
        maxEmojiReached = true;
      } else if (error.message?.includes('emoji name')) {
        errorMessage = `${member.displayName}: Invalid emoji name`;
      }
      
      errorLines.push(errorMessage);
    }
  }
  
  return {
    resultLines,
    existingLines,
    errorLines,
    maxEmojiReached
  };
}


// createEmojiForUser function moved to utils/emojiUtils.js (Phase 1A refactoring)

// Check if a role has existing emojis generated for its members
// checkRoleHasEmojis function moved to utils/emojiUtils.js (Phase 1A refactoring)

// clearEmojisForRole function moved to utils/emojiUtils.js (Phase 1A refactoring)

// Update calculateCastlistFields to handle role ID correctly and manage spacers intelligently
// calculateCastlistFields function moved to utils/castlistUtils.js (Phase 1A refactoring)

// Add this helper function before handling the castlist command
// createMemberFields function moved to utils/castlistUtils.js (Phase 1A refactoring)

// Add this helper function before the castlist command handler!
// determineCastlistToShow function moved to utils/castlistUtils.js (Phase 1A refactoring)

// Add reaction handlers near client.on('guildCreate') handlers
client.on('messageReactionAdd', async (reaction, user) => {
  try {
    if (user.bot) return;

    // When a reaction is received, check if the structure is partial
    if (reaction.partial) {
      // If the message this reaction belongs to was removed, the fetching might result in an API error
      try {
        await reaction.fetch();
      } catch (error) {
        console.error('Something went wrong when fetching the message:', error);
        return;
      }
    }

    // Check if this is an availability message
    let availabilityData = client.availabilityReactions?.get(reaction.message.id);
    
    // If not in memory, try loading from persistent storage
    if (!availabilityData) {
      const guildId = reaction.message.guild?.id;
      if (guildId) {
        const playerData = await loadPlayerData();
        const messageData = playerData[guildId]?.availabilityMessages?.[reaction.message.id];
        if (messageData) {
          // Restore to memory cache
          if (!client.availabilityReactions) client.availabilityReactions = new Map();
          availabilityData = {
            slots: messageData.slots,
            guildId: guildId,
            startHour: messageData.startHour
          };
          client.availabilityReactions.set(reaction.message.id, availabilityData);
          console.log(`Restored availability message ${reaction.message.id} from storage`);
        }
      }
    }
    
    if (availabilityData) {
      const guildInfo = reaction.message.guild
        ? `${reaction.message.guild.name} (${reaction.message.guild.id})`
        : 'DM';
      const channelName = reaction.message.channel?.name || reaction.message.channel?.id || 'unknown';
      console.log(`üîç DEBUG: Availability reaction added - Server: ${guildInfo} #${channelName}, Message: ${reaction.message.id}, Emoji: ${reaction.emoji.name}, User: ${user.tag} (ID: ${user.id})`);

      // Find which time slot this emoji corresponds to
      const slot = availabilityData.slots.find(s => s.emoji === reaction.emoji.name);
      if (!slot) {
        console.log(`No slot found for emoji ${reaction.emoji.name}`);
        return;
      }
      
      // Load player data
      const playerData = await loadPlayerData();
      const guildId = availabilityData.guildId;
      
      if (!playerData[guildId]) {
        playerData[guildId] = {};
      }
      if (!playerData[guildId].availability) {
        playerData[guildId].availability = {};
      }
      if (!playerData[guildId].availability[user.id]) {
        playerData[guildId].availability[user.id] = [];
      }
      
      // Add this UTC hour to the user's availability
      if (!playerData[guildId].availability[user.id].includes(slot.utcHour)) {
        playerData[guildId].availability[user.id].push(slot.utcHour);
        playerData[guildId].availability[user.id].sort((a, b) => a - b);
        await savePlayerData(playerData);
        console.log(`Added availability slot for UTC hour ${slot.utcHour} for user ${user.id}`);
      }
      
      return; // Don't process as a role reaction
    }

    // Check in-memory cache first, then persistent storage
    let roleMapping = client.roleReactions?.get(reaction.message.id);

    if (!roleMapping) {
      // Try to load from persistent storage
      const guildId = reaction.message.guild.id;
      roleMapping = await getReactionMapping(guildId, reaction.message.id);

      if (!roleMapping) return; // No mapping found

      // Cache it for future use
      if (!client.roleReactions) client.roleReactions = new Map();
      client.roleReactions.set(reaction.message.id, roleMapping);
    }

    const roleId = roleMapping[reaction.emoji.name];
    if (!roleId) return;

    const guild = reaction.message.guild;
    const channelName = reaction.message.channel?.name || reaction.message.channel?.id || 'unknown';
    console.log(`üîç DEBUG: Role reaction added - Server: ${guild.name} (${guild.id}) #${channelName}, Message: ${reaction.message.id}, Emoji: ${reaction.emoji.name}, User: ${user.tag} (ID: ${user.id})`);

    const member = await guild.members.fetch(user.id);

    // Check if client is ready before doing permission checks
    if (!client || !client.user) {
      console.error('‚ùå Client not ready in messageReactionAdd, skipping role assignment');
      return;
    }

    // Add permission check - pass client directly
    const permCheck = await checkRoleHierarchyPermission(guild, roleId, client);
    if (!permCheck.allowed) {
      // Remove the user's reaction to indicate failure
      await reaction.users.remove(user.id);
      
      // For ban mappings with missing role, post a channel message
      if (roleMapping.isBan && permCheck.reason.includes('Role not found (may have been deleted)')) {
        try {
          const channelId = reaction.message.channel.id;
          await fetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
            method: 'POST',
            headers: {
              Authorization: `Bot ${process.env.DISCORD_TOKEN}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              content: `‚ö†Ô∏è **${guild.name}** ‚Äî ${user.tag} clicked the React for Ban emoji, but the ban role is missing. Please ask the Production Team to re-run the React for Bans feature to resolve this.`
            })
          });
        } catch (notifyError) {
          console.error('Failed to post missing ban role notification:', notifyError.message);
        }
        console.error(`Ban role missing in ${guild.name}: ${permCheck.reason}`);
        return;
      }

      // Only send DM for actual errors, not for deleted roles (silent handling)
      if (!permCheck.reason.includes('Role not found (may have been deleted)')) {
        try {
          // Try to DM the user about the error
          await user.send(`Could not assign role in ${guild.name}: ${permCheck.reason}. Please contact a server admin to fix the bot's role position.`);
        } catch (dmError) {
          console.log('Could not DM user about role assignment failure');
        }
      }

      // Also log the error
      console.error(`Role assignment failed in ${guild.name}: ${permCheck.reason}`);
      return;
    }

    try {
      if (roleMapping.isBan) {
        // BAN TRAP ‚Äî auto-ban the user who reacted
        console.log(`üéØ BAN TRAP: User ${user.tag} (${user.id}) triggered React for Bans in ${guild.name}`);

        // Skip users with admin/mod permissions (protection against accidental self-ban)
        if (member.permissions.has(PermissionFlagsBits.ManageRoles) || member.permissions.has(PermissionFlagsBits.Administrator)) {
          console.log(`üõ°Ô∏è Skipping ban for ${user.tag} ‚Äî has admin/mod permissions`);
          await reaction.users.remove(user.id);
          return;
        }

        // Verify bot can ban this user (bot's highest role must be above target's highest role)
        const botMember = await guild.members.fetch(client.user.id);
        if (!botMember.permissions.has(PermissionFlagsBits.BanMembers)) {
          console.error(`‚ùå Bot lacks BanMembers permission in ${guild.name}`);
          await reaction.users.remove(user.id);
          return;
        }
        if (member.roles.highest.position >= botMember.roles.highest.position) {
          console.error(`‚ùå Cannot ban ${user.tag} ‚Äî their highest role (${member.roles.highest.name}, pos ${member.roles.highest.position}) is >= bot's highest role (${botMember.roles.highest.name}, pos ${botMember.roles.highest.position})`);
          await reaction.users.remove(user.id);
          return;
        }

        // Remove reaction first (visual feedback)
        await reaction.users.remove(user.id);

        // Execute ban
        await guild.members.ban(user.id, {
          reason: `CastBot React for Bans honeypot ‚Äî user reacted to ban trap message`
        });

        console.log(`üî® BANNED: ${user.tag} (${user.id}) from ${guild.name} via React for Bans`);

        // Post public notification in the channel
        try {
          const channelId = reaction.message.channel.id;
          await fetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
            method: 'POST',
            headers: {
              Authorization: `Bot ${process.env.DISCORD_TOKEN}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              content: `üî® **${guild.name}** ‚Äî ${user.tag} was banned by CastBot's üéØ React for Bans honeypot.`
            })
          });
        } catch (notifyError) {
          console.error('Failed to post ban notification:', notifyError.message);
        }
      } else if (roleMapping.isTimezone) {
        // Remove all other timezone roles first
        const timezones = await getGuildTimezones(guild.id);
        const timezoneRoleIds = Object.keys(timezones);
        const currentTimezoneRoles = member.roles.cache.filter(r => timezoneRoleIds.includes(r.id));

        if (currentTimezoneRoles.size > 0) {
          await member.roles.remove(currentTimezoneRoles.map(r => r.id));
        }

        await member.roles.add(roleId);
        console.log(`Set timezone role ${roleId} for user ${user.tag}`);
      } else {
        // Regular pronoun role - just add it
        await member.roles.add(roleId);
        console.log(`Added pronoun role ${roleId} to user ${user.tag}`);
      }
    } catch (error) {
      console.error('Error in role/ban action:', error);
      try { await reaction.users.remove(user.id); } catch (e) { /* user may already be banned */ }
    }
  } catch (error) {
    console.error('Error in messageReactionAdd:', error);
  }
});

client.on('messageReactionRemove', async (reaction, user) => {
  try {
    if (user.bot) return;

    // When a reaction is received, check if the structure is partial
    if (reaction.partial) {
      // If the message this reaction belongs to was removed, the fetching might result in an API error
      try {
        await reaction.fetch();
      } catch (error) {
        console.error('Something went wrong when fetching the message:', error);
        return;
      }
    }

    // Check if this is an availability message
    let availabilityData = client.availabilityReactions?.get(reaction.message.id);
    
    // If not in memory, try loading from persistent storage
    if (!availabilityData) {
      const guildId = reaction.message.guild?.id;
      if (guildId) {
        const playerData = await loadPlayerData();
        const messageData = playerData[guildId]?.availabilityMessages?.[reaction.message.id];
        if (messageData) {
          // Restore to memory cache
          if (!client.availabilityReactions) client.availabilityReactions = new Map();
          availabilityData = {
            slots: messageData.slots,
            guildId: guildId,
            startHour: messageData.startHour
          };
          client.availabilityReactions.set(reaction.message.id, availabilityData);
        }
      }
    }
    
    if (availabilityData) {
      const guildInfo = reaction.message.guild
        ? `${reaction.message.guild.name} (${reaction.message.guild.id})`
        : 'DM';
      const channelName = reaction.message.channel?.name || reaction.message.channel?.id || 'unknown';
      console.log(`üîç DEBUG: Availability reaction removed - Server: ${guildInfo} #${channelName}, Message: ${reaction.message.id}, Emoji: ${reaction.emoji.name}, User: ${user.tag} (ID: ${user.id})`);

      // Find which time slot this emoji corresponds to
      const slot = availabilityData.slots.find(s => s.emoji === reaction.emoji.name);
      if (!slot) return;
      
      // Load player data
      const playerData = await loadPlayerData();
      const guildId = availabilityData.guildId;
      
      if (playerData[guildId]?.availability?.[user.id]) {
        // Remove this UTC hour from the user's availability
        const index = playerData[guildId].availability[user.id].indexOf(slot.utcHour);
        if (index > -1) {
          playerData[guildId].availability[user.id].splice(index, 1);
          await savePlayerData(playerData);
          console.log(`Removed availability slot for UTC hour ${slot.utcHour} for user ${user.id}`);
        }
      }
      
      return; // Don't process as a role reaction
    }

    // Check in-memory cache first, then persistent storage
    let roleMapping = client.roleReactions?.get(reaction.message.id);

    if (!roleMapping) {
      // Try to load from persistent storage
      const guildId = reaction.message.guild.id;
      roleMapping = await getReactionMapping(guildId, reaction.message.id);

      if (!roleMapping) return; // No mapping found

      // Cache it for future use
      if (!client.roleReactions) client.roleReactions = new Map();
      client.roleReactions.set(reaction.message.id, roleMapping);
    }

    // Don't process reaction removal for ban traps (user is already banned)
    if (roleMapping.isBan) return;

    const roleId = roleMapping[reaction.emoji.name];
    if (!roleId) return;

    const guild = reaction.message.guild;
    const channelName = reaction.message.channel?.name || reaction.message.channel?.id || 'unknown';
    console.log(`üîç DEBUG: Role reaction removed - Server: ${guild.name} (${guild.id}) #${channelName}, Message: ${reaction.message.id}, Emoji: ${reaction.emoji.name}, User: ${user.tag} (ID: ${user.id})`);

    const member = await guild.members.fetch(user.id);

    // Add permission check here too - pass client directly
    const permCheck = await checkRoleHierarchyPermission(guild, roleId, client);
    if (!permCheck.allowed) {
      console.error(`Role removal failed in ${guild.name}: ${permCheck.reason}`);
      return;
    }

    try {
      await member.roles.remove(roleId);
      console.log(`Removed role ${roleId} from user ${user.tag}`);
    } catch (error) {
      console.error('Error removing role:', error);
    }
  } catch (error) {
    console.error('Error in messageReactionRemove:', error);
  }
});

// Clean up reaction mappings when messages are deleted
client.on('messageDelete', async (message) => {
  try {
    // Only process if we have a guild (not DM)
    if (!message.guild) return;
    
    // Check if this message had reaction mappings
    const hasMapping = client.roleReactions?.has(message.id);
    
    if (hasMapping) {
      // Remove from in-memory cache
      client.roleReactions.delete(message.id);
      
      // Remove from persistent storage
      await deleteReactionMapping(message.guild.id, message.id);
      
      console.log(`üóëÔ∏è Cleaned up reaction mapping for deleted message ${message.id} in guild ${message.guild.name}`);
    }
  } catch (error) {
    console.error('Error cleaning up reaction mapping on message delete:', error);
  }
});

// Add near other helper functions
// checkRoleHierarchyPermission function moved to utils/roleUtils.js (Phase 1A refactoring)

// Add this function to check if spacers should be omitted to fit within field limits
// shouldOmitSpacers function moved to utils/castlistUtils.js (Phase 1A refactoring)

// Helper functions for Safari config UI
function getGroupDisplayName(groupKey) {
  const names = {
    currency: 'Currency & Inventory Settings',
    events: 'Event Customization Settings', 
    rounds: 'Round Probability Settings'
  };
  return names[groupKey] || 'Safari Settings';
}

// Helper function to get action type display names
function getActionTypeName(actionType) {
  const actionTypeNames = {
    'display_text': 'Text Display Action',
    'update_currency': 'Update Currency Action',
    'give_currency': 'Give / Remove Currency Action',
    'give_item': 'Give / Remove Item Action',
    'follow_up_button': 'Follow-up Action',
    'conditional': 'Conditional Action',
    'random_outcome': 'Random Outcome Action'
  };
  return actionTypeNames[actionType] || 'Action';
}

function getButtonStyleName(style) {
  const styles = {
    1: 'Primary (Blue)',
    2: 'Secondary (Grey)',
    3: 'Success (Green)',
    4: 'Danger (Red)'
  };
  return styles[style] || 'Primary';
}

function getFieldDisplayName(fieldKey) {
  const labels = {
    currencyName: 'Currency Name',
    currencyEmoji: 'Currency Emoji', 
    inventoryName: 'Inventory Name',
    goodEventName: 'Good Event Name',
    badEventName: 'Bad Event Name',
    goodEventEmoji: 'Good Event Emoji',
    badEventEmoji: 'Bad Event Emoji',
    round1GoodProbability: 'Round 1 Probability',
    round2GoodProbability: 'Round 2 Probability',
    round3GoodProbability: 'Round 3 Probability'
  };
  return labels[fieldKey] || fieldKey;
}

// Add this helper function at the end of the file before the last closing bracket
// handleSetupTycoons function moved to utils/roleUtils.js (Phase 1A refactoring)

// Helper function to show drop configuration UI
async function showDropConfiguration(guildId, buttonId, actionIndex) {
  const { loadSafariContent } = await import('./safariManager.js');
  const safariData = await loadSafariContent();
  const button = safariData[guildId]?.buttons?.[buttonId];
  const action = button?.actions?.[actionIndex];
  
  if (!button || !action) {
    return {
      content: '‚ùå Action not found.',
      ephemeral: true
    };
  }
  
  const actionType = action.type;
  const dropType = action.config?.limit?.type || 'unlimited';
  const claimedCount = Array.isArray(action.config?.limit?.claimedBy) ? 
    action.config.limit.claimedBy.length : 
    (action.config?.limit?.claimedBy ? 1 : 0);
  
  return {
    components: [{
      type: 17, // Container
      components: [
        {
          type: 10, // Text Display
          content: `# Configure ${actionType === 'give_currency' ? 'Currency' : 'Item'} Drop\n\n**Action:** ${button.name || buttonId}\n**${actionType === 'give_currency' ? 'Amount' : 'Item'}: ${actionType === 'give_currency' ? action.config.amount : action.config.itemId} ${actionType === 'give_item' ? `x${action.config.quantity}` : ''}`
        },
        { type: 14 }, // Separator
        // Usage limit configuration
        {
          type: 9, // Section
          components: [{
            type: 10,
            content: `**Usage Limit:** ${dropType === 'once_per_player' ? 'Once per player' : dropType === 'once_globally' ? 'Once globally' : 'Unlimited'}\n*Claims: ${claimedCount}*`
          }],
          accessory: {
            type: 2, // Button
            custom_id: `safari_drop_type_${buttonId}_${actionIndex}`,
            label: 'Change',
            style: 2, // Secondary
            emoji: { name: 'üîÑ' }
          }
        },
        // Button style configuration
        {
          type: 9, // Section
          components: [{
            type: 10,
            content: `**Button Style:** ${getButtonStyleName(button.style || 1)}`
          }],
          accessory: {
            type: 2, // Button
            custom_id: `safari_drop_style_${buttonId}_${actionIndex}`,
            label: 'Change',
            style: 2,
            emoji: { name: 'üé®' }
          }
        },
        { type: 14 }, // Separator
        // Action buttons
        {
          type: 1, // Action Row
          components: [
            {
              type: 2, // Button
              custom_id: `safari_drop_reset_${buttonId}_${actionIndex}`,
              label: 'Reset Claims',
              style: 4, // Danger
              emoji: { name: 'üîÑ' },
              disabled: claimedCount === 0
            },
            {
              type: 2, // Button
              custom_id: `safari_drop_save_${buttonId}_${actionIndex}`,
              label: 'Save & Finish',
              style: 3, // Success
              emoji: { name: '‚úÖ' }
            }
          ]
        }
      ]
    }],
    flags: (1 << 15), // IS_COMPONENTS_V2
    ephemeral: true
  };
}

// Temporary state storage for give_item/give_currency configuration
const dropConfigState = new Map();

/**
 * Show configuration UI for give_item action
 */
async function showGiveItemConfig(guildId, buttonId, itemId, item, actionIndex) {
  // Get or create state for this configuration with sensible defaults
  const stateKey = `${guildId}_${buttonId}_${itemId}_${actionIndex}`;
  let state = dropConfigState.get(stateKey);

  // If no state exists, create with defaults and save it immediately
  if (!state) {
    state = {
      limit: 'once_per_player',   // Default to once per player (most common)
      style: '2',                 // Default to Secondary/Grey
      quantity: 1,                // Default to 1 item
      operation: 'give',          // Default to give (not remove)
      executeOn: 'true'           // Default to true
    };
    // CRITICAL: Save the default state so it's available when user clicks Save
    dropConfigState.set(stateKey, state);
  }

  // Check if there are existing claims to enable/disable reset button
  let claimsExist = false;
  try {
    const { loadSafariContent } = await import('./safariManager.js');
    const safariData = await loadSafariContent();
    const button = safariData[guildId]?.buttons?.[buttonId];
    if (button && button.actions && button.actions[actionIndex]) {
      const action = button.actions[actionIndex];
      if (action.type === 'give_item' && action.config?.limit) {
        const claimedBy = action.config.limit.claimedBy;
        if (action.config.limit.type === 'once_per_player') {
          claimsExist = Array.isArray(claimedBy) && claimedBy.length > 0;
        } else if (action.config.limit.type === 'once_globally') {
          claimsExist = claimedBy !== null && claimedBy !== undefined;
        }
      }
    }
  } catch (error) {
    console.error('Error checking claims:', error);
  }
  // Create quantity options (0-24, with state-based default)
  const quantityOptions = [];
  for (let i = 0; i <= 24; i++) {
    quantityOptions.push({
      label: i.toString(),
      value: i.toString(),
      description: i === 0 ? 'Remove this action' : undefined,
      default: state.quantity === i
    });
  }
  
  return {
    components: [{
      type: 17, // Container
      components: [
        {
          type: 10, // Text Display
          content: `# Configure ${item.emoji || 'üì¶'} ${item.name} Action\n\nSet how this item will be given or removed when the action is triggered.`
        },
        { type: 14 }, // Separator
        
        // Usage Limit Select
        {
          type: 1, // Action Row
          components: [{
            type: 3, // String Select
            custom_id: `safari_item_limit_${buttonId}_${itemId}_${actionIndex}`,
            placeholder: 'Select usage limit...',
            options: [
              {
                label: 'Unlimited',
                value: 'unlimited',
                description: 'Can be claimed infinite times',
                emoji: { name: '‚ôæÔ∏è' },
                default: state.limit === 'unlimited'
              },
              {
                label: 'Once Per Player',
                value: 'once_per_player',
                description: 'Each player can claim once',
                emoji: { name: 'üë§' },
                default: state.limit === 'once_per_player'
              },
              {
                label: 'Once Globally',
                value: 'once_globally',
                description: 'Only one player can claim',
                emoji: { name: 'üåç' },
                default: state.limit === 'once_globally'
              }
            ]
          }]
        },

        // Operation Type Select (Give vs Remove)
        {
          type: 1, // Action Row
          components: [{
            type: 3, // String Select
            custom_id: `safari_item_operation_${buttonId}_${itemId}_${actionIndex}`,
            placeholder: 'Select operation type...',
            options: [
              {
                label: 'Give Item',
                value: 'give',
                description: 'Adds the item to the player\'s inventory',
                emoji: { name: 'üéÅ' },
                default: state.operation !== 'remove'  // Default to give
              },
              {
                label: 'Remove Item',
                value: 'remove',
                description: 'Removes the item from the player\'s inventory, if it exists',
                emoji: { name: 'üß®' },
                default: state.operation === 'remove'
              }
            ]
          }]
        },

        // NOTE: Button style is set at parent Custom Action level via Trigger Type menu

        // Execute On Condition Select
        {
          type: 1, // Action Row
          components: [{
            type: 3, // String Select
            custom_id: `safari_item_execute_on_${buttonId}_${itemId}_${actionIndex}`,
            placeholder: 'When to execute this action...',
            options: [
              { 
                label: 'Execute if all conditions are true', 
                value: 'true', 
                emoji: { name: '‚úÖ' }, 
                default: state.executeOn !== 'false' // Default to true
              },
              { 
                label: 'Execute if all conditions are false', 
                value: 'false', 
                emoji: { name: '‚ùå' }, 
                default: state.executeOn === 'false' 
              }
            ]
          }]
        },
        
        // Quantity Select
        {
          type: 1, // Action Row
          components: [{
            type: 3, // String Select
            custom_id: `safari_item_quantity_${buttonId}_${itemId}_${actionIndex}`,
            placeholder: 'Select quantity...',
            options: quantityOptions.slice(0, 25) // Discord limit
          }]
        },
        
        { type: 14 }, // Separator
        
        // Action buttons
        {
          type: 1, // Action Row
          components: [
            {
              type: 2, // Button
              custom_id: `safari_item_reset_${buttonId}_${itemId}_${actionIndex}`,
              label: 'Reset Claims',
              style: 2, // Secondary (grey)
              emoji: { name: 'üîÑ' },
              disabled: !claimsExist // Enable when claims exist
            },
            {
              type: 2, // Button
              custom_id: `safari_remove_action_${buttonId}_${actionIndex}`,
              label: 'Delete Action',
              style: 4, // Danger (red)
              emoji: { name: 'üóëÔ∏è' }
            },
            {
              type: 2, // Button
              custom_id: `safari_item_save_${buttonId}_${itemId}_${actionIndex}`,
              label: 'Save & Finish',
              style: 3, // Success
              emoji: { name: '‚úÖ' }
            }
          ]
        }
      ]
    }],
    flags: (1 << 15), // IS_COMPONENTS_V2
    ephemeral: true
  };
}

/**
 * Show configuration UI for give_currency action
 */
async function showGiveCurrencyConfig(guildId, buttonId, actionIndex, customTerms) {
  // Get or create state for this configuration
  const stateKey = `${guildId}_${buttonId}_currency_${actionIndex}`;
  const state = dropConfigState.get(stateKey) || {
    limit: null,   // null means no selection made yet
    style: null,
    amount: null
  };

  // Check if there are existing claims to enable/disable reset button
  let claimsExist = false;
  try {
    const { loadSafariContent } = await import('./safariManager.js');
    const safariData = await loadSafariContent();
    const button = safariData[guildId]?.buttons?.[buttonId];
    if (button && button.actions && button.actions[actionIndex]) {
      const action = button.actions[actionIndex];
      if (action.type === 'give_currency' && action.config?.limit) {
        const claimedBy = action.config.limit.claimedBy;
        if (action.config.limit.type === 'once_per_player') {
          claimsExist = Array.isArray(claimedBy) && claimedBy.length > 0;
        } else if (action.config.limit.type === 'once_globally') {
          claimsExist = claimedBy !== null && claimedBy !== undefined;
        }
      }
    }
  } catch (error) {
    console.error('Error checking claims:', error);
  }
  
  return {
    components: [{
      type: 17, // Container
      components: [
        {
          type: 10, // Text Display
          content: `# Configure ${customTerms.currencyEmoji} ${customTerms.currencyName} Drop\n\nSet how ${customTerms.currencyName} will be given when the action is triggered.`
        },
        { type: 14 }, // Separator
        
        // Currency Amount (via modal button)
        {
          type: 9, // Section
          components: [{
            type: 10, // Text Display
            content: `**Amount:** ${state.amount !== null ? (state.amount > 0 ? `+${state.amount}` : `${state.amount}`) : 'Not set'}`
          }],
          accessory: {
            type: 2, // Button
            custom_id: `safari_currency_amount_${buttonId}_${actionIndex}`,
            label: 'Set Amount',
            style: 1, // Primary
            emoji: { name: 'üí∞' }
          }
        },
        
        // Usage Limit Select
        {
          type: 1, // Action Row
          components: [{
            type: 3, // String Select
            custom_id: `safari_currency_limit_${buttonId}_${actionIndex}`,
            placeholder: 'Select usage limit...',
            options: [
              {
                label: 'Unlimited',
                value: 'unlimited',
                description: 'Can be claimed infinite times',
                emoji: { name: '‚ôæÔ∏è' },
                default: state.limit === 'unlimited'
              },
              {
                label: 'Once Per Player',
                value: 'once_per_player',
                description: 'Each player can claim once',
                emoji: { name: 'üë§' },
                default: state.limit === 'once_per_player'
              },
              {
                label: 'Once Globally',
                value: 'once_globally',
                description: 'Only one player can claim',
                emoji: { name: 'üåç' },
                default: state.limit === 'once_globally'
              }
            ]
          }]
        },

        // NOTE: Button style is set at parent Custom Action level via Trigger Type menu

        // Execute On Condition Select
        {
          type: 1, // Action Row
          components: [{
            type: 3, // String Select
            custom_id: `safari_currency_execute_on_${buttonId}_${actionIndex}`,
            placeholder: 'When to execute this action...',
            options: [
              { 
                label: 'Execute if all conditions are true', 
                value: 'true', 
                emoji: { name: '‚úÖ' }, 
                default: state.executeOn !== 'false' // Default to true
              },
              { 
                label: 'Execute if all conditions are false', 
                value: 'false', 
                emoji: { name: '‚ùå' }, 
                default: state.executeOn === 'false' 
              }
            ]
          }]
        },
        
        { type: 14 }, // Separator
        
        // Action buttons
        {
          type: 1, // Action Row
          components: [
            {
              type: 2, // Button
              custom_id: `safari_currency_reset_${buttonId}_${actionIndex}`,
              label: 'Reset Claims',
              style: 2, // Secondary (grey)
              emoji: { name: 'üîÑ' },
              disabled: !claimsExist // Enable when claims exist
            },
            {
              type: 2, // Button
              custom_id: `safari_remove_action_${buttonId}_${actionIndex}`,
              label: 'Delete Action',
              style: 4, // Danger (red)
              emoji: { name: 'üóëÔ∏è' }
            },
            {
              type: 2, // Button
              custom_id: `safari_currency_save_${buttonId}_${actionIndex}`,
              label: 'Save & Finish',
              style: 3, // Success
              emoji: { name: '‚úÖ' }
            }
          ]
        }
      ]
    }],
    flags: (1 << 15), // IS_COMPONENTS_V2
    ephemeral: true
  };
}

/**
 * Show configuration UI for follow_up_button action
 */
async function showFollowUpConfig(guildId, buttonId, targetButtonId, actionIndex) {
  // Get or create state for this configuration
  const stateKey = `${guildId}_${buttonId}_followup_${actionIndex}`;
  const state = dropConfigState.get(stateKey) || {
    targetButtonId: targetButtonId,
    executeOn: 'true'  // Default to 'true' for backwards compatibility
  };
  
  // Load safari data to get button information
  const { loadSafariContent, getCustomButton } = await import('./safariManager.js');
  const targetButton = await getCustomButton(guildId, targetButtonId);
  
  if (!targetButton) {
    return {
      content: '‚ùå Target button not found.',
      components: [],
      ephemeral: true
    };
  }
  
  // Build the configuration UI
  return {
    components: [{
      type: 17, // Container
      accent_color: 0x5865f2,
      components: [
          {
            type: 10, // Text Display
            content: `## üîó Follow-up Action Configuration\nConfiguring follow-up action for **${targetButton.name}**`
          },
          
          { type: 14 }, // Separator
          
          // Selected button display
          {
            type: 10,
            content: `### Selected Button\n${targetButton.emoji || 'üìå'} **${targetButton.name}**\n*${targetButton.description || 'No description'}*`
          },
          
          { type: 14 }, // Separator
          
          // Execute on selector
          {
            type: 10,
            content: '### Execution Condition\nWhen should this follow-up action be triggered?'
          },
          {
            type: 1, // Action Row
            components: [{
              type: 3, // String Select
              custom_id: `safari_followup_execute_on_${buttonId}_${targetButtonId}_${actionIndex}`,
              placeholder: 'Select when to execute...',
              options: [
                {
                  label: 'Execute if all conditions are TRUE',
                  value: 'true',
                  description: 'Only show follow-up when conditions are met',
                  emoji: { name: '‚úÖ' },
                  default: state.executeOn === 'true'
                },
                {
                  label: 'Execute if all conditions are FALSE',
                  value: 'false',
                  description: 'Only show follow-up when conditions are NOT met',
                  emoji: { name: '‚ùå' },
                  default: state.executeOn === 'false'
                }
              ]
            }]
          },
          
          { type: 14 }, // Separator
          
          // Action buttons
          {
            type: 1, // Action Row
            components: [
              {
                type: 2, // Button
                custom_id: `custom_action_editor_${buttonId}`,
                label: 'Cancel',
                style: 2, // Secondary
                emoji: { name: '‚Ü©Ô∏è' }
              },
              {
                type: 2, // Button
                custom_id: `safari_remove_action_${buttonId}_${actionIndex}`,
                label: 'Delete Action',
                style: 4, // Danger (red)
                emoji: { name: 'üóëÔ∏è' }
              },
              {
                type: 2, // Button
                custom_id: `safari_followup_save_${buttonId}_${targetButtonId}_${actionIndex}`,
                label: 'Save & Finish',
                style: 3, // Success
                emoji: { name: '‚úÖ' }
              }
            ]
          }
        ]
      }],
      flags: (1 << 15), // IS_COMPONENTS_V2
      ephemeral: true
  };
}

